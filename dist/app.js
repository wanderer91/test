/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/components/Scheduler.vue":
/*!*************************************!*\
  !*** ./js/components/Scheduler.vue ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Scheduler_vue_vue_type_template_id_0f4b6a6c_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scheduler.vue?vue&type=template&id=0f4b6a6c&scoped=true& */ \"./js/components/Scheduler.vue?vue&type=template&id=0f4b6a6c&scoped=true&\");\n/* harmony import */ var _Scheduler_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Scheduler.vue?vue&type=script&lang=js& */ \"./js/components/Scheduler.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _Scheduler_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Scheduler_vue_vue_type_template_id_0f4b6a6c_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _Scheduler_vue_vue_type_template_id_0f4b6a6c_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  \"0f4b6a6c\",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"js/components/Scheduler.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./js/components/Scheduler.vue?");

/***/ }),

/***/ "./js/components/Scheduler.vue?vue&type=script&lang=js&":
/*!**************************************************************!*\
  !*** ./js/components/Scheduler.vue?vue&type=script&lang=js& ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_3_node_modules_vue_loader_lib_index_js_vue_loader_options_Scheduler_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib??ref--3!../../node_modules/vue-loader/lib??vue-loader-options!./Scheduler.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js?!./node_modules/vue-loader/lib/index.js?!./js/components/Scheduler.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_3_node_modules_vue_loader_lib_index_js_vue_loader_options_Scheduler_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./js/components/Scheduler.vue?");

/***/ }),

/***/ "./js/components/Scheduler.vue?vue&type=template&id=0f4b6a6c&scoped=true&":
/*!********************************************************************************!*\
  !*** ./js/components/Scheduler.vue?vue&type=template&id=0f4b6a6c&scoped=true& ***!
  \********************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Scheduler_vue_vue_type_template_id_0f4b6a6c_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib??vue-loader-options!./Scheduler.vue?vue&type=template&id=0f4b6a6c&scoped=true& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./js/components/Scheduler.vue?vue&type=template&id=0f4b6a6c&scoped=true&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Scheduler_vue_vue_type_template_id_0f4b6a6c_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Scheduler_vue_vue_type_template_id_0f4b6a6c_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./js/components/Scheduler.vue?");

/***/ }),

/***/ "./js/source.js":
/*!**********************!*\
  !*** ./js/source.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_Scheduler_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Scheduler.vue */ \"./js/components/Scheduler.vue\");\nwindow.Vue = __webpack_require__(/*! vue/dist/vue.min.js */ \"./node_modules/vue/dist/vue.min.js\");\nwindow.BootstrapVue = __webpack_require__(/*! bootstrap-vue/dist/bootstrap-vue */ \"./node_modules/bootstrap-vue/dist/bootstrap-vue.js\");\nwindow.VueRouter = __webpack_require__(/*! vue-router */ \"./node_modules/vue-router/dist/vue-router.esm.js\");\nVue.use(BootstrapVue);\nVue.use(VueRouter);\n\nvar app = new Vue({\n  el: '#app',\n  data: function data() {},\n  mounted: function mounted() {},\n  components: {\n    Scheduler: _components_Scheduler_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n  }\n});\n\n//# sourceURL=webpack:///./js/source.js?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/vue-loader/lib/index.js?!./js/components/Scheduler.vue?vue&type=script&lang=js&":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/lib??vue-loader-options!./js/components/Scheduler.vue?vue&type=script&lang=js& ***!
  \********************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: \"Scheduler\"\n});\n\n//# sourceURL=webpack:///./js/components/Scheduler.vue?./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/bootstrap-vue/dist/bootstrap-vue.js":
/*!**********************************************************!*\
  !*** ./node_modules/bootstrap-vue/dist/bootstrap-vue.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj){if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof2=function _typeof2(obj){return typeof obj;};}else{_typeof2=function _typeof2(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof2(obj);}(function(global,factory){( false?undefined:_typeof2(exports))==='object'&&typeof module!=='undefined'?module.exports=factory(): true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):(undefined);})(this,function(){'use strict';function _typeof(obj){if(typeof Symbol===\"function\"&&_typeof2(Symbol.iterator)===\"symbol\"){_typeof=function _typeof(obj){return _typeof2(obj);};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":_typeof2(obj);};}return _typeof(obj);}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==='function'){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable;}));}ownKeys.forEach(function(key){_defineProperty(target,key,source[key]);});}return target;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function\");}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});if(superClass)_setPrototypeOf(subClass,superClass);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _possibleConstructorReturn(self,call){if(call&&(_typeof2(call)===\"object\"||typeof call===\"function\")){return call;}return _assertThisInitialized(self);}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)===\"[object Arguments]\")return Array.from(iter);}function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance\");}var _assign=function __assign(){return(_assign=Object.assign||function(e){for(var a,s=1,t=arguments.length;s<t;s++){for(var r in a=arguments[s]){Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r]);}}return e;}).apply(this,arguments);};function mergeData(){for(var e,a,s={},t=arguments.length;t--;){for(var r=0,c=Object.keys(arguments[t]);r<c.length;r++){switch(e=c[r]){case\"class\":case\"style\":case\"directives\":Array.isArray(s[e])||(s[e]=[]),s[e]=s[e].concat(arguments[t][e]);break;case\"staticClass\":if(!arguments[t][e])break;void 0===s[e]&&(s[e]=\"\"),s[e]&&(s[e]+=\" \"),s[e]+=arguments[t][e].trim();break;case\"on\":case\"nativeOn\":s[e]||(s[e]={});for(var n=0,o=Object.keys(arguments[t][e]||{});n<o.length;n++){a=o[n],s[e][a]?s[e][a]=[].concat(s[e][a],arguments[t][e][a]):s[e][a]=arguments[t][e][a];}break;case\"attrs\":case\"props\":case\"domProps\":case\"scopedSlots\":case\"staticStyle\":case\"hook\":case\"transition\":s[e]||(s[e]={}),s[e]=_assign({},arguments[t][e],s[e]);break;case\"slot\":case\"key\":case\"ref\":case\"tag\":case\"show\":case\"keepAlive\":default:s[e]||(s[e]=arguments[t][e]);}}}return s;}var props={disabled:{type:Boolean,default:false},ariaLabel:{type:String,default:'Close'},textVariant:{type:String,default:null// @vue/component\n}};var BButtonClose={name:'BButtonClose',functional:true,props:props,render:function render(h,_ref){var props=_ref.props,data=_ref.data,listeners=_ref.listeners,slots=_ref.slots;var componentData={staticClass:'close',class:_defineProperty({},\"text-\".concat(props.textVariant),props.textVariant),attrs:{type:'button',disabled:props.disabled,'aria-label':props.ariaLabel?String(props.ariaLabel):null},on:{click:function click(e){// Ensure click on button HTML content is also disabled\n/* istanbul ignore if: bug in JSDOM still emits click on inner element */if(props.disabled&&e instanceof Event){e.stopPropagation();e.preventDefault();}}// Careful not to override the default slot with innerHTML\n}};if(!slots().default){componentData.domProps={innerHTML:'&times;'};}return h('button',mergeData(data,componentData),slots().default);}};var BAlert={name:'BAlert',components:{BButtonClose:BButtonClose},model:{prop:'show',event:'input'},props:{variant:{type:String,default:'info'},dismissible:{type:Boolean,default:false},dismissLabel:{type:String,default:'Close'},show:{type:[Boolean,Number],default:false},fade:{type:Boolean,default:false}},data:function data(){return{countDownTimerId:null,dismissed:false};},computed:{classObject:function classObject(){return['alert',this.alertVariant,this.dismissible?'alert-dismissible':''];},alertVariant:function alertVariant(){var variant=this.variant;return\"alert-\".concat(variant);},localShow:function localShow(){return!this.dismissed&&(this.countDownTimerId||this.show);}},watch:{show:function show(){this.showChanged();}},mounted:function mounted(){this.showChanged();},destroyed/* istanbul ignore next */:function destroyed(){this.clearCounter();},methods:{dismiss:function dismiss(){this.clearCounter();this.dismissed=true;this.$emit('dismissed');this.$emit('input',false);if(typeof this.show==='number'){this.$emit('dismiss-count-down',0);this.$emit('input',0);}else{this.$emit('input',false);}},clearCounter:function clearCounter(){if(this.countDownTimerId){clearInterval(this.countDownTimerId);this.countDownTimerId=null;}},showChanged:function showChanged(){var _this=this;// Reset counter status\nthis.clearCounter();// Reset dismiss status\nthis.dismissed=false;// No timer for boolean values\nif(this.show===true||this.show===false||this.show===null||this.show===0){return;}// Start counter (ensure we have an integer value)\nvar dismissCountDown=parseInt(this.show,10)||1;this.countDownTimerId=setInterval(function(){if(dismissCountDown<1){_this.dismiss();return;}dismissCountDown--;_this.$emit('dismiss-count-down',dismissCountDown);_this.$emit('input',dismissCountDown);},1000);}},render:function render(h){if(!this.localShow){// If not showing, render placeholder\nreturn h(false);}var dismissBtn=h(false);if(this.dismissible){// Add dismiss button\ndismissBtn=h('b-button-close',{attrs:{'aria-label':this.dismissLabel},on:{click:this.dismiss}},[this.$slots.dismiss]);}var alert=h('div',{class:this.classObject,attrs:{role:'alert','aria-live':'polite','aria-atomic':true}},[dismissBtn,this.$slots.default]);return!this.fade?alert:h('transition',{props:{name:'fade',appear:true}},[alert]);}};/**\n   * Load a component.\n   * @param {object} Vue\n   * @param {string} Component name\n   * @param {object} Component definition\n   */var registerComponent=function registerComponent(Vue,name,def){Vue.component(name,def);};/**\n   * Load a group of components.\n   * @param {object} Vue\n   * @param {object} Object of component definitions\n   */var registerComponents=function registerComponents(Vue,components){for(var component in components){registerComponent(Vue,component,components[component]);}};/**\n   * Load a directive.\n   * @param {object} Vue\n   * @param {string} Directive name\n   * @param {object} Directive definition\n   */var registerDirective=function registerDirective(Vue,name,def){Vue.directive(name,def);};/**\n   * Load a group of directives.\n   * @param {object} Vue\n   * @param {object} Object of directive definitions\n   */var registerDirectives=function registerDirectives(Vue,directives){for(var directive in directives){registerDirective(Vue,directive,directives[directive]);}};/**\n   * Install plugin if window.Vue available\n   * @param {object} Plugin definition\n   */var vueUse=function vueUse(VuePlugin){/* istanbul ignore next */if(typeof window!=='undefined'&&window.Vue){window.Vue.use(VuePlugin);}};var components={BAlert:BAlert};var index={install:function install(Vue){registerComponents(Vue,components);}};/**\n   * Aliasing Object[method] allows the minifier to shorten methods to a single character variable,\n   * as well as giving BV a chance to inject polyfills.\n   * As long as we avoid\n   * - import * as Object from \"utils/object\"\n   * all unused exports should be removed by tree-shaking.\n   */ // @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n/* istanbul ignore if */if(typeof Object.assign!=='function'){Object.assign=function(target,varArgs){// .length of function is 2\nif(target==null){// TypeError if undefined or null\nthrow new TypeError('Cannot convert undefined or null to object');}var to=Object(target);for(var index=1;index<arguments.length;index++){var nextSource=arguments[index];if(nextSource!=null){// Skip over if undefined or null\nfor(var nextKey in nextSource){// Avoid bugs when hasOwnProperty is shadowed\nif(Object.prototype.hasOwnProperty.call(nextSource,nextKey)){to[nextKey]=nextSource[nextKey];}}}}return to;};}// @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Polyfill\n/* istanbul ignore if */if(!Object.is){Object.is=function(x,y){// SameValue algorithm\nif(x===y){// Steps 1-5, 7-10\n// Steps 6.b-6.e: +0 != -0\nreturn x!==0||1/x===1/y;}else{// Step 6.a: NaN == NaN\n// eslint-disable-next-line no-self-compare\nreturn x!==x&&y!==y;}};}var assign=Object.assign;var keys=Object.keys;var defineProperties=Object.defineProperties;var defineProperty=Object.defineProperty;var create=Object.create;/**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   * Note object could be a complex type like array, date, etc.\n   */var isObject=function isObject(obj){return obj!==null&&_typeof(obj)==='object';};/**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */var isPlainObject=function isPlainObject(obj){return Object.prototype.toString.call(obj)==='[object Object]';};// @link https://gist.github.com/bisubus/2da8af7e801ffd813fab7ac221aa7afc\nvar omit=function omit(obj,props){return Object.keys(obj).filter(function(key){return props.indexOf(key)===-1;}).reduce(function(result,key){return _objectSpread({},result,_defineProperty({},key,obj[key]));},{});};var readonlyDescriptor=function readonlyDescriptor(){return{enumerable:true,configurable:false,writable:false};};// Production steps of ECMA-262, Edition 6, 22.1.2.1\n// es6-ified by @alexsasharegan\n/* istanbul ignore if */if(!Array.from){Array.from=function(){var toStr=Object.prototype.toString;var isCallable=function isCallable(fn){return typeof fn==='function'||toStr.call(fn)==='[object Function]';};var toInteger=function toInteger(value){var number=Number(value);if(isNaN(number)){return 0;}if(number===0||!isFinite(number)){return number;}return(number>0?1:-1)*Math.floor(Math.abs(number));};var maxSafeInteger=Math.pow(2,53)-1;var toLength=function toLength(value){return Math.min(Math.max(toInteger(value),0),maxSafeInteger);};// The length property of the from method is 1.\nreturn function from(arrayLike/*, mapFn, thisArg */){// 1. Let C be the this value.\nvar C=this;// 2. Let items be ToObject(arrayLike).\nvar items=Object(arrayLike);// 3. ReturnIfAbrupt(items).\nif(arrayLike==null){throw new TypeError('Array.from requires an array-like object - not null or undefined');}// 4. If mapfn is undefined, then let mapping be false.\nvar mapFn=arguments.length>1?arguments[1]:void undefined;var T;if(typeof mapFn!=='undefined'){// 5. else\n// 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\nif(!isCallable(mapFn)){throw new TypeError('Array.from: when provided, the second argument must be a function');}// 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\nif(arguments.length>2){T=arguments[2];}}// 10. Let lenValue be Get(items, \"length\").\n// 11. Let len be ToLength(lenValue).\nvar len=toLength(items.length);// 13. If IsConstructor(C) is true, then\n// 13. a. Let A be the result of calling the [[Construct]] internal method\n// of C with an argument list containing the single item len.\n// 14. a. Else, Let A be ArrayCreate(len).\nvar A=isCallable(C)?Object(new C(len)):new Array(len);// 16. Let k be 0.\nvar k=0;// 17. Repeat, while k < len… (also steps a - h)\nvar kValue;while(k<len){kValue=items[k];if(mapFn){A[k]=typeof T==='undefined'?mapFn(kValue,k):mapFn.call(T,kValue,k);}else{A[k]=kValue;}k+=1;}// 18. Let putStatus be Put(A, \"length\", len, true).\nA.length=len;// 20. Return A.\nreturn A;};}();}// https://tc39.github.io/ecma262/#sec-array.prototype.find\n// Needed for IE support\n/* istanbul ignore if */if(!Array.prototype.find){// eslint-disable-next-line no-extend-native\nObject.defineProperty(Array.prototype,'find',{value:function value(predicate){// 1. Let O be ? ToObject(this value).\nif(this==null){throw new TypeError('\"this\" is null or not defined');}var o=Object(this);// 2. Let len be ? ToLength(? Get(O, \"length\")).\nvar len=o.length>>>0;// 3. If IsCallable(predicate) is false, throw a TypeError exception.\nif(typeof predicate!=='function'){throw new TypeError('predicate must be a function');}// 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\nvar thisArg=arguments[1];// 5. Let k be 0.\nvar k=0;// 6. Repeat, while k < len\nwhile(k<len){// a. Let Pk be ! ToString(k).\n// b. Let kValue be ? Get(O, Pk).\n// c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n// d. If testResult is true, return kValue.\nvar kValue=o[k];if(predicate.call(thisArg,kValue,k,o)){return kValue;}// e. Increase k by 1.\nk++;}// 7. Return undefined.\nreturn undefined;}});}/* istanbul ignore if */if(!Array.isArray){Array.isArray=function(arg){return Object.prototype.toString.call(arg)==='[object Array]';};}// Static\nvar from=Array.from;var isArray=Array.isArray;// Instance\nvar arrayIncludes=function arrayIncludes(array,value){return array.indexOf(value)!==-1;};var concat=function concat(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return Array.prototype.concat.apply([],args);};var identity=function identity(x){return x;};/**\n   * Given an array of properties or an object of property keys,\n   * plucks all the values off the target object, returning a new object\n   * that has props that reference the original prop values\n   *\n   * @param {{}|string[]} keysToPluck\n   * @param {{}} objToPluck\n   * @param {Function} transformFn\n   * @return {{}}\n   */var pluckProps=function pluckProps(keysToPluck,objToPluck){var transformFn=arguments.length>2&&arguments[2]!==undefined?arguments[2]:identity;return(isArray(keysToPluck)?keysToPluck.slice():keys(keysToPluck)).reduce(function(memo,prop){memo[transformFn(prop)]=objToPluck[prop];return memo;},{});};/**\n   * Convert a value to a string that can be rendered.\n   */var toString=function toString(val){var spaces=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2;return val===null||val===undefined?'':isArray(val)||isPlainObject(val)&&val.toString===Object.prototype.toString?JSON.stringify(val,null,spaces):String(val);};var ANCHOR_TAG='a';// Precompile RegExp\nvar commaRE=/%2C/g;var encodeReserveRE=/[!'()*]/g;// Method to replace reserved chars\nvar encodeReserveReplacer=function encodeReserveReplacer(c){return'%'+c.charCodeAt(0).toString(16);};// Fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode=function encode(str){return encodeURIComponent(toString(str)).replace(encodeReserveRE,encodeReserveReplacer).replace(commaRE,',');};var decode=decodeURIComponent;// Stringifies an object of query parameters\n// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js\nvar stringifyQueryObj=function stringifyQueryObj(obj){if(!isPlainObject(obj)){return'';}var query=keys(obj).map(function(key){var val=obj[key];if(val===undefined){return'';}else if(val===null){return encode(key);}else if(isArray(val)){return val.reduce(function(results,val2){if(val2===null){results.push(encode(key));}else if(val2!==undefined){// Faster than string interpolation\nresults.push(encode(key)+'='+encode(val2));}return results;},[]).join('&');}// Faster than string interpolation\nreturn encode(key)+'='+encode(val);})/* must check for length, as we only want to filter empty strings, not things that look falsey! */.filter(function(x){return x.length>0;}).join('&');return query?\"?\".concat(query):'';};var parseQuery=function parseQuery(query){var parsed={};query=toString(query).trim().replace(/^(\\?|#|&)/,'');if(!query){return parsed;}query.split('&').forEach(function(param){var parts=param.replace(/\\+/g,' ').split('=');var key=decode(parts.shift());var val=parts.length>0?decode(parts.join('=')):null;if(parsed[key]===undefined){parsed[key]=val;}else if(isArray(parsed[key])){parsed[key].push(val);}else{parsed[key]=[parsed[key],val];}});return parsed;};var isRouterLink=function isRouterLink(tag){return tag!==ANCHOR_TAG;};var computeTag=function computeTag(){var _ref=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},to=_ref.to,disabled=_ref.disabled;var thisOrParent=arguments.length>1?arguments[1]:undefined;return thisOrParent.$router&&to&&!disabled?thisOrParent.$nuxt?'nuxt-link':'router-link':ANCHOR_TAG;};var computeRel=function computeRel(){var _ref2=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},target=_ref2.target,rel=_ref2.rel;if(target==='_blank'&&rel===null){return'noopener';}return rel||null;};var computeHref=function computeHref(){var _ref3=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},href=_ref3.href,to=_ref3.to;var tag=arguments.length>1&&arguments[1]!==undefined?arguments[1]:ANCHOR_TAG;var fallback=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'#';var toFallback=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'/';// We've already checked the $router in computeTag(), so isRouterLink() indicates a live router.\n// When deferring to Vue Router's router-link, don't use the href attribute at all.\n// We return null, and then remove href from the attributes passed to router-link\nif(isRouterLink(tag)){return null;}// Return `href` when explicitly provided\nif(href){return href;}// Reconstruct `href` when `to` used, but no router\nif(to){// Fallback to `to` prop (if `to` is a string)\nif(typeof to==='string'){return to||toFallback;}// Fallback to `to.path + to.query + to.hash` prop (if `to` is an object)\nif(isPlainObject(to)&&(to.path||to.query||to.hash)){var path=toString(to.path);var query=stringifyQueryObj(to.query);var hash=toString(to.hash);hash=!hash||hash.charAt(0)==='#'?hash:\"#\".concat(hash);return\"\".concat(path).concat(query).concat(hash)||toFallback;}}// If nothing is provided return the fallback\nreturn fallback;};/**\n   * The Link component is used in many other BV components.\n   * As such, sharing its props makes supporting all its features easier.\n   * However, some components need to modify the defaults for their own purpose.\n   * Prefer sharing a fresh copy of the props to ensure mutations\n   * do not affect other component references to the props.\n   *\n   * https://github.com/vuejs/vue-router/blob/dev/src/components/link.js\n   * @return {{}}\n   */function propsFactory(){return{href:{type:String,default:null},rel:{type:String,default:null},target:{type:String,default:'_self'},active:{type:Boolean,default:false},disabled:{type:Boolean,default:false},// router-link specific props\nto:{type:[String,Object],default:null},append:{type:Boolean,default:false},replace:{type:Boolean,default:false},event:{type:[String,Array],default:'click'},activeClass:{type:String// default: undefined\n},exact:{type:Boolean,default:false},exactActiveClass:{type:String// default: undefined\n},routerTag:{type:String,default:'a'},// nuxt-link specific prop(s)\nnoPrefetch:{type:Boolean,default:false}};}function clickHandlerFactory(_ref){var disabled=_ref.disabled,tag=_ref.tag,href=_ref.href,suppliedHandler=_ref.suppliedHandler,parent=_ref.parent;return function onClick(evt){if(disabled&&evt instanceof Event){// Stop event from bubbling up.\nevt.stopPropagation();// Kill the event loop attached to this specific EventTarget.\nevt.stopImmediatePropagation();}else{if(isRouterLink(tag)&&evt.target.__vue__){// Router links do not emit instance 'click' events, so we\n// add in an $emit('click', evt) on it's vue instance\nevt.target.__vue__.$emit('click',evt);}if(typeof suppliedHandler==='function'){suppliedHandler.apply(void 0,arguments);}parent.$root.$emit('clicked::link',evt);}if(!isRouterLink(tag)&&href==='#'||disabled){// Stop scroll-to-top behavior or navigation on regular links\n// when href is just '#'\nevt.preventDefault();}};}// @vue/component\nvar BLink={name:'BLink',functional:true,props:propsFactory(),render:function render(h,_ref2){var props=_ref2.props,data=_ref2.data,parent=_ref2.parent,children=_ref2.children;var tag=computeTag(props,parent);var rel=computeRel(props);var href=computeHref(props,tag);var eventType=isRouterLink(tag)?'nativeOn':'on';var suppliedHandler=(data[eventType]||{}).click;var handlers={click:clickHandlerFactory({tag:tag,href:href,disabled:props.disabled,suppliedHandler:suppliedHandler,parent:parent})};var componentData=mergeData(data,{class:{active:props.active,disabled:props.disabled},attrs:{rel:rel,target:props.target,tabindex:props.disabled?'-1':data.attrs?data.attrs.tabindex:null,'aria-disabled':props.disabled?'true':null},props:_objectSpread({},props,{tag:props.routerTag})});// If href attribute exists on router-link (even undefined or null) it fails working on SSR\n// So we explicitly add it here if needed (i.e. if computeHref() is truthy)\nif(href){componentData.attrs.href=href;}// We want to overwrite any click handler since our callback\n// will invoke the user supplied handler if !props.disabled\ncomponentData[eventType]=_objectSpread({},componentData[eventType]||{},handlers);return h(tag,componentData,children);}};var linkProps=propsFactory();delete linkProps.href.default;delete linkProps.to.default;var props$1=_objectSpread({},linkProps,{tag:{type:String,default:'span'},variant:{type:String,default:'secondary'},pill:{type:Boolean,default:false// @vue/component\n}});var BBadge={name:'BBadge',functional:true,props:props$1,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var tag=!props.href&&!props.to?props.tag:BLink;var componentData={staticClass:'badge',class:[!props.variant?'badge-secondary':\"badge-\".concat(props.variant),{'badge-pill':Boolean(props.pill),active:props.active,disabled:props.disabled}],props:pluckProps(linkProps,props)};return h(tag,mergeData(data,componentData),children);}};var components$1={BBadge:BBadge};var index$1={install:function install(Vue){registerComponents(Vue,components$1);}};var stripTagsRegex=/(<([^>]+)>)/gi;// Removes any thing that looks like an HTML tag from the supplied string\nvar stripTags=function stripTags(){var text=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';return String(text).replace(stripTagsRegex,'');};// Generate a domProps object for either innerHTML, textContent or nothing\nvar htmlOrText=function htmlOrText(innerHTML,textContent){return innerHTML?{innerHTML:innerHTML}:textContent?{textContent:textContent}:{};};var props$2=_objectSpread({},propsFactory(),{text:{type:String,default:null},html:{type:String,default:null},ariaCurrent:{type:String,default:'location'// @vue/component\n}});var BBreadcrumbLink={name:'BBreadcrumbLink',functional:true,props:props$2,render:function render(h,_ref){var suppliedProps=_ref.props,data=_ref.data,children=_ref.children;var tag=suppliedProps.active?'span':BLink;var componentData={props:pluckProps(props$2,suppliedProps)};if(suppliedProps.active){componentData.attrs={'aria-current':suppliedProps.ariaCurrent};}if(!children){componentData.domProps=htmlOrText(suppliedProps.html,suppliedProps.text);}return h(tag,mergeData(data,componentData),children);}};var BBreadcrumbItem={name:'BBreadcrumbItem',functional:true,props:props$2,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h('li',mergeData(data,{staticClass:'breadcrumb-item',class:{active:props.active},attrs:{role:'presentation'}}),[h(BBreadcrumbLink,{props:props},children)]);}};var props$3={items:{type:Array,default:null// @vue/component\n}};var BBreadcrumb={name:'BBreadcrumb',functional:true,props:props$3,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var childNodes=children;// Build child nodes from items if given.\nif(isArray(props.items)){var activeDefined=false;childNodes=props.items.map(function(item,idx){if(_typeof(item)!=='object'){item={text:toString(item)};}// Copy the value here so we can normalize it.\nvar active=item.active;if(active){activeDefined=true;}if(!active&&!activeDefined){// Auto-detect active by position in list.\nactive=idx+1===props.items.length;}return h(BBreadcrumbItem,{props:_objectSpread({},item,{active:active})});});}return h('ol',mergeData(data,{staticClass:'breadcrumb'}),childNodes);}};var components$2={BBreadcrumb:BBreadcrumb,BBreadcrumbItem:BBreadcrumbItem,BBreadcrumbLink:BBreadcrumbLink};var index$2={install:function install(Vue){registerComponents(Vue,components$2);}};// Info about the current environment\nvar inBrowser=typeof document!=='undefined'&&typeof window!=='undefined';var isServer=!inBrowser;var hasTouchSupport=inBrowser&&('ontouchstart'in document.documentElement||navigator.maxTouchPoints>0);var hasPointerEvent=inBrowser&&Boolean(window.PointerEvent||window.MSPointerEvent);var passiveEventSupported=false;/* istanbul ignore if */if(inBrowser){try{var options={get passive(){// This function will be called when the browser\n// attempts to access the passive property.\npassiveEventSupported=true;}};window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(err){passiveEventSupported=false;}}// Exported only for testing purposes\n// Exported only for testing purposes\nvar parseEventOptions=function parseEventOptions(options){if(!passiveEventSupported){// Need to translate to actual Boolean value\nreturn Boolean(isObject(options)?options.useCapture:options);}/* istanbul ignore next: JSDOM doesn't support above detection of passive */return options||{useCapture:false// So we can't reach this anymore for unit testing due to the above if statement\n};};// Attach an event listener to an element\nvar eventOn=function eventOn(el,evtName,handler,options){if(el&&el.addEventListener){el.addEventListener(evtName,handler,parseEventOptions(options));}};// Remove an event listener from an element\nvar eventOff=function eventOff(el,evtName,handler,options){if(el&&el.removeEventListener){el.removeEventListener(evtName,handler,parseEventOptions(options));}};// Determine if an element is an HTML Element\nvar isElement=function isElement(el){return Boolean(el&&el.nodeType===Node.ELEMENT_NODE);};// Determine if an HTML element is visible - Faster than CSS check\nvar isVisible=function isVisible(el)/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */{if(!isElement(el)||!contains(document.body,el)){return false;}// All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n// So any tests that need isVisible will fail in JSDOM\nvar bcr=getBCR(el);return Boolean(bcr&&bcr.height>0&&bcr.width>0);};// Determine if an element is disabled\nvar isDisabled=function isDisabled(el){return!isElement(el)||el.disabled||hasClass(el,'disabled')||Boolean(getAttr(el,'disabled'));};// Cause/wait-for an element to reflow it's content (adjusting it's height/width)\nvar reflow=function reflow(el){// Requesting an elements offsetHight will trigger a reflow of the element content\n/* istanbul ignore next: reflow doesn't happen in JSDOM */return isElement(el)&&el.offsetHeight;};// Select all elements matching selector. Returns `[]` if none found\nvar selectAll=function selectAll(selector,root){if(!isElement(root)){root=document;}return from(root.querySelectorAll(selector));};// Select a single element, returns `null` if not found\nvar select=function select(selector,root){if(!isElement(root)){root=document;}return root.querySelector(selector)||null;};// Determine if an element matches a selector\nvar matches=function matches(el,selector){if(!isElement(el)){return false;}// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n// Prefer native implementations over polyfill function\nvar proto=Element.prototype;/* istanbul ignore next */var Matches=proto.matches||proto.matchesSelector||proto.mozMatchesSelector||proto.msMatchesSelector||proto.oMatchesSelector||proto.webkitMatchesSelector||function(sel)/* istanbul ignore next */{var element=this;var m=selectAll(sel,element.document||element.ownerDocument);var i=m.length;// eslint-disable-next-line no-empty\nwhile(--i>=0&&m.item(i)!==element){}return i>-1;};return Matches.call(el,selector);};// Finds closest element matching selector. Returns `null` if not found\nvar closest=function closest(selector,root){if(!isElement(root)){return null;}// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n// Since we dont support IE < 10, we can use the \"Matches\" version of the polyfill for speed\n// Prefer native implementation over polyfill function\nvar Closest=Element.prototype.closest||function(sel)/* istanbul ignore next */{var element=this;if(!contains(document.documentElement,element)){return null;}do{// Use our \"patched\" matches function\nif(matches(element,sel)){return element;}element=element.parentElement;}while(element!==null);return null;};var el=Closest.call(root,selector);// Emulate jQuery closest and return `null` if match is the passed in element (root)\nreturn el===root?null:el;};// Returns true if the parent element contains the child element\nvar contains=function contains(parent,child){if(!parent||typeof parent.contains!=='function'){return false;}return parent.contains(child);};// Get an element given an ID\nvar getById=function getById(id){return document.getElementById(/^#/.test(id)?id.slice(1):id)||null;};// Add a class to an element\nvar addClass=function addClass(el,className){// We are checking for `el.classList` existence here since IE 11\n// returns `undefined` for some elements (e.g. SVG elements)\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\nif(className&&isElement(el)&&el.classList){el.classList.add(className);}};// Remove a class from an element\nvar removeClass=function removeClass(el,className){// We are checking for `el.classList` existence here since IE 11\n// returns `undefined` for some elements (e.g. SVG elements)\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\nif(className&&isElement(el)&&el.classList){el.classList.remove(className);}};// Test if an element has a class\nvar hasClass=function hasClass(el,className){// We are checking for `el.classList` existence here since IE 11\n// returns `undefined` for some elements (e.g. SVG elements)\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\nif(className&&isElement(el)&&el.classList){return el.classList.contains(className);}return false;};// Set an attribute on an element\nvar setAttr=function setAttr(el,attr,value){if(attr&&isElement(el)){el.setAttribute(attr,value);}};// Remove an attribute from an element\nvar removeAttr=function removeAttr(el,attr){if(attr&&isElement(el)){el.removeAttribute(attr);}};// Get an attribute value from an element (returns `null` if not found)\nvar getAttr=function getAttr(el,attr){if(attr&&isElement(el)){return el.getAttribute(attr);}return null;};// Determine if an attribute exists on an element (returns `true`\n// or `false`, or `null` if element not found)\nvar hasAttr=function hasAttr(el,attr){if(attr&&isElement(el)){return el.hasAttribute(attr);}return null;};// Return the Bounding Client Rect of an element. Returns `null` if not an element\nvar getBCR=function getBCR(el){/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */return isElement(el)?el.getBoundingClientRect():null;};// Get computed style object for an element\nvar getCS=function getCS(el){/* istanbul ignore next: getComputedStyle() doesn't work in JSDOM */return isElement(el)?window.getComputedStyle(el):{};};// Return an element's offset with respect to document element\n// https://j11y.io/jquery/#v=git&fn=jQuery.fn.offset\nvar offset=function offset(el)/* istanbul ignore next: getBoundingClientRect(), getClientRects() doesn't work in JSDOM */{var _offset={top:0,left:0};if(!isElement(el)||el.getClientRects().length===0){return _offset;}var bcr=getBCR(el);if(bcr){var win=el.ownerDocument.defaultView;_offset.top=bcr.top+win.pageYOffset;_offset.left=bcr.left+win.pageXOffset;}return _offset;};// Return an element's offset with respect to to it's offsetParent\n// https://j11y.io/jquery/#v=git&fn=jQuery.fn.position\nvar position=function position(el)/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */{var _offset={top:0,left:0};if(!isElement(el)){return _offset;}var parentOffset={top:0,left:0};var elStyles=getCS(el);if(elStyles.position==='fixed'){_offset=getBCR(el)||_offset;}else{_offset=offset(el);var doc=el.ownerDocument;var offsetParent=el.offsetParent||doc.documentElement;while(offsetParent&&(offsetParent===doc.body||offsetParent===doc.documentElement)&&getCS(offsetParent).position==='static'){offsetParent=offsetParent.parentNode;}if(offsetParent&&offsetParent!==el&&offsetParent.nodeType===Node.ELEMENT_NODE){parentOffset=offset(offsetParent);var offsetParentStyles=getCS(offsetParent);parentOffset.top+=parseFloat(offsetParentStyles.borderTopWidth);parentOffset.left+=parseFloat(offsetParentStyles.borderLeftWidth);}}return{top:_offset.top-parentOffset.top-parseFloat(elStyles.marginTop),left:_offset.left-parentOffset.left-parseFloat(elStyles.marginLeft)};};// requestAnimationFrame convenience method\n// We don't have a version for cancelAnimationFrame, but we don't call it anywhere\nvar requestAF=function requestAF(cb){var w=inBrowser?window:{};var rAF=w.requestAnimationFrame||w.webkitRequestAnimationFrame||w.mozRequestAnimationFrame||w.msRequestAnimationFrame||w.oRequestAnimationFrame||function(cb){// Fallback, but not a true polyfill.\n// But all browsers we support (other than Opera Mini) support rAF\n// without a polyfill.\n/* istanbul ignore next */return setTimeout(cb,16);};return rAF(cb);};var btnProps={block:{type:Boolean,default:false},disabled:{type:Boolean,default:false},size:{type:String,default:null},variant:{type:String,default:null},type:{type:String,default:'button'},tag:{type:String,default:'button'},pressed:{// tri-state prop: true, false or null\n// => on, off, not a toggle\ntype:Boolean,default:null}};var linkProps$1=propsFactory();delete linkProps$1.href.default;delete linkProps$1.to.default;var linkPropKeys=keys(linkProps$1);var props$4=_objectSpread({},linkProps$1,btnProps);// Focus handler for toggle buttons.  Needs class of 'focus' when focused.\nfunction handleFocus(evt){if(evt.type==='focusin'){addClass(evt.target,'focus');}else if(evt.type==='focusout'){removeClass(evt.target,'focus');}}// Helper functons to minimize runtime memory footprint when lots of buttons on page\n// Is the requested button a link?\nfunction isLink(props){// If tag prop is set to `a`, we use a b-link to get proper disabled handling\nreturn Boolean(props.href||props.to||props.tag&&String(props.tag).toLowerCase()==='a');}// Is the button to be a toggle button?\nfunction isToggle(props){return typeof props.pressed==='boolean';}// Is the button \"really\" a button?\nfunction isButton(props){if(isLink(props)){return false;}else if(props.tag&&String(props.tag).toLowerCase()!=='button'){return false;}return true;}// Is the requested tag not a button or link?\nfunction isNonStandardTag(props){return!isLink(props)&&!isButton(props);}// Compute required classes (non static classes)\nfunction computeClass(props){var _ref;return[props.variant?\"btn-\".concat(props.variant):\"btn-secondary\",(_ref={},_defineProperty(_ref,\"btn-\".concat(props.size),Boolean(props.size)),_defineProperty(_ref,'btn-block',props.block),_defineProperty(_ref,\"disabled\",props.disabled),_defineProperty(_ref,\"active\",props.pressed),_ref)];}// Compute the link props to pass to b-link (if required)\nfunction computeLinkProps(props){return isLink(props)?pluckProps(linkPropKeys,props):null;}// Compute the attributes for a button\nfunction computeAttrs(props,data){var button=isButton(props);var link=isLink(props);var toggle=isToggle(props);var nonStdTag=isNonStandardTag(props);var role=data.attrs&&data.attrs['role']?data.attrs['role']:null;var tabindex=data.attrs?data.attrs['tabindex']:null;if(nonStdTag){tabindex='0';}return{// Type only used for \"real\" buttons\ntype:button&&!link?props.type:null,// Disabled only set on \"real\" buttons\ndisabled:button?props.disabled:null,// We add a role of button when the tag is not a link or button for ARIA.\n// Don't bork any role provided in data.attrs when isLink or isButton\nrole:nonStdTag?'button':role,// We set the aria-disabled state for non-standard tags\n'aria-disabled':nonStdTag?String(props.disabled):null,// For toggles, we need to set the pressed state for ARIA\n'aria-pressed':toggle?String(props.pressed):null,// autocomplete off is needed in toggle mode to prevent some browsers from\n// remembering the previous setting when using the back button.\nautocomplete:toggle?'off':null,// Tab index is used when the component is not a button.\n// Links are tabbable, but don't allow disabled, while non buttons or links\n// are not tabbable, so we mimic that functionality by disabling tabbing\n// when disabled, and adding a tabindex of '0' to non buttons or non links.\ntabindex:props.disabled&&!button?'-1':tabindex};}// @vue/component\nvar BButton={name:'BButton',functional:true,props:props$4,render:function render(h,_ref2){var props=_ref2.props,data=_ref2.data,listeners=_ref2.listeners,children=_ref2.children;var toggle=isToggle(props);var link=isLink(props);var on={click:function click(e){/* istanbul ignore if: blink/button disabled should handle this */if(props.disabled&&e instanceof Event){e.stopPropagation();e.preventDefault();}else if(toggle&&listeners&&listeners['update:pressed']){// Send .sync updates to any \"pressed\" prop (if .sync listeners)\n// Concat will normalize the value to an array\n// without double wrapping an array value in an array.\nconcat(listeners['update:pressed']).forEach(function(fn){if(typeof fn==='function'){fn(!props.pressed);}});}}};if(toggle){on.focusin=handleFocus;on.focusout=handleFocus;}var componentData={staticClass:'btn',class:computeClass(props),props:computeLinkProps(props),attrs:computeAttrs(props,data),on:on};return h(link?BLink:props.tag,mergeData(data,componentData),children);}};var components$3={BButton:BButton,BBtn:BButton,BButtonClose:BButtonClose,BBtnClose:BButtonClose};var index$3={install:function install(Vue){registerComponents(Vue,components$3);}};var props$5={vertical:{type:Boolean,default:false},size:{type:String,default:null},tag:{type:String,default:'div'},ariaRole:{type:String,default:'group'// @vue/component\n}};var BButtonGroup={name:'BButtonGroup',functional:true,props:props$5,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{class:_defineProperty({'btn-group':!props.vertical,'btn-group-vertical':props.vertical},\"btn-group-\".concat(props.size),Boolean(props.size)),attrs:{role:props.ariaRole}}),children);}};var components$4={BButtonGroup:BButtonGroup,BBtnGroup:BButtonGroup};var index$4={install:function install(Vue){registerComponents(Vue,components$4);}};/*\n   * Key Codes (events)\n   */var KEY_CODES={SPACE:32,ENTER:13,ESC:27,LEFT:37,UP:38,RIGHT:39,DOWN:40,PAGEUP:33,PAGEDOWN:34,HOME:36,END:35,TAB:9,SHIFT:16,CTRL:17,BACKSPACE:8,ALT:18,PAUSE:19,BREAK:19,INSERT:45,INS:45,DELETE:46};var ITEM_SELECTOR=['.btn:not(.disabled):not([disabled]):not(.dropdown-item)','.form-control:not(.disabled):not([disabled])','select:not(.disabled):not([disabled])','input[type=\"checkbox\"]:not(.disabled)','input[type=\"radio\"]:not(.disabled)'].join(',');// @vue/component\nvar BButtonToolbar={name:'BButtonToolbar',props:{justify:{type:Boolean,default:false},keyNav:{type:Boolean,default:false}},computed:{classObject:function classObject(){return['btn-toolbar',this.justify&&!this.vertical?'justify-content-between':''];}},mounted:function mounted(){if(this.keyNav){// Pre-set the tabindexes if the markup does not include tabindex=\"-1\" on the toolbar items\nthis.getItems();}},methods:{onFocusin:function onFocusin(evt){if(evt.target===this.$el){evt.preventDefault();evt.stopPropagation();this.focusFirst(evt);}},onKeydown:function onKeydown(evt){if(!this.keyNav){return;}var key=evt.keyCode;var shift=evt.shiftKey;if(key===KEY_CODES.UP||key===KEY_CODES.LEFT){evt.preventDefault();evt.stopPropagation();if(shift){this.focusFirst(evt);}else{this.focusNext(evt,true);}}else if(key===KEY_CODES.DOWN||key===KEY_CODES.RIGHT){evt.preventDefault();evt.stopPropagation();if(shift){this.focusLast(evt);}else{this.focusNext(evt,false);}}},setItemFocus:function setItemFocus(item){this.$nextTick(function(){item.focus();});},focusNext:function focusNext(evt,prev){var items=this.getItems();if(items.length<1){return;}var index=items.indexOf(evt.target);if(prev&&index>0){index--;}else if(!prev&&index<items.length-1){index++;}if(index<0){index=0;}this.setItemFocus(items[index]);},focusFirst:function focusFirst(evt){var items=this.getItems();if(items.length>0){this.setItemFocus(items[0]);}},focusLast:function focusLast(evt){var items=this.getItems();if(items.length>0){this.setItemFocus([items.length-1]);}},getItems:function getItems(){var items=selectAll(ITEM_SELECTOR,this.$el);items.forEach(function(item){// Ensure tabfocus is -1 on any new elements\nitem.tabIndex=-1;});return items.filter(function(el){return isVisible(el);});}},render:function render(h){return h('div',{class:this.classObject,attrs:{role:'toolbar',tabindex:this.keyNav?'0':null},on:{focusin:this.onFocusin,keydown:this.onKeydown}},[this.$slots.default]);}};var components$5={BButtonToolbar:BButtonToolbar,BBtnToolbar:BButtonToolbar};var index$5={install:function install(Vue){registerComponents(Vue,components$5);}};var props$6={tag:{type:String,default:'div'// @vue/component\n}};var InputGroupText={name:'BInputGroupText',functional:true,props:props$6,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{staticClass:'input-group-text'}),children);}};var commonProps={id:{type:String,default:null},tag:{type:String,default:'div'},isText:{type:Boolean,default:false// @vue/component\n}};var InputGroupAddon={name:'BInputGroupAddon',functional:true,props:_objectSpread({},commonProps,{append:{type:Boolean,default:false}}),render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{class:{'input-group-append':props.append,'input-group-prepend':!props.append},attrs:{id:props.id}}),props.isText?[h(InputGroupText,children)]:children);}};var InputGroupPrepend={name:'BInputGroupPrepend',functional:true,props:commonProps,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;// pass all our props/attrs down to child, and set`append` to false\nreturn h(InputGroupAddon,mergeData(data,{props:_objectSpread({},props,{append:false})}),children);}};var InputGroupAppend={name:'BInputGroupAppend',functional:true,props:commonProps,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;// pass all our props/attrs down to child, and set`append` to true\nreturn h(InputGroupAddon,mergeData(data,{props:_objectSpread({},props,{append:true})}),children);}};var props$7={id:{type:String},size:{type:String},prepend:{type:String},prependHTML:{type:String},append:{type:String},appendHTML:{type:String},tag:{type:String,default:'div'// @vue/component\n}};var BInputGroup={name:'BInputGroup',functional:true,props:props$7,render:function render(h,_ref){var props=_ref.props,data=_ref.data,slots=_ref.slots;var $slots=slots();var childNodes=[];// Prepend prop\nif(props.prepend){childNodes.push(h(InputGroupPrepend,[h(InputGroupText,{domProps:htmlOrText(props.prependHTML,props.prepend)})]));}else{childNodes.push(h(false));}// Prepend slot\nif($slots.prepend){childNodes.push(h(InputGroupPrepend,$slots.prepend));}else{childNodes.push(h(false));}// Default slot\nif($slots.default){childNodes.push.apply(childNodes,_toConsumableArray($slots.default));}else{childNodes.push(h(false));}// Append prop\nif(props.append){childNodes.push(h(InputGroupAppend,[h(InputGroupText,{domProps:htmlOrText(props.appendHTML,props.append)})]));}else{childNodes.push(h(false));}// Append slot\nif($slots.append){childNodes.push(h(InputGroupAppend,$slots.append));}else{childNodes.push(h(false));}return h(props.tag,mergeData(data,{staticClass:'input-group',class:_defineProperty({},\"input-group-\".concat(props.size),Boolean(props.size)),attrs:{id:props.id||null,role:'group'}}),childNodes);}};var components$6={BInputGroup:BInputGroup,BInputGroupAddon:InputGroupAddon,BInputGroupPrepend:InputGroupPrepend,BInputGroupAppend:InputGroupAppend,BInputGroupText:InputGroupText};var index$6={install:function install(Vue){registerComponents(Vue,components$6);}};/**\n   * @param {string} str\n   */var upperFirst=function upperFirst(str){if(typeof str!=='string'){str=String(str);}str=str.trim();return str.charAt(0).toUpperCase()+str.slice(1);};/**\n   * @param {string} prefix\n   * @param {string} value\n   */var prefixPropName=function prefixPropName(prefix,value){return prefix+upperFirst(value);};/**\n   * @param {string} str\n   */var lowerFirst=function lowerFirst(str){str=String(str);return str.charAt(0).toLowerCase()+str.slice(1);};/**\n   * @param {string} prefix\n   * @param {string} value\n   */var unprefixPropName=function unprefixPropName(prefix,value){return lowerFirst(value.replace(prefix,''));};/**\n   * Copies props from one array/object to a new array/object. Prop values\n   * are also cloned as new references to prevent possible mutation of original\n   * prop object values. Optionally accepts a function to transform the prop name.\n   *\n   * @param {[]|{}} props\n   * @param {Function} transformFn\n   */var copyProps=function copyProps(props){var transformFn=arguments.length>1&&arguments[1]!==undefined?arguments[1]:identity;if(isArray(props)){return props.map(transformFn);}// Props as an object.\nvar copied={};for(var prop in props){/* istanbul ignore else */if(props.hasOwnProperty(prop)){// If the prop value is an object, do a shallow clone to prevent\n// potential mutations to the original object.\ncopied[transformFn(prop)]=isObject(props[prop])?_objectSpread({},props[prop]):props[prop];}}return copied;};// @vue/component\nvar cardMixin={props:{tag:{type:String,default:'div'},bgVariant:{type:String,default:null},borderVariant:{type:String,default:null},textVariant:{type:String,default:null}}};var props$8={title:{type:String,default:''},titleTag:{type:String,default:'h4'// @vue/component\n}};var BCardTitle={name:'BCardTitle',functional:true,props:props$8,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.titleTag,mergeData(data,{staticClass:'card-title'}),children||props.title);}};var props$9={subTitle:{type:String,default:''},subTitleTag:{type:String,default:'h6'},subTitleTextVariant:{type:String,default:'muted'// @vue/component\n}};var BCardSubTitle={name:'BCardSubTitle',functional:true,props:props$9,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.subTitleTag,mergeData(data,{staticClass:'card-subtitle',class:[props.subTitleTextVariant?\"text-\".concat(props.subTitleTextVariant):null]}),children||props.subTitle);}};var props$a=_objectSpread({},copyProps(cardMixin.props,prefixPropName.bind(null,'body')),{bodyClass:{type:[String,Object,Array],default:null}},props$8,props$9,{overlay:{type:Boolean,default:false// @vue/component\n}});var BCardBody={name:'BCardBody',functional:true,props:props$a,render:function render(h,_ref){var _ref2;var props=_ref.props,data=_ref.data,children=_ref.children;var cardTitle=h(false);var cardSubTitle=h(false);var cardContent=children||[h(false)];if(props.title){cardTitle=h(BCardTitle,{props:pluckProps(props$8,props)});}if(props.subTitle){cardSubTitle=h(BCardSubTitle,{props:pluckProps(props$9,props),class:['mb-2']});}return h(props.bodyTag,mergeData(data,{staticClass:'card-body',class:[(_ref2={'card-img-overlay':props.overlay},_defineProperty(_ref2,\"bg-\".concat(props.bodyBgVariant),Boolean(props.bodyBgVariant)),_defineProperty(_ref2,\"border-\".concat(props.bodyBorderVariant),Boolean(props.bodyBorderVariant)),_defineProperty(_ref2,\"text-\".concat(props.bodyTextVariant),Boolean(props.bodyTextVariant)),_ref2),props.bodyClass||{}]}),[cardTitle,cardSubTitle].concat(_toConsumableArray(cardContent)));}};var props$b=_objectSpread({},copyProps(cardMixin.props,prefixPropName.bind(null,'header')),{header:{type:String,default:null},headerHtml:{type:String,default:null},headerClass:{type:[String,Object,Array],default:null// @vue/component\n}});var BCardHeader={name:'BCardHeader',functional:true,props:props$b,render:function render(h,_ref){var _ref2;var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.headerTag,mergeData(data,{staticClass:'card-header',class:[props.headerClass,(_ref2={},_defineProperty(_ref2,\"bg-\".concat(props.headerBgVariant),Boolean(props.headerBgVariant)),_defineProperty(_ref2,\"border-\".concat(props.headerBorderVariant),Boolean(props.headerBorderVariant)),_defineProperty(_ref2,\"text-\".concat(props.headerTextVariant),Boolean(props.headerTextVariant)),_ref2)]}),children||[h('div',{domProps:htmlOrText(props.headerHtml,props.header)})]);}};var props$c=_objectSpread({},copyProps(cardMixin.props,prefixPropName.bind(null,'footer')),{footer:{type:String,default:null},footerHtml:{type:String,default:null},footerClass:{type:[String,Object,Array],default:null// @vue/component\n}});var BCardFooter={name:'BCardFooter',functional:true,props:props$c,render:function render(h,_ref){var _ref2;var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.footerTag,mergeData(data,{staticClass:'card-footer',class:[props.footerClass,(_ref2={},_defineProperty(_ref2,\"bg-\".concat(props.footerBgVariant),Boolean(props.footerBgVariant)),_defineProperty(_ref2,\"border-\".concat(props.footerBorderVariant),Boolean(props.footerBorderVariant)),_defineProperty(_ref2,\"text-\".concat(props.footerTextVariant),Boolean(props.footerTextVariant)),_ref2)]}),children||[h('div',{domProps:htmlOrText(props.footerHtml,props.footer)})]);}};var props$d={src:{type:String,default:null,required:true},alt:{type:String,default:null},top:{type:Boolean,default:false},bottom:{type:Boolean,default:false},left:{type:Boolean,default:false},start:{type:Boolean,default:false// alias of 'left'\n},right:{type:Boolean,default:false},end:{type:Boolean,default:false// alias of 'right'\n},height:{type:String,default:null},width:{type:String,default:null// @vue/component\n}};var BCardImg={name:'BCardImg',functional:true,props:props$d,render:function render(h,_ref){var props=_ref.props,data=_ref.data;var baseClass='card-img';if(props.top){baseClass+='-top';}else if(props.right||props.end){baseClass+='-right';}else if(props.bottom){baseClass+='-bottom';}else if(props.left||props.start){baseClass+='-left';}return h('img',mergeData(data,{class:[baseClass],attrs:{src:props.src,alt:props.alt,height:props.height,width:props.width}}));}};var cardImgProps=copyProps(props$d,prefixPropName.bind(null,'img'));cardImgProps.imgSrc.required=false;var props$e=_objectSpread({},props$a,props$b,props$c,cardImgProps,copyProps(cardMixin.props),{align:{type:String,default:null},noBody:{type:Boolean,default:false// @vue/component\n}});var BCard={name:'BCard',functional:true,props:props$e,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,slots=_ref.slots;var $slots=slots();// Create placeholder elements for each section\nvar imgFirst=h(false);var header=h(false);var content=h(false);var footer=h(false);var imgLast=h(false);if(props.imgSrc){var img=h(BCardImg,{props:pluckProps(cardImgProps,props,unprefixPropName.bind(null,'img'))});if(props.imgBottom){imgLast=img;}else{imgFirst=img;}}if(props.header||$slots.header){header=h(BCardHeader,{props:pluckProps(props$b,props)},$slots.header);}if(props.noBody){content=$slots.default||[];}else{// Wrap content in card-body\ncontent=[h(BCardBody,{props:pluckProps(props$a,props)},$slots.default)];}if(props.footer||$slots.footer){footer=h(BCardFooter,{props:pluckProps(props$c,props)},$slots.footer);}return h(props.tag,mergeData(data,{staticClass:'card',class:(_class={'flex-row':props.imgLeft||props.imgStart,'flex-row-reverse':(props.imgRight||props.imgEnd)&&!(props.imgLeft||props.imgStart)},_defineProperty(_class,\"text-\".concat(props.align),Boolean(props.align)),_defineProperty(_class,\"bg-\".concat(props.bgVariant),Boolean(props.bgVariant)),_defineProperty(_class,\"border-\".concat(props.borderVariant),Boolean(props.borderVariant)),_defineProperty(_class,\"text-\".concat(props.textVariant),Boolean(props.textVariant)),_class)}),[imgFirst,header].concat(_toConsumableArray(content),[footer,imgLast]));}};var BLANK_TEMPLATE='<svg width=\"%{w}\" height=\"%{h}\" '+'xmlns=\"http://www.w3.org/2000/svg\" '+'viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\">'+'<rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect>'+'</svg>';function makeBlankImgSrc(width,height,color){var src=encodeURIComponent(BLANK_TEMPLATE.replace('%{w}',String(width)).replace('%{h}',String(height)).replace('%{f}',color));return\"data:image/svg+xml;charset=UTF-8,\".concat(src);}var props$f={src:{type:String,default:null},alt:{type:String,default:null},width:{type:[Number,String],default:null},height:{type:[Number,String],default:null},block:{type:Boolean,default:false},fluid:{type:Boolean,default:false},fluidGrow:{// Gives fluid images class `w-100` to make them grow to fit container\ntype:Boolean,default:false},rounded:{// rounded can be:\n//   false: no rounding of corners\n//   true: slightly rounded corners\n//   'top': top corners rounded\n//   'right': right corners rounded\n//   'bottom': bottom corners rounded\n//   'left': left corners rounded\n//   'circle': circle/oval\n//   '0': force rounding off\ntype:[Boolean,String],default:false},thumbnail:{type:Boolean,default:false},left:{type:Boolean,default:false},right:{type:Boolean,default:false},center:{type:Boolean,default:false},blank:{type:Boolean,default:false},blankColor:{type:String,default:'transparent'// @vue/component\n}};var BImg={name:'BImg',functional:true,props:props$f,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data;var src=props.src;var width=parseInt(props.width,10)?parseInt(props.width,10):null;var height=parseInt(props.height,10)?parseInt(props.height,10):null;var align=null;var block=props.block;if(props.blank){if(!height&&Boolean(width)){height=width;}else if(!width&&Boolean(height)){width=height;}if(!width&&!height){width=1;height=1;}// Make a blank SVG image\nsrc=makeBlankImgSrc(width,height,props.blankColor||'transparent');}if(props.left){align='float-left';}else if(props.right){align='float-right';}else if(props.center){align='mx-auto';block=true;}return h('img',mergeData(data,{attrs:{src:src,alt:props.alt,width:width?String(width):null,height:height?String(height):null},class:(_class={'img-thumbnail':props.thumbnail,'img-fluid':props.fluid||props.fluidGrow,'w-100':props.fluidGrow,rounded:props.rounded===''||props.rounded===true},_defineProperty(_class,\"rounded-\".concat(props.rounded),typeof props.rounded==='string'&&props.rounded!==''),_defineProperty(_class,align,Boolean(align)),_defineProperty(_class,'d-block',block),_class)}));}};var THROTTLE=100;var EventOptions={passive:true,capture:false// @vue/component\n};var BImgLazy={name:'BImgLazy',components:{BImg:BImg},props:{src:{type:String,default:null,required:true},alt:{type:String,default:null},width:{type:[Number,String],default:null},height:{type:[Number,String],default:null},blankSrc:{// If null, a blank image is generated\ntype:String,default:null},blankColor:{type:String,default:'transparent'},blankWidth:{type:[Number,String],default:null},blankHeight:{type:[Number,String],default:null},show:{type:Boolean,default:false},fluid:{type:Boolean,default:false},fluidGrow:{type:Boolean,default:false},block:{type:Boolean,default:false},thumbnail:{type:Boolean,default:false},rounded:{type:[Boolean,String],default:false},left:{type:Boolean,default:false},right:{type:Boolean,default:false},center:{type:Boolean,default:false},offset:{type:[Number,String],default:360},throttle:{type:[Number,String],default:THROTTLE}},data:function data(){return{isShown:false,scrollTimeout:null};},computed:{computedSrc:function computedSrc(){return!this.blankSrc||this.isShown?this.src:this.blankSrc;},computedBlank:function computedBlank(){return!(this.isShown||this.blankSrc);},computedWidth:function computedWidth(){return this.isShown?this.width:this.blankWidth||this.width;},computedHeight:function computedHeight(){return this.isShown?this.height:this.blankHeight||this.height;}},watch:{show:function show(newVal,oldVal){if(newVal!==oldVal){this.isShown=newVal;if(!newVal){// Make sure listeners are re-enabled if img is force set to blank\nthis.setListeners(true);}}},isShown:function isShown(newVal,oldVal){if(newVal!==oldVal){// Update synched show prop\nthis.$emit('update:show',newVal);}}},created:function created(){this.isShown=this.show;},mounted:function mounted(){if(this.isShown){this.setListeners(false);}else{this.setListeners(true);this.$nextTick(this.checkView);}},activated:function activated()/* istanbul ignore next */{if(!this.isShown){this.setListeners(true);this.$nextTick(this.checkView);}},deactivated:function deactivated()/* istanbul ignore next */{this.setListeners(false);},beforeDestroy:function beforeDestroy(){this.setListeners(false);},methods:{setListeners:function setListeners(on){if(this.scrollTimeout){clearTimeout(this.scrollTimeout);this.scrollTimeout=null;}var root=window;if(on){eventOn(this.$el,'load',this.checkView);eventOn(root,'scroll',this.onScroll,EventOptions);eventOn(root,'resize',this.onScroll,EventOptions);eventOn(root,'orientationchange',this.onScroll,EventOptions);eventOn(document,'transitionend',this.onScroll,EventOptions);}else{eventOff(this.$el,'load',this.checkView);eventOff(root,'scroll',this.onScroll,EventOptions);eventOff(root,'resize',this.onScroll,EventOptions);eventOff(root,'orientationchange',this.onScroll,EventOptions);eventOff(document,'transitionend',this.onScroll,EventOptions);}},checkView:function checkView(){// check bounding box + offset to see if we should show\nif(this.isShown){this.setListeners(false);return;}var offset=parseInt(this.offset,10)||0;var docElement=document.documentElement;var view={l:0-offset,t:0-offset,b:docElement.clientHeight+offset,r:docElement.clientWidth+offset/* istanbul ignore next */};var box=getBCR(this.$el);/* istanbul ignore next: can't test getBoundingClientRect in JSDOM */if(box.right>=view.l&&box.bottom>=view.t&&box.left<=view.r&&box.top<=view.b){// image is in view (or about to be in view)\nthis.isShown=true;this.setListeners(false);}},onScroll:function onScroll(){if(this.isShown){this.setListeners(false);}else{clearTimeout(this.scrollTimeout);this.scrollTimeout=setTimeout(this.checkView,parseInt(this.throttle,10)||THROTTLE);}}},render:function render(h){return h('b-img',{props:{src:this.computedSrc,alt:this.alt,blank:this.computedBlank,blankColor:this.blankColor,width:this.computedWidth,height:this.computedHeight,fluid:this.fluid,fluidGrow:this.fluidGrow,block:this.block,thumbnail:this.thumbnail,rounded:this.rounded,left:this.left,right:this.right,center:this.center}});}};// The `omit()` util creates a new object, so we can just pass the original props\nvar lazyProps=omit(BImgLazy.props,['left','right','center','block','rounded','thumbnail','fluid','fluidGrow']);var props$g=_objectSpread({},lazyProps,{top:{type:Boolean,default:false},bottom:{type:Boolean,default:false},left:{type:Boolean,default:false},start:{type:Boolean,default:false// alias of 'left'\n},right:{type:Boolean,default:false},end:{type:Boolean,default:false// alias of 'right'\n// @vue/component\n}});var BCardImgLazy={name:'BCardImgLazy',functional:true,props:props$g,render:function render(h,_ref){var props=_ref.props,data=_ref.data;var baseClass='card-img';if(props.top){baseClass+='-top';}else if(props.right||props.end){baseClass+='-right';}else if(props.bottom){baseClass+='-bottom';}else if(props.left||props.start){baseClass+='-left';}// False out the left/center/right props before passing to b-img-lazy\nvar lazyProps=_objectSpread({},props,{left:false,right:false,center:false});return h(BImgLazy,mergeData(data,{class:[baseClass],props:lazyProps}));}};var props$h={textTag:{type:String,default:'p'// @vue/component\n}};var BCardText={name:'BCardText',functional:true,props:props$h,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.textTag,mergeData(data,{staticClass:'card-text'}),children);}};var props$i={tag:{type:String,default:'div'},deck:{type:Boolean,default:false},columns:{type:Boolean,default:false// @vue/component\n}};var BCardGroup={name:'BCardGroup',functional:true,props:props$i,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var baseClass='card-group';if(props.deck){baseClass='card-deck';}else if(props.columns){baseClass='card-columns';}return h(props.tag,mergeData(data,{class:baseClass}),children);}};var components$7={BCard:BCard,BCardHeader:BCardHeader,BCardBody:BCardBody,BCardTitle:BCardTitle,BCardSubTitle:BCardSubTitle,BCardFooter:BCardFooter,BCardImg:BCardImg,BCardImgLazy:BCardImgLazy,BCardText:BCardText,BCardGroup:BCardGroup};var index$7={install:function install(Vue){registerComponents(Vue,components$7);}};var eventListenerSupported=inBrowser&&window.addEventListener;var MutationObserver=inBrowser&&(window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver);// Fallback observation for legacy browsers\n// Emulate observer disconnect() method so that we can detach the events later\nvar fakeObserverFactory=function fakeObserverFactory(el,callback)/* istanbul ignore next: hard to test in JSDOM */{eventOn(el,'DOMNodeInserted',callback,false);eventOn(el,'DOMNodeRemoved',callback,false);return{disconnect:function disconnect(){eventOff(el,'DOMNodeInserted',callback,false);eventOff(el,'DOMNodeRemoved',callback,false);}};};/**\n   * Observe a DOM element changes, falls back to eventListener mode\n   * @param {Element} el The DOM element to observe\n   * @param {Function} callback callback to be called on change\n   * @param {object} [opts={childList: true, subtree: true}] observe options\n   * @see http://stackoverflow.com/questions/3219758\n   */var observeDom=function observeDom(el,callback,opts)/* istanbul ignore next: difficult to test in JSDOM */{// Handle case where we might be passed a vue instance\nel=el?el.$el||el:null;/* istanbul ignore next: difficult to test in JSDOM */if(!isElement(el)){// We can't observe something that isn't an element\nreturn null;}var obs=null;if(MutationObserver){// Define a new observer\nobs=new MutationObserver(function(mutations){var changed=false;// A Mutation can contain several change records, so we loop through them to see what has changed.\n// We break out of the loop early if any \"significant\" change has been detected\nfor(var i=0;i<mutations.length&&!changed;i++){// The mutation record\nvar mutation=mutations[i];// Mutation Type\nvar type=mutation.type;// DOM Node (could be any DOM Node type - HTMLElement, Text, comment, etc)\nvar target=mutation.target;if(type==='characterData'&&target.nodeType===Node.TEXT_NODE){// We ignore nodes that are not TEXT (i.e. comments, etc) as they don't change layout\nchanged=true;}else if(type==='attributes'){changed=true;}else if(type==='childList'&&(mutation.addedNodes.length>0||mutation.removedNodes.length>0)){// This includes HTMLElement and Text Nodes being added/removed/re-arranged\nchanged=true;}}if(changed){// We only call the callback if a change that could affect layout/size truely happened.\ncallback();}});// Have the observer observe foo for changes in children, etc\nobs.observe(el,_objectSpread({childList:true,subtree:true},opts));}else if(eventListenerSupported){// Legacy interface. most likely not used in modern browsers\nobs=fakeObserverFactory(el,callback);}// We return a reference to the observer so that obs.disconnect() can be called if necessary\n// To reduce overhead when the root element is hidden\nreturn obs;};/*\n   * SSR Safe Client Side ID attribute generation\n   * id's can only be generated client side, after mount.\n   * this._uid is not synched between server and client.\n   */ // @vue/component\nvar idMixin={props:{id:{type:String,default:null}},data:function data(){return{localId_:null};},computed:{safeId:function safeId(){// Computed property that returns a dynamic function for creating the ID.\n// Reacts to changes in both .id and .localId_ And regens a new function\nvar id=this.id||this.localId_;// We return a function that accepts an optional suffix string\n// So this computed prop looks and works like a method!!!\n// But benefits from Vue's Computed prop caching\nvar fn=function fn(suffix){if(!id){return null;}suffix=String(suffix||'').replace(/\\s+/g,'_');return suffix?id+'_'+suffix:id;};return fn;}},mounted:function mounted(){var _this=this;// mounted only occurs client side\nthis.$nextTick(function(){// Update dom with auto ID after dom loaded to prevent\n// SSR hydration errors.\n_this.localId_=\"__BVID__\".concat(_this._uid);});}};var DIRECTION={next:{dirClass:'carousel-item-left',overlayClass:'carousel-item-next'},prev:{dirClass:'carousel-item-right',overlayClass:'carousel-item-prev'// Fallback Transition duration (with a little buffer) in ms\n}};var TRANS_DURATION=600+50;// Time for mouse compat events to fire after touch\nvar TOUCHEVENT_COMPAT_WAIT=500;// Number of pixels to consider touch move a swipe\nvar SWIPE_THRESHOLD=40;// PointerEvent pointer types\nvar PointerType={TOUCH:'touch',PEN:'pen'// Transition Event names\n};var TransitionEndEvents={WebkitTransition:'webkitTransitionEnd',MozTransition:'transitionend',OTransition:'otransitionend oTransitionEnd',transition:'transitionend'};var EventOptions$1={passive:true,capture:false// Return the browser specific transitionEnd event name\n};function getTransisionEndEvent(el){for(var name in TransitionEndEvents){if(el.style[name]!==undefined){return TransitionEndEvents[name];}}// fallback\n/* istanbul ignore next */return null;}// @vue/component\nvar BCarousel={name:'BCarousel',mixins:[idMixin],provide:function provide(){return{bvCarousel:this};},props:{labelPrev:{type:String,default:'Previous Slide'},labelNext:{type:String,default:'Next Slide'},labelGotoSlide:{type:String,default:'Goto Slide'},labelIndicators:{type:String,default:'Select a slide to display'},interval:{type:Number,default:5000},indicators:{type:Boolean,default:false},controls:{type:Boolean,default:false},noAnimation:{// Disable slide/fade animation\ntype:Boolean,default:false},fade:{// Enable cross-fade animation instead of slide animation\ntype:Boolean,default:false},noTouch:{// Sniffed by carousel-slide\ntype:Boolean,default:false},imgWidth:{// Sniffed by carousel-slide\ntype:[Number,String]// default: undefined\n},imgHeight:{// Sniffed by carousel-slide\ntype:[Number,String]// default: undefined\n},background:{type:String// default: undefined\n},value:{type:Number,default:0}},data:function data(){return{index:this.value||0,isSliding:false,transitionEndEvent:null,slides:[],direction:null,isPaused:false,// Touch event handling values\ntouchStartX:0,touchDeltaX:0};},watch:{value:function value(newVal,oldVal){if(newVal!==oldVal){this.setSlide(newVal);}},interval:function interval(newVal,oldVal){if(newVal===oldVal){/* istanbul ignore next */return;}if(!newVal){// Pausing slide show\nthis.pause(false);}else{// Restarting or Changing interval\nthis.pause(true);this.start(false);}},isPaused:function isPaused(newVal,oldVal){if(newVal!==oldVal){this.$emit(newVal?'paused':'unpaused');}},index:function index(to,from){if(to===from||this.isSliding){return;}this.doSlide(to,from);}},created:function created(){// Create private non-reactive props\nthis._intervalId=null;this._animationTimeout=null;this._touchTimeout=null;},mounted:function mounted(){// Cache current browser transitionend event name\nthis.transitionEndEvent=getTransisionEndEvent(this.$el)||null;// Get all slides\nthis.updateSlides();// Observe child changes so we can update slide list\nobserveDom(this.$refs.inner,this.updateSlides.bind(this),{subtree:false,childList:true,attributes:true,attributeFilter:['id']});},beforeDestroy:function beforeDestroy()/* istanbul ignore next: dificult to test */{clearTimeout(this._animationTimeout);clearTimeout(this._touchTimeout);clearInterval(this._intervalId);this._intervalId=null;this._animationTimeout=null;this._touchTimeout=null;},methods:{// Set slide\nsetSlide:function setSlide(slide){var _this=this;var direction=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;// Don't animate when page is not visible\n/* istanbul ignore if: dificult to test */if(inBrowser&&document.visibilityState&&document.hidden){return;}var len=this.slides.length;// Don't do anything if nothing to slide to\nif(len===0){return;}// Don't change slide while transitioning, wait until transition is done\nif(this.isSliding){// Schedule slide after sliding complete\nthis.$once('sliding-end',function(){return _this.setSlide(slide,direction);});return;}this.direction=direction;// Make sure we have an integer (you never know!)\nslide=Math.floor(slide);// Set new slide index. Wrap around if necessary\nthis.index=slide>=len?0:slide>=0?slide:len-1;},// Previous slide\nprev:function prev(){this.setSlide(this.index-1,'prev');},// Next slide\nnext:function next(){this.setSlide(this.index+1,'next');},// Pause auto rotation\npause:function pause(evt){if(!evt){this.isPaused=true;}if(this._intervalId){clearInterval(this._intervalId);this._intervalId=null;}},// Start auto rotate slides\nstart:function start(evt){if(!evt){this.isPaused=false;}if(this._intervalId){clearInterval(this._intervalId);this._intervalId=null;}// Don't start if no interval, or less than 2 slides\nif(this.interval&&this.slides.length>1){this._intervalId=setInterval(this.next,Math.max(1000,this.interval));}},// Re-Start auto rotate slides when focus/hover leaves the carousel\nrestart:function restart(evt){/* istanbul ignore if: dificult to test */if(!this.$el.contains(document.activeElement)){this.start();}},doSlide:function doSlide(to,from){var _this2=this;var isCycling=Boolean(this.interval);// Determine sliding direction\nvar direction=this.calcDirection(this.direction,from,to);var overlayClass=direction.overlayClass;var dirClass=direction.dirClass;// Determine current and next slides\nvar currentSlide=this.slides[from];var nextSlide=this.slides[to];// Don't do anything if there aren't any slides to slide to\nif(!currentSlide||!nextSlide){/* istanbul ignore next */return;}// Start animating\nthis.isSliding=true;if(isCycling){this.pause(false);}this.$emit('sliding-start',to);// Update v-model\nthis.$emit('input',this.index);if(this.noAnimation){addClass(nextSlide,'active');removeClass(currentSlide,'active');this.isSliding=false;// Notify ourselves that we're done sliding (slid)\nthis.$nextTick(function(){return _this2.$emit('sliding-end',to);});}else{addClass(nextSlide,overlayClass);// Trigger a reflow of next slide\nreflow(nextSlide);addClass(currentSlide,dirClass);addClass(nextSlide,dirClass);// Transition End handler\nvar called=false;/* istanbul ignore next: dificult to test */var onceTransEnd=function onceTransEnd(evt){if(called){return;}called=true;/* istanbul ignore if: transition events cant be tested in JSDOM */if(_this2.transitionEndEvent){var events=_this2.transitionEndEvent.split(/\\s+/);events.forEach(function(evt){return eventOff(currentSlide,evt,onceTransEnd,EventOptions$1);});}_this2._animationTimeout=null;removeClass(nextSlide,dirClass);removeClass(nextSlide,overlayClass);addClass(nextSlide,'active');removeClass(currentSlide,'active');removeClass(currentSlide,dirClass);removeClass(currentSlide,overlayClass);setAttr(currentSlide,'aria-current','false');setAttr(nextSlide,'aria-current','true');setAttr(currentSlide,'aria-hidden','true');setAttr(nextSlide,'aria-hidden','false');_this2.isSliding=false;_this2.direction=null;// Notify ourselves that we're done sliding (slid)\n_this2.$nextTick(function(){return _this2.$emit('sliding-end',to);});};// Set up transitionend handler\n/* istanbul ignore if: transition events cant be tested in JSDOM */if(this.transitionEndEvent){var events=this.transitionEndEvent.split(/\\s+/);events.forEach(function(event){return eventOn(currentSlide,event,onceTransEnd,EventOptions$1);});}// Fallback to setTimeout\nthis._animationTimeout=setTimeout(onceTransEnd,TRANS_DURATION);}if(isCycling){this.start(false);}},// Update slide list\nupdateSlides:function updateSlides(){this.pause(true);// Get all slides as DOM elements\nthis.slides=selectAll('.carousel-item',this.$refs.inner);var numSlides=this.slides.length;// Keep slide number in range\nvar index=Math.max(0,Math.min(Math.floor(this.index),numSlides-1));this.slides.forEach(function(slide,idx){var n=idx+1;if(idx===index){addClass(slide,'active');setAttr(slide,'aria-current','true');}else{removeClass(slide,'active');setAttr(slide,'aria-current','false');}setAttr(slide,'aria-posinset',String(n));setAttr(slide,'aria-setsize',String(numSlides));});// Set slide as active\nthis.setSlide(index);this.start(this.isPaused);},calcDirection:function calcDirection(){var direction=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var curIndex=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var nextIndex=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;if(!direction){return nextIndex>curIndex?DIRECTION.next:DIRECTION.prev;}return DIRECTION[direction];},handleClick:function handleClick(evt,fn){var keyCode=evt.keyCode;if(evt.type==='click'||keyCode===KEY_CODES.SPACE||keyCode===KEY_CODES.ENTER){evt.preventDefault();evt.stopPropagation();fn();}},handleSwipe:function handleSwipe()/* istanbul ignore next: JSDOM doesn't support touch events */{var absDeltax=Math.abs(this.touchDeltaX);if(absDeltax<=SWIPE_THRESHOLD){return;}var direction=absDeltax/this.touchDeltaX;if(direction>0){// swipe left\nthis.prev();}else if(direction<0){// swipe right\nthis.next();}},touchStart:function touchStart(evt)/* istanbul ignore next: JSDOM doesn't support touch events */{if(hasPointerEvent&&PointerType[evt.pointerType.toUpperCase()]){this.touchStartX=evt.clientX;}else if(!hasPointerEvent){this.touchStartX=evt.touches[0].clientX;}},touchMove:function touchMove(evt)/* istanbul ignore next: JSDOM doesn't support touch events */{// ensure swiping with one touch and not pinching\nif(evt.touches&&evt.touches.length>1){this.touchDeltaX=0;}else{this.touchDeltaX=evt.touches[0].clientX-this.touchStartX;}},touchEnd:function touchEnd(evt)/* istanbul ignore next: JSDOM doesn't support touch events */{if(hasPointerEvent&&PointerType[evt.pointerType.toUpperCase()]){this.touchDeltaX=evt.clientX-this.touchStartX;}this.handleSwipe();// If it's a touch-enabled device, mouseenter/leave are fired as\n// part of the mouse compatibility events on first tap - the carousel\n// would stop cycling until user tapped out of it;\n// here, we listen for touchend, explicitly pause the carousel\n// (as if it's the second time we tap on it, mouseenter compat event\n// is NOT fired) and after a timeout (to allow for mouse compatibility\n// events to fire) we explicitly restart cycling\nthis.pause(false);if(this._touchTimeout){clearTimeout(this._touchTimeout);}this._touchTimeout=setTimeout(this.start,TOUCHEVENT_COMPAT_WAIT+Math.max(1000,this.interval));}},render:function render(h){var _this3=this;// Wrapper for slides\nvar inner=h('div',{ref:'inner',class:['carousel-inner'],attrs:{id:this.safeId('__BV_inner_'),role:'list'}},[this.$slots.default]);// Prev and Next Controls\nvar controls=h(false);if(this.controls){controls=[h('a',{class:['carousel-control-prev'],attrs:{href:'#',role:'button','aria-controls':this.safeId('__BV_inner_')},on:{click:function click(evt){_this3.handleClick(evt,_this3.prev);},keydown:function keydown(evt){_this3.handleClick(evt,_this3.prev);}}},[h('span',{class:['carousel-control-prev-icon'],attrs:{'aria-hidden':'true'}}),h('span',{class:['sr-only']},[this.labelPrev])]),h('a',{class:['carousel-control-next'],attrs:{href:'#',role:'button','aria-controls':this.safeId('__BV_inner_')},on:{click:function click(evt){_this3.handleClick(evt,_this3.next);},keydown:function keydown(evt){_this3.handleClick(evt,_this3.next);}}},[h('span',{class:['carousel-control-next-icon'],attrs:{'aria-hidden':'true'}}),h('span',{class:['sr-only']},[this.labelNext])])];}// Indicators\nvar indicators=h('ol',{class:['carousel-indicators'],directives:[{name:'show',rawName:'v-show',value:this.indicators,expression:'indicators'}],attrs:{id:this.safeId('__BV_indicators_'),'aria-hidden':this.indicators?'false':'true','aria-label':this.labelIndicators,'aria-owns':this.safeId('__BV_inner_')}},this.slides.map(function(slide,n){return h('li',{key:\"slide_\".concat(n),class:{active:n===_this3.index},attrs:{role:'button',id:_this3.safeId(\"__BV_indicator_\".concat(n+1,\"_\")),tabindex:_this3.indicators?'0':'-1','aria-current':n===_this3.index?'true':'false','aria-label':\"\".concat(_this3.labelGotoSlide,\" \").concat(n+1),'aria-describedby':_this3.slides[n].id||null,'aria-controls':_this3.safeId('__BV_inner_')},on:{click:function click(evt){_this3.handleClick(evt,function(){_this3.setSlide(n);});},keydown:function keydown(evt){_this3.handleClick(evt,function(){_this3.setSlide(n);});}}});}));var on={mouseenter:this.pause,mouseleave:this.restart,focusin:this.pause,focusout:this.restart,keydown:function keydown(evt){if(/input|textarea/i.test(evt.target.tagName)){/* istanbul ignore next */return;}var keyCode=evt.keyCode;if(keyCode===KEY_CODES.LEFT||keyCode===KEY_CODES.RIGHT){evt.preventDefault();evt.stopPropagation();_this3[keyCode===KEY_CODES.LEFT?'prev':'next']();}}// Touch support event handlers for environment\n};if(!this.noTouch&&hasTouchSupport){/* istanbul ignore next: JSDOM doesn't support touch events */ // Attach appropriate listeners (passsive mode)\nif(hasPointerEvent){on['&pointerdown']=this.touchStart;on['&pointerup']=this.touchEnd;}else{on['&touchstart']=this.touchStart;on['&touchmove']=this.touchMove;on['&touchend']=this.touchEnd;}}// Return the carousel\nreturn h('div',{staticClass:'carousel',class:{slide:!this.noAnimation,'carousel-fade':!this.noAnimation&&this.fade,'pointer-event':!this.noTouch&&hasTouchSupport&&hasPointerEvent},style:{background:this.background},attrs:{role:'region',id:this.safeId(),'aria-busy':this.isSliding?'true':'false'},on:on},[inner,controls,indicators]);}};var BCarouselSlide={name:'BCarouselSlide',components:{BImg:BImg},mixins:[idMixin],inject:{bvCarousel:{default:function _default(){return{// Explicitly disable touch if not a child of carousel\nnoTouch:true};}}},props:{imgSrc:{type:String// default: undefined\n},imgAlt:{type:String// default: undefined\n},imgWidth:{type:[Number,String]// default: undefined\n},imgHeight:{type:[Number,String]// default: undefined\n},imgBlank:{type:Boolean,default:false},imgBlankColor:{type:String,default:'transparent'},contentVisibleUp:{type:String},contentTag:{type:String,default:'div'},caption:{type:String},captionHtml:{type:String},captionTag:{type:String,default:'h3'},text:{type:String},textHtml:{type:String},textTag:{type:String,default:'p'},background:{type:String}},data:function data(){return{};},computed:{contentClasses:function contentClasses(){return[this.contentVisibleUp?'d-none':'',this.contentVisibleUp?\"d-\".concat(this.contentVisibleUp,\"-block\"):''];},computedWidth:function computedWidth(){// Use local width, or try parent width\nreturn this.imgWidth||this.bvCarousel.imgWidth||null;},computedHeight:function computedHeight(){// Use local height, or try parent height\nreturn this.imgHeight||this.bvCarousel.imgHeight||null;}},render:function render(h){var $slots=this.$slots;var noDrag=!this.bvCarousel.noTouch&&hasTouchSupport;var img=$slots.img;if(!img&&(this.imgSrc||this.imgBlank)){img=h('b-img',{props:{fluidGrow:true,block:true,src:this.imgSrc,blank:this.imgBlank,blankColor:this.imgBlankColor,width:this.computedWidth,height:this.computedHeight,alt:this.imgAlt},// Touch support event handler\non:noDrag?{dragstart:function dragstart(e){e.preventDefault();}}:{}});}if(!img){img=h(false);}var content=h(this.contentTag,{staticClass:'carousel-caption',class:this.contentClasses},[this.caption||this.captionHtml?h(this.captionTag,{domProps:htmlOrText(this.captionHtml,this.caption)}):h(false),this.text||this.textHtml?h(this.textTag,{domProps:htmlOrText(this.textHtml,this.text)}):h(false),$slots.default]);return h('div',{staticClass:'carousel-item',style:{background:this.background||this.bvCarousel.background||null},attrs:{id:this.safeId(),role:'listitem'}},[img,content]);}};var components$8={BCarousel:BCarousel,BCarouselSlide:BCarouselSlide};var index$8={install:function install(Vue){registerComponents(Vue,components$8);}};var props$j={tag:{type:String,default:'div'},fluid:{type:Boolean,default:false// @vue/component\n}};var Container={name:'BContainer',functional:true,props:props$j,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{class:{container:!props.fluid,'container-fluid':props.fluid}}),children);}};var COMMON_ALIGNMENT=['start','end','center'];var props$k={tag:{type:String,default:'div'},noGutters:{type:Boolean,default:false},alignV:{type:String,default:null,validator:function validator(str){return arrayIncludes(COMMON_ALIGNMENT.concat(['baseline','stretch']),str);}},alignH:{type:String,default:null,validator:function validator(str){return arrayIncludes(COMMON_ALIGNMENT.concat(['between','around']),str);}},alignContent:{type:String,default:null,validator:function validator(str){return arrayIncludes(COMMON_ALIGNMENT.concat(['between','around','stretch']),str);}// @vue/component\n}};var BRow={name:'BRow',functional:true,props:props$k,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{staticClass:'row',class:(_class={'no-gutters':props.noGutters},_defineProperty(_class,\"align-items-\".concat(props.alignV),props.alignV),_defineProperty(_class,\"justify-content-\".concat(props.alignH),props.alignH),_defineProperty(_class,\"align-content-\".concat(props.alignContent),props.alignContent),_class)}),children);}};var memoize=function memoize(fn){var cache=create(null);return function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var argsKey=JSON.stringify(args);return cache[argsKey]=cache[argsKey]||fn.apply(null,args);};};/**\n   * Suffix can be a falsey value so nothing is appended to string.\n   * (helps when looping over props & some shouldn't change)\n   * Use data last parameters to allow for currying.\n   * @param {string} suffix\n   * @param {string} str\n   */var suffixPropName=function suffixPropName(suffix,str){return str+(suffix?upperFirst(suffix):'');};/**\n   * Generates a prop object with a type of\n   * [Boolean, String, Number]\n   */function boolStrNum(){return{type:[Boolean,String,Number],default:false};}/**\n   * Generates a prop object with a type of\n   * [String, Number]\n   */function strNum(){return{type:[String,Number],default:null};}var computeBkPtClass=memoize(function computeBkPt(type,breakpoint,val){var className=type;if(val===false||val===null||val===undefined){return undefined;}if(breakpoint){className+=\"-\".concat(breakpoint);}// Handling the boolean style prop when accepting [Boolean, String, Number]\n// means Vue will not convert <b-col sm /> to sm: true for us.\n// Since the default is false, an empty string indicates the prop's presence.\nif(type==='col'&&(val===''||val===true)){// .col-md\nreturn className.toLowerCase();}// .order-md-6\nclassName+=\"-\".concat(val);return className.toLowerCase();});var BREAKPOINTS=['sm','md','lg','xl'];// Supports classes like: .col-sm, .col-md-6, .col-lg-auto\nvar breakpointCol=BREAKPOINTS.reduce(// eslint-disable-next-line no-sequences\nfunction(propMap,breakpoint){return propMap[breakpoint]=boolStrNum(),propMap;},create(null));// Supports classes like: .offset-md-1, .offset-lg-12\nvar breakpointOffset=BREAKPOINTS.reduce(// eslint-disable-next-line no-sequences\nfunction(propMap,breakpoint){return propMap[suffixPropName(breakpoint,'offset')]=strNum(),propMap;},create(null));// Supports classes like: .order-md-1, .order-lg-12\nvar breakpointOrder=BREAKPOINTS.reduce(// eslint-disable-next-line no-sequences\nfunction(propMap,breakpoint){return propMap[suffixPropName(breakpoint,'order')]=strNum(),propMap;},create(null));// For loop doesn't need to check hasOwnProperty\n// when using an object created from null\nvar breakpointPropMap=assign(create(null),{col:keys(breakpointCol),offset:keys(breakpointOffset),order:keys(breakpointOrder)});var props$l=_objectSpread({},breakpointCol,breakpointOffset,breakpointOrder,{tag:{type:String,default:'div'},// Generic flexbox .col\ncol:{type:Boolean,default:false},// .col-[1-12]|auto\ncols:strNum(),// .offset-[1-12]\noffset:strNum(),// Flex ordering utility .order-[1-12]\norder:strNum(),alignSelf:{type:String,default:null,validator:function validator(str){return arrayIncludes(['auto','start','end','center','baseline','stretch'],str);}/**\n     * We need \".col\" to default in when no other props are passed,\n     * but always render when col=true.\n     */ // @vue/component\n}});var BCol={name:'BCol',functional:true,props:props$l,render:function render(h,_ref){var _classList$push;var props=_ref.props,data=_ref.data,children=_ref.children;var classList=[];// Loop through `col`, `offset`, `order` breakpoint props\nfor(var type in breakpointPropMap){// Returns colSm, offset, offsetSm, orderMd, etc.\nvar _keys=breakpointPropMap[type];for(var i=0;i<_keys.length;i++){// computeBkPt(col, colSm => Sm, value=[String, Number, Boolean])\nvar c=computeBkPtClass(type,_keys[i].replace(type,''),props[_keys[i]]);// If a class is returned, push it onto the array.\nif(c){classList.push(c);}}}classList.push((_classList$push={// Default to .col if no other classes generated nor `cols` specified.\ncol:props.col||classList.length===0&&!props.cols},_defineProperty(_classList$push,\"col-\".concat(props.cols),props.cols),_defineProperty(_classList$push,\"offset-\".concat(props.offset),props.offset),_defineProperty(_classList$push,\"order-\".concat(props.order),props.order),_defineProperty(_classList$push,\"align-self-\".concat(props.alignSelf),props.alignSelf),_classList$push));return h(props.tag,mergeData(data,{class:classList}),children);}};var props$m={tag:{type:String,default:'div'// @vue/component\n}};var BFormRow={name:'BFormRow',functional:true,props:props$m,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{staticClass:'form-row'}),children);}};var components$9={BContainer:Container,BRow:BRow,BCol:BCol,BFormRow:BFormRow};var index$9={install:function install(Vue){registerComponents(Vue,components$9);}};/**\n   * Issue #569: collapse::toggle::state triggered too many times\n   * @link https://github.com/bootstrap-vue/bootstrap-vue/issues/569\n   */ // @vue/component\nvar listenOnRootMixin={methods:{/**\n       * Safely register event listeners on the root Vue node.\n       * While Vue automatically removes listeners for individual components,\n       * when a component registers a listener on root and is destroyed,\n       * this orphans a callback because the node is gone,\n       * but the root does not clear the callback.\n       *\n       * When registering a $root listener, it also registers a listener on\n       * the component's `beforeDestroy` hook to automatically remove the\n       * event listener from the $root instance.\n       *\n       * @param {string} event\n       * @param {function} callback\n       * @chainable\n       */listenOnRoot:function listenOnRoot(event,callback){var _this=this;this.$root.$on(event,callback);this.$on('hook:beforeDestroy',function(){_this.$root.$off(event,callback);});// Return this for easy chaining\nreturn this;},/**\n       * Convenience method for calling vm.$emit on vm.$root.\n       * @param {string} event\n       * @param {*} args\n       * @chainable\n       */emitOnRoot:function emitOnRoot(event){var _this$$root;for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}(_this$$root=this.$root).$emit.apply(_this$$root,[event].concat(args));// Return this for easy chaining\nreturn this;}}};var EVENT_STATE='bv::collapse::state';var EVENT_ACCORDION='bv::collapse::accordion';// Events we listen to on $root\nvar EVENT_TOGGLE='bv::toggle::collapse';// Event Listener options\nvar EventOptions$2={passive:true,capture:false// @vue/component\n};var BCollapse={name:'BCollapse',mixins:[listenOnRootMixin],model:{prop:'visible',event:'input'},props:{id:{type:String,required:true},isNav:{type:Boolean,default:false},accordion:{type:String,default:null},visible:{type:Boolean,default:false},tag:{type:String,default:'div'}},data:function data(){return{show:this.visible,transitioning:false};},computed:{classObject:function classObject(){return{'navbar-collapse':this.isNav,collapse:!this.transitioning,show:this.show&&!this.transitioning};}},watch:{visible:function visible(newVal){if(newVal!==this.show){this.show=newVal;}},show:function show(newVal,oldVal){if(newVal!==oldVal){this.emitState();}}},created:function created(){// Listen for toggle events to open/close us\nthis.listenOnRoot(EVENT_TOGGLE,this.handleToggleEvt);// Listen to other collapses for accordion events\nthis.listenOnRoot(EVENT_ACCORDION,this.handleAccordionEvt);},mounted:function mounted(){if(this.isNav&&inBrowser){// Set up handlers\nthis.setWindowEvents(true);this.handleResize();}this.emitState();},deactivated:function deactivated()/* istanbul ignore next */{if(this.isNav&&inBrowser){this.setWindowEvents(false);}},activated:function activated()/* istanbul ignore next */{if(this.isNav&&inBrowser){this.setWindowEvents(true);}},updated:function updated(){this.$root.$emit(EVENT_STATE,this.id,this.show);},beforeDestroy:function beforeDestroy()/* istanbul ignore next */{if(this.isNav&&inBrowser){this.setWindowEvents(false);}},methods:{setWindowEvents:function setWindowEvents(on){var method=on?eventOn:eventOff;method(window,'resize',this.handleResize,EventOptions$2);method(window,'orientationchange',this.handleResize,EventOptions$2);},toggle:function toggle(){this.show=!this.show;},onEnter:function onEnter(el){el.style.height=0;reflow(el);el.style.height=el.scrollHeight+'px';this.transitioning=true;// This should be moved out so we can add cancellable events\nthis.$emit('show');},onAfterEnter:function onAfterEnter(el){el.style.height=null;this.transitioning=false;this.$emit('shown');},onLeave:function onLeave(el){el.style.height='auto';el.style.display='block';el.style.height=getBCR(el).height+'px';reflow(el);this.transitioning=true;el.style.height=0;// This should be moved out so we can add cancellable events\nthis.$emit('hide');},onAfterLeave:function onAfterLeave(el){el.style.height=null;this.transitioning=false;this.$emit('hidden');},emitState:function emitState(){this.$emit('input',this.show);// Let v-b-toggle know the state of this collapse\nthis.$root.$emit(EVENT_STATE,this.id,this.show);if(this.accordion&&this.show){// Tell the other collapses in this accordion to close\nthis.$root.$emit(EVENT_ACCORDION,this.id,this.accordion);}},clickHandler:function clickHandler(evt){// If we are in a nav/navbar, close the collapse when non-disabled link clicked\nvar el=evt.target;if(!this.isNav||!el||getCS(this.$el).display!=='block'){return;}if(matches(el,'.nav-link,.dropdown-item')||closest('.nav-link,.dropdown-item',el)){this.show=false;}},handleToggleEvt:function handleToggleEvt(target){if(target!==this.id){return;}this.toggle();},handleAccordionEvt:function handleAccordionEvt(openedId,accordion){if(!this.accordion||accordion!==this.accordion){return;}if(openedId===this.id){// Open this collapse if not shown\nif(!this.show){this.toggle();}}else{// Close this collapse if shown\nif(this.show){this.toggle();}}},handleResize:function handleResize(){// Handler for orientation/resize to set collapsed state in nav/navbar\nthis.show=getCS(this.$el).display==='block';}},render:function render(h){var content=h(this.tag,{class:this.classObject,directives:[{name:'show',value:this.show}],attrs:{id:this.id||null},on:{click:this.clickHandler}},[this.$slots.default]);return h('transition',{props:{enterClass:'',enterActiveClass:'collapsing',enterToClass:'',leaveClass:'',leaveActiveClass:'collapsing',leaveToClass:''},on:{enter:this.onEnter,afterEnter:this.onAfterEnter,leave:this.onLeave,afterLeave:this.onAfterLeave}},[content]);}};var allListenTypes={hover:true,click:true,focus:true};var BVBoundListeners='__BV_boundEventListeners__';var bindTargets=function bindTargets(vnode,binding,listenTypes,fn){var targets=keys(binding.modifiers||{}).filter(function(t){return!allListenTypes[t];});if(binding.value){targets.push(binding.value);}var listener=function listener(){fn({targets:targets,vnode:vnode});};keys(allListenTypes).forEach(function(type){if(listenTypes[type]||binding.modifiers[type]){eventOn(vnode.elm,type,listener);var boundListeners=vnode.elm[BVBoundListeners]||{};boundListeners[type]=boundListeners[type]||[];boundListeners[type].push(listener);vnode.elm[BVBoundListeners]=boundListeners;}});// Return the list of targets\nreturn targets;};var unbindTargets=function unbindTargets(vnode,binding,listenTypes){keys(allListenTypes).forEach(function(type){if(listenTypes[type]||binding.modifiers[type]){var boundListeners=vnode.elm[BVBoundListeners]&&vnode.elm[BVBoundListeners][type];if(boundListeners){boundListeners.forEach(function(listener){return eventOff(vnode.elm,type,listener);});delete vnode.elm[BVBoundListeners][type];}}});};var inBrowser$1=typeof window!=='undefined';// target listen types\nvar listenTypes={click:true// Property key for handler storage\n};var BVT='__BV_toggle__';// Emitted Control Event for collapse (emitted to collapse)\nvar EVENT_TOGGLE$1='bv::toggle::collapse';// Listen to Event for toggle state update (Emited by collapse)\nvar EVENT_STATE$1='bv::collapse::state';var bToggle={bind:function bind(el,binding,vnode){var targets=bindTargets(vnode,binding,listenTypes,function(_ref){var targets=_ref.targets,vnode=_ref.vnode;targets.forEach(function(target){vnode.context.$root.$emit(EVENT_TOGGLE$1,target);});});if(inBrowser$1&&vnode.context&&targets.length>0){// Add aria attributes to element\nsetAttr(el,'aria-controls',targets.join(' '));setAttr(el,'aria-expanded','false');if(el.tagName!=='BUTTON'){// If element is not a button, we add `role=\"button\"` for accessibility\nsetAttr(el,'role','button');}// Toggle state hadnler, stored on element\nel[BVT]=function toggleDirectiveHandler(id,state){if(targets.indexOf(id)!==-1){// Set aria-expanded state\nsetAttr(el,'aria-expanded',state?'true':'false');// Set/Clear 'collapsed' class state\nif(state){removeClass(el,'collapsed');}else{addClass(el,'collapsed');}}};// Listen for toggle state changes\nvnode.context.$root.$on(EVENT_STATE$1,el[BVT]);}},unbind:function unbind(el,binding,vnode){if(el[BVT]){// Remove our $root listener\nvnode.context.$root.$off(EVENT_STATE$1,el[BVT]);el[BVT]=null;}}};var directives={bToggle:bToggle};var toggleDirectivePlugin={install:function install(Vue){registerDirectives(Vue,directives);}};var components$a={BCollapse:BCollapse};var collapsePlugin={install:function install(Vue){registerComponents(Vue,components$a);Vue.use(toggleDirectivePlugin);}};/**!\n   * @fileOverview Kickass library to create and place poppers near their reference elements.\n   * @version 1.14.7\n   * @license\n   * Copyright (c) 2016 Federico Zivolo and contributors\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in all\n   * copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   * SOFTWARE.\n   */var isBrowser=typeof window!=='undefined'&&typeof document!=='undefined';var longerTimeoutBrowsers=['Edge','Trident','Firefox'];var timeoutDuration=0;for(var i=0;i<longerTimeoutBrowsers.length;i+=1){if(isBrowser&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0){timeoutDuration=1;break;}}function microtaskDebounce(fn){var called=false;return function(){if(called){return;}called=true;window.Promise.resolve().then(function(){called=false;fn();});};}function taskDebounce(fn){var scheduled=false;return function(){if(!scheduled){scheduled=true;setTimeout(function(){scheduled=false;fn();},timeoutDuration);}};}var supportsMicroTasks=isBrowser&&window.Promise;/**\n  * Create a debounced version of a method, that's asynchronously deferred\n  * but called in the minimum time possible.\n  *\n  * @method\n  * @memberof Popper.Utils\n  * @argument {Function} fn\n  * @returns {Function}\n  */var debounce=supportsMicroTasks?microtaskDebounce:taskDebounce;/**\n   * Check if the given variable is a function\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Any} functionToCheck - variable to check\n   * @returns {Boolean} answer to: is a function?\n   */function isFunction(functionToCheck){var getType={};return functionToCheck&&getType.toString.call(functionToCheck)==='[object Function]';}/**\n   * Get CSS computed property of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Eement} element\n   * @argument {String} property\n   */function getStyleComputedProperty(element,property){if(element.nodeType!==1){return[];}// NOTE: 1 DOM access here\nvar window=element.ownerDocument.defaultView;var css=window.getComputedStyle(element,null);return property?css[property]:css;}/**\n   * Returns the parentNode or the host of the element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} parent\n   */function getParentNode(element){if(element.nodeName==='HTML'){return element;}return element.parentNode||element.host;}/**\n   * Returns the scrolling parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} scroll parent\n   */function getScrollParent(element){// Return body, `getScroll` will take care to get the correct `scrollTop` from it\nif(!element){return document.body;}switch(element.nodeName){case'HTML':case'BODY':return element.ownerDocument.body;case'#document':return element.body;}// Firefox want us to check `-x` and `-y` variations as well\nvar _getStyleComputedProp=getStyleComputedProperty(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;if(/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)){return element;}return getScrollParent(getParentNode(element));}var isIE11=isBrowser&&!!(window.MSInputMethodContext&&document.documentMode);var isIE10=isBrowser&&/MSIE 10/.test(navigator.userAgent);/**\n   * Determines if the browser is Internet Explorer\n   * @method\n   * @memberof Popper.Utils\n   * @param {Number} version to check\n   * @returns {Boolean} isIE\n   */function isIE(version){if(version===11){return isIE11;}if(version===10){return isIE10;}return isIE11||isIE10;}/**\n   * Returns the offset parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */function getOffsetParent(element){if(!element){return document.documentElement;}var noOffsetParent=isIE(10)?document.body:null;// NOTE: 1 DOM access here\nvar offsetParent=element.offsetParent||null;// Skip hidden elements which don't have an offsetParent\nwhile(offsetParent===noOffsetParent&&element.nextElementSibling){offsetParent=(element=element.nextElementSibling).offsetParent;}var nodeName=offsetParent&&offsetParent.nodeName;if(!nodeName||nodeName==='BODY'||nodeName==='HTML'){return element?element.ownerDocument.documentElement:document.documentElement;}// .offsetParent will return the closest TH, TD or TABLE in case\n// no offsetParent is present, I hate this job...\nif(['TH','TD','TABLE'].indexOf(offsetParent.nodeName)!==-1&&getStyleComputedProperty(offsetParent,'position')==='static'){return getOffsetParent(offsetParent);}return offsetParent;}function isOffsetContainer(element){var nodeName=element.nodeName;if(nodeName==='BODY'){return false;}return nodeName==='HTML'||getOffsetParent(element.firstElementChild)===element;}/**\n   * Finds the root node (document, shadowDOM root) of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} node\n   * @returns {Element} root node\n   */function getRoot(node){if(node.parentNode!==null){return getRoot(node.parentNode);}return node;}/**\n   * Finds the offset parent common to the two provided nodes\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element1\n   * @argument {Element} element2\n   * @returns {Element} common offset parent\n   */function findCommonOffsetParent(element1,element2){// This check is needed to avoid errors in case one of the elements isn't defined for any reason\nif(!element1||!element1.nodeType||!element2||!element2.nodeType){return document.documentElement;}// Here we make sure to give as \"start\" the element that comes first in the DOM\nvar order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING;var start=order?element1:element2;var end=order?element2:element1;// Get common ancestor container\nvar range=document.createRange();range.setStart(start,0);range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;// Both nodes are inside #document\nif(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end)){if(isOffsetContainer(commonAncestorContainer)){return commonAncestorContainer;}return getOffsetParent(commonAncestorContainer);}// one of the nodes is inside shadowDOM, find which one\nvar element1root=getRoot(element1);if(element1root.host){return findCommonOffsetParent(element1root.host,element2);}else{return findCommonOffsetParent(element1,getRoot(element2).host);}}/**\n   * Gets the scroll value of the given element in the given side (top and left)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {String} side `top` or `left`\n   * @returns {number} amount of scrolled pixels\n   */function getScroll(element){var side=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'top';var upperSide=side==='top'?'scrollTop':'scrollLeft';var nodeName=element.nodeName;if(nodeName==='BODY'||nodeName==='HTML'){var html=element.ownerDocument.documentElement;var scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide];}return element[upperSide];}/*\n   * Sum or subtract the element scroll values (left and top) from a given rect object\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} rect - Rect object you want to change\n   * @param {HTMLElement} element - The element from the function reads the scroll values\n   * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n   * @return {Object} rect - The modifier rect object\n   */function includeScroll(rect,element){var subtract=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var scrollTop=getScroll(element,'top');var scrollLeft=getScroll(element,'left');var modifier=subtract?-1:1;rect.top+=scrollTop*modifier;rect.bottom+=scrollTop*modifier;rect.left+=scrollLeft*modifier;rect.right+=scrollLeft*modifier;return rect;}/*\n   * Helper to detect borders of a given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {CSSStyleDeclaration} styles\n   * Result of `getStyleComputedProperty` on the given element\n   * @param {String} axis - `x` or `y`\n   * @return {number} borders - The borders size of the given axis\n   */function getBordersSize(styles,axis){var sideA=axis==='x'?'Left':'Top';var sideB=sideA==='Left'?'Right':'Bottom';return parseFloat(styles['border'+sideA+'Width'],10)+parseFloat(styles['border'+sideB+'Width'],10);}function getSize(axis,body,html,computedStyle){return Math.max(body['offset'+axis],body['scroll'+axis],html['client'+axis],html['offset'+axis],html['scroll'+axis],isIE(10)?parseInt(html['offset'+axis])+parseInt(computedStyle['margin'+(axis==='Height'?'Top':'Left')])+parseInt(computedStyle['margin'+(axis==='Height'?'Bottom':'Right')]):0);}function getWindowSizes(document){var body=document.body;var html=document.documentElement;var computedStyle=isIE(10)&&getComputedStyle(html);return{height:getSize('Height',body,html,computedStyle),width:getSize('Width',body,html,computedStyle)};}var classCallCheck=function classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}};var createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var defineProperty$1=function defineProperty$1(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;};var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};/**\n   * Given element offsets, generate an output similar to getBoundingClientRect\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} offsets\n   * @returns {Object} ClientRect like output\n   */function getClientRect(offsets){return _extends({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height});}/**\n   * Get bounding client rect of given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} element\n   * @return {Object} client rect\n   */function getBoundingClientRect(element){var rect={};// IE10 10 FIX: Please, don't ask, the element isn't\n// considered in DOM in some circumstances...\n// This isn't reproducible in IE10 compatibility mode of IE11\ntry{if(isIE(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll(element,'top');var scrollLeft=getScroll(element,'left');rect.top+=scrollTop;rect.left+=scrollLeft;rect.bottom+=scrollTop;rect.right+=scrollLeft;}else{rect=element.getBoundingClientRect();}}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top};// subtract scrollbar size from sizes\nvar sizes=element.nodeName==='HTML'?getWindowSizes(element.ownerDocument):{};var width=sizes.width||element.clientWidth||result.right-result.left;var height=sizes.height||element.clientHeight||result.bottom-result.top;var horizScrollbar=element.offsetWidth-width;var vertScrollbar=element.offsetHeight-height;// if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n// we make this check conditional for performance reasons\nif(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty(element);horizScrollbar-=getBordersSize(styles,'x');vertScrollbar-=getBordersSize(styles,'y');result.width-=horizScrollbar;result.height-=vertScrollbar;}return getClientRect(result);}function getOffsetRectRelativeToArbitraryNode(children,parent){var fixedPosition=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var isIE10=isIE(10);var isHTML=parent.nodeName==='HTML';var childrenRect=getBoundingClientRect(children);var parentRect=getBoundingClientRect(parent);var scrollParent=getScrollParent(children);var styles=getStyleComputedProperty(parent);var borderTopWidth=parseFloat(styles.borderTopWidth,10);var borderLeftWidth=parseFloat(styles.borderLeftWidth,10);// In cases where the parent is fixed, we must ignore negative scroll in offset calc\nif(fixedPosition&&isHTML){parentRect.top=Math.max(parentRect.top,0);parentRect.left=Math.max(parentRect.left,0);}var offsets=getClientRect({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});offsets.marginTop=0;offsets.marginLeft=0;// Subtract margins of documentElement in case it's being used as parent\n// we do this only on HTML because it's the only element that behaves\n// differently when margins are applied to it. The margins are included in\n// the box of the documentElement, in the other cases not.\nif(!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop,10);var marginLeft=parseFloat(styles.marginLeft,10);offsets.top-=borderTopWidth-marginTop;offsets.bottom-=borderTopWidth-marginTop;offsets.left-=borderLeftWidth-marginLeft;offsets.right-=borderLeftWidth-marginLeft;// Attach marginTop and marginLeft because in some circumstances we may need them\noffsets.marginTop=marginTop;offsets.marginLeft=marginLeft;}if(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&scrollParent.nodeName!=='BODY'){offsets=includeScroll(offsets,parent);}return offsets;}function getViewportOffsetRectRelativeToArtbitraryNode(element){var excludeScroll=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var html=element.ownerDocument.documentElement;var relativeOffset=getOffsetRectRelativeToArbitraryNode(element,html);var width=Math.max(html.clientWidth,window.innerWidth||0);var height=Math.max(html.clientHeight,window.innerHeight||0);var scrollTop=!excludeScroll?getScroll(html):0;var scrollLeft=!excludeScroll?getScroll(html,'left'):0;var offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect(offset);}/**\n   * Check if the given element is fixed or is inside a fixed parent\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {Element} customContainer\n   * @returns {Boolean} answer to \"isFixed?\"\n   */function isFixed(element){var nodeName=element.nodeName;if(nodeName==='BODY'||nodeName==='HTML'){return false;}if(getStyleComputedProperty(element,'position')==='fixed'){return true;}var parentNode=getParentNode(element);if(!parentNode){return false;}return isFixed(parentNode);}/**\n   * Finds the first parent of an element that has a transformed property defined\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} first transformed parent or documentElement\n   */function getFixedPositionOffsetParent(element){// This check is needed to avoid errors in case one of the elements isn't defined for any reason\nif(!element||!element.parentElement||isIE()){return document.documentElement;}var el=element.parentElement;while(el&&getStyleComputedProperty(el,'transform')==='none'){el=el.parentElement;}return el||document.documentElement;}/**\n   * Computed the boundaries limits and return them\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} popper\n   * @param {HTMLElement} reference\n   * @param {number} padding\n   * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n   * @param {Boolean} fixedPosition - Is in fixed position mode\n   * @returns {Object} Coordinates of the boundaries\n   */function getBoundaries(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;// NOTE: 1 DOM access here\nvar boundaries={top:0,left:0};var offsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,reference);// Handle viewport case\nif(boundariesElement==='viewport'){boundaries=getViewportOffsetRectRelativeToArtbitraryNode(offsetParent,fixedPosition);}else{// Handle other cases based on DOM element used as boundaries\nvar boundariesNode=void 0;if(boundariesElement==='scrollParent'){boundariesNode=getScrollParent(getParentNode(reference));if(boundariesNode.nodeName==='BODY'){boundariesNode=popper.ownerDocument.documentElement;}}else if(boundariesElement==='window'){boundariesNode=popper.ownerDocument.documentElement;}else{boundariesNode=boundariesElement;}var offsets=getOffsetRectRelativeToArbitraryNode(boundariesNode,offsetParent,fixedPosition);// In case of HTML, we need a different computation\nif(boundariesNode.nodeName==='HTML'&&!isFixed(offsetParent)){var _getWindowSizes=getWindowSizes(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop;boundaries.bottom=height+offsets.top;boundaries.left+=offsets.left-offsets.marginLeft;boundaries.right=width+offsets.left;}else{// for all the other DOM elements, this one is good\nboundaries=offsets;}}// Add paddings\npadding=padding||0;var isPaddingNumber=typeof padding==='number';boundaries.left+=isPaddingNumber?padding:padding.left||0;boundaries.top+=isPaddingNumber?padding:padding.top||0;boundaries.right-=isPaddingNumber?padding:padding.right||0;boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0;return boundaries;}function getArea(_ref){var width=_ref.width,height=_ref.height;return width*height;}/**\n   * Utility used to transform the `auto` placement to the placement with more\n   * available space.\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function computeAutoPlacement(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;if(placement.indexOf('auto')===-1){return placement;}var boundaries=getBoundaries(popper,reference,padding,boundariesElement);var rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}};var sortedAreas=Object.keys(rects).map(function(key){return _extends({key:key},rects[key],{area:getArea(rects[key])});}).sort(function(a,b){return b.area-a.area;});var filteredAreas=sortedAreas.filter(function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight;});var computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key;var variation=placement.split('-')[1];return computedPlacement+(variation?'-'+variation:'');}/**\n   * Get offsets to the reference element\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} state\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @param {Element} fixedPosition - is in fixed position mode\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */function getReferenceOffsets(state,popper,reference){var fixedPosition=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;var commonOffsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,reference);return getOffsetRectRelativeToArbitraryNode(reference,commonOffsetParent,fixedPosition);}/**\n   * Get the outer sizes of the given element (offset size + margins)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Object} object containing width and height properties\n   */function getOuterSizes(element){var window=element.ownerDocument.defaultView;var styles=window.getComputedStyle(element);var x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0);var y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0);var result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result;}/**\n   * Get the opposite placement of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement\n   * @returns {String} flipped placement\n   */function getOppositePlacement(placement){var hash={left:'right',right:'left',bottom:'top',top:'bottom'};return placement.replace(/left|right|bottom|top/g,function(matched){return hash[matched];});}/**\n   * Get offsets to the popper\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} position - CSS position the Popper will get applied\n   * @param {HTMLElement} popper - the popper element\n   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n   * @param {String} placement - one of the valid placement options\n   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n   */function getPopperOffsets(popper,referenceOffsets,placement){placement=placement.split('-')[0];// Get popper node sizes\nvar popperRect=getOuterSizes(popper);// Add position, width and height to our offsets object\nvar popperOffsets={width:popperRect.width,height:popperRect.height};// depending by the popper placement we have to compute its offsets slightly differently\nvar isHoriz=['right','left'].indexOf(placement)!==-1;var mainSide=isHoriz?'top':'left';var secondarySide=isHoriz?'left':'top';var measurement=isHoriz?'height':'width';var secondaryMeasurement=!isHoriz?'height':'width';popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2;if(placement===secondarySide){popperOffsets[secondarySide]=referenceOffsets[secondarySide]-popperRect[secondaryMeasurement];}else{popperOffsets[secondarySide]=referenceOffsets[getOppositePlacement(secondarySide)];}return popperOffsets;}/**\n   * Mimics the `find` method of Array\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */function find(arr,check){// use native find if supported\nif(Array.prototype.find){return arr.find(check);}// use `filter` to obtain the same behavior of `find`\nreturn arr.filter(check)[0];}/**\n   * Return the index of the matching object\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */function findIndex(arr,prop,value){// use native findIndex if supported\nif(Array.prototype.findIndex){return arr.findIndex(function(cur){return cur[prop]===value;});}// use `find` + `indexOf` if `findIndex` isn't supported\nvar match=find(arr,function(obj){return obj[prop]===value;});return arr.indexOf(match);}/**\n   * Loop trough the list of modifiers and run them in order,\n   * each of them will then edit the data object.\n   * @method\n   * @memberof Popper.Utils\n   * @param {dataObject} data\n   * @param {Array} modifiers\n   * @param {String} ends - Optional modifier name used as stopper\n   * @returns {dataObject}\n   */function runModifiers(modifiers,data,ends){var modifiersToRun=ends===undefined?modifiers:modifiers.slice(0,findIndex(modifiers,'name',ends));modifiersToRun.forEach(function(modifier){if(modifier['function']){// eslint-disable-line dot-notation\nconsole.warn('`modifier.function` is deprecated, use `modifier.fn`!');}var fn=modifier['function']||modifier.fn;// eslint-disable-line dot-notation\nif(modifier.enabled&&isFunction(fn)){// Add properties to offsets to make them a complete clientRect object\n// we do this before each modifier to make sure the previous one doesn't\n// mess with these values\ndata.offsets.popper=getClientRect(data.offsets.popper);data.offsets.reference=getClientRect(data.offsets.reference);data=fn(data,modifier);}});return data;}/**\n   * Updates the position of the popper, computing the new offsets and applying\n   * the new style.<br />\n   * Prefer `scheduleUpdate` over `update` because of performance reasons.\n   * @method\n   * @memberof Popper\n   */function update(){// if popper is destroyed, don't perform any further update\nif(this.state.isDestroyed){return;}var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:false,offsets:{}};// compute reference element offsets\ndata.offsets.reference=getReferenceOffsets(this.state,this.popper,this.reference,this.options.positionFixed);// compute auto placement, store placement inside the data object,\n// modifiers will be able to edit `placement` if needed\n// and refer to originalPlacement to know the original value\ndata.placement=computeAutoPlacement(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding);// store the computed placement inside `originalPlacement`\ndata.originalPlacement=data.placement;data.positionFixed=this.options.positionFixed;// compute the popper offsets\ndata.offsets.popper=getPopperOffsets(this.popper,data.offsets.reference,data.placement);data.offsets.popper.position=this.options.positionFixed?'fixed':'absolute';// run the modifiers\ndata=runModifiers(this.modifiers,data);// the first `update` will call `onCreate` callback\n// the other ones will call `onUpdate` callback\nif(!this.state.isCreated){this.state.isCreated=true;this.options.onCreate(data);}else{this.options.onUpdate(data);}}/**\n   * Helper used to know if the given modifier is enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @returns {Boolean}\n   */function isModifierEnabled(modifiers,modifierName){return modifiers.some(function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName;});}/**\n   * Get the prefixed supported property name\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} property (camelCase)\n   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n   */function getSupportedPropertyName(property){var prefixes=[false,'ms','Webkit','Moz','O'];var upperProp=property.charAt(0).toUpperCase()+property.slice(1);for(var i=0;i<prefixes.length;i++){var prefix=prefixes[i];var toCheck=prefix?''+prefix+upperProp:property;if(typeof document.body.style[toCheck]!=='undefined'){return toCheck;}}return null;}/**\n   * Destroys the popper.\n   * @method\n   * @memberof Popper\n   */function destroy(){this.state.isDestroyed=true;// touch DOM only if `applyStyle` modifier is enabled\nif(isModifierEnabled(this.modifiers,'applyStyle')){this.popper.removeAttribute('x-placement');this.popper.style.position='';this.popper.style.top='';this.popper.style.left='';this.popper.style.right='';this.popper.style.bottom='';this.popper.style.willChange='';this.popper.style[getSupportedPropertyName('transform')]='';}this.disableEventListeners();// remove the popper if user explicity asked for the deletion on destroy\n// do not use `remove` because IE11 doesn't support it\nif(this.options.removeOnDestroy){this.popper.parentNode.removeChild(this.popper);}return this;}/**\n   * Get the window associated with the element\n   * @argument {Element} element\n   * @returns {Window}\n   */function getWindow(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window;}function attachToScrollParents(scrollParent,event,callback,scrollParents){var isBody=scrollParent.nodeName==='BODY';var target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:true});if(!isBody){attachToScrollParents(getScrollParent(target.parentNode),event,callback,scrollParents);}scrollParents.push(target);}/**\n   * Setup needed event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */function setupEventListeners(reference,options,state,updateBound){// Resize event listener on window\nstate.updateBound=updateBound;getWindow(reference).addEventListener('resize',state.updateBound,{passive:true});// Scroll event listener on scroll parents\nvar scrollElement=getScrollParent(reference);attachToScrollParents(scrollElement,'scroll',state.updateBound,state.scrollParents);state.scrollElement=scrollElement;state.eventsEnabled=true;return state;}/**\n   * It will add resize/scroll events and start recalculating\n   * position of the popper element when they are triggered.\n   * @method\n   * @memberof Popper\n   */function enableEventListeners(){if(!this.state.eventsEnabled){this.state=setupEventListeners(this.reference,this.options,this.state,this.scheduleUpdate);}}/**\n   * Remove event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */function removeEventListeners(reference,state){// Remove resize event listener on window\ngetWindow(reference).removeEventListener('resize',state.updateBound);// Remove scroll event listener on scroll parents\nstate.scrollParents.forEach(function(target){target.removeEventListener('scroll',state.updateBound);});// Reset state\nstate.updateBound=null;state.scrollParents=[];state.scrollElement=null;state.eventsEnabled=false;return state;}/**\n   * It will remove resize/scroll events and won't recalculate popper position\n   * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n   * unless you call `update` method manually.\n   * @method\n   * @memberof Popper\n   */function disableEventListeners(){if(this.state.eventsEnabled){cancelAnimationFrame(this.scheduleUpdate);this.state=removeEventListeners(this.reference,this.state);}}/**\n   * Tells if a given input is a number\n   * @method\n   * @memberof Popper.Utils\n   * @param {*} input to check\n   * @return {Boolean}\n   */function isNumeric(n){return n!==''&&!isNaN(parseFloat(n))&&isFinite(n);}/**\n   * Set the style to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the style to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */function setStyles(element,styles){Object.keys(styles).forEach(function(prop){var unit='';// add unit if the value is numeric and is one of the following\nif(['width','height','top','right','bottom','left'].indexOf(prop)!==-1&&isNumeric(styles[prop])){unit='px';}element.style[prop]=styles[prop]+unit;});}/**\n   * Set the attributes to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the attributes to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */function setAttributes(element,attributes){Object.keys(attributes).forEach(function(prop){var value=attributes[prop];if(value!==false){element.setAttribute(prop,attributes[prop]);}else{element.removeAttribute(prop);}});}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} data.styles - List of style properties - values to apply to popper element\n   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The same data object\n   */function applyStyle(data){// any property present in `data.styles` will be applied to the popper,\n// in this way we can make the 3rd party modifiers add custom styles to it\n// Be aware, modifiers could override the properties defined in the previous\n// lines of this modifier!\nsetStyles(data.instance.popper,data.styles);// any property present in `data.attributes` will be applied to the popper,\n// they will be set as HTML attributes of the element\nsetAttributes(data.instance.popper,data.attributes);// if arrowElement is defined and arrowStyles has some properties\nif(data.arrowElement&&Object.keys(data.arrowStyles).length){setStyles(data.arrowElement,data.arrowStyles);}return data;}/**\n   * Set the x-placement attribute before everything else because it could be used\n   * to add margins to the popper margins needs to be calculated to get the\n   * correct popper offsets.\n   * @method\n   * @memberof Popper.modifiers\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper\n   * @param {Object} options - Popper.js options\n   */function applyStyleOnLoad(reference,popper,options,modifierOptions,state){// compute reference element offsets\nvar referenceOffsets=getReferenceOffsets(state,popper,reference,options.positionFixed);// compute auto placement, store placement inside the data object,\n// modifiers will be able to edit `placement` if needed\n// and refer to originalPlacement to know the original value\nvar placement=computeAutoPlacement(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);popper.setAttribute('x-placement',placement);// Apply `position` to popper before anything else because\n// without the position applied we can't guarantee correct computations\nsetStyles(popper,{position:options.positionFixed?'fixed':'absolute'});return options;}/**\n   * @function\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n   * @returns {Object} The popper's position offsets rounded\n   *\n   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n   * good as it can be within reason.\n   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n   *\n   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n   * as well on High DPI screens).\n   *\n   * Firefox prefers no rounding for positioning and does not have blurriness on\n   * high DPI screens.\n   *\n   * Only horizontal placement and left/right values need to be considered.\n   */function getRoundedOffsets(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var round=Math.round,floor=Math.floor;var noRound=function noRound(v){return v;};var referenceWidth=round(reference.width);var popperWidth=round(popper.width);var isVertical=['left','right'].indexOf(data.placement)!==-1;var isVariation=data.placement.indexOf('-')!==-1;var sameWidthParity=referenceWidth%2===popperWidth%2;var bothOddWidth=referenceWidth%2===1&&popperWidth%2===1;var horizontalToInteger=!shouldRound?noRound:isVertical||isVariation||sameWidthParity?round:floor;var verticalToInteger=!shouldRound?noRound:round;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)};}var isFirefox=isBrowser&&/Firefox/i.test(navigator.userAgent);/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function computeStyle(data,options){var x=options.x,y=options.y;var popper=data.offsets.popper;// Remove this legacy support in Popper.js v2\nvar legacyGpuAccelerationOption=find(data.instance.modifiers,function(modifier){return modifier.name==='applyStyle';}).gpuAcceleration;if(legacyGpuAccelerationOption!==undefined){console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');}var gpuAcceleration=legacyGpuAccelerationOption!==undefined?legacyGpuAccelerationOption:options.gpuAcceleration;var offsetParent=getOffsetParent(data.instance.popper);var offsetParentRect=getBoundingClientRect(offsetParent);// Styles\nvar styles={position:popper.position};var offsets=getRoundedOffsets(data,window.devicePixelRatio<2||!isFirefox);var sideA=x==='bottom'?'top':'bottom';var sideB=y==='right'?'left':'right';// if gpuAcceleration is set to `true` and transform is supported,\n//  we use `translate3d` to apply the position to the popper we\n// automatically use the supported prefixed version if needed\nvar prefixedProperty=getSupportedPropertyName('transform');// now, let's make a step back and look at this code closely (wtf?)\n// If the content of the popper grows once it's been positioned, it\n// may happen that the popper gets misplaced because of the new content\n// overflowing its reference element\n// To avoid this problem, we provide two options (x and y), which allow\n// the consumer to define the offset origin.\n// If we position a popper on top of a reference element, we can set\n// `x` to `top` to make the popper grow towards its top instead of\n// its bottom.\nvar left=void 0,top=void 0;if(sideA==='bottom'){// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n// and not the bottom of the html element\nif(offsetParent.nodeName==='HTML'){top=-offsetParent.clientHeight+offsets.bottom;}else{top=-offsetParentRect.height+offsets.bottom;}}else{top=offsets.top;}if(sideB==='right'){if(offsetParent.nodeName==='HTML'){left=-offsetParent.clientWidth+offsets.right;}else{left=-offsetParentRect.width+offsets.right;}}else{left=offsets.left;}if(gpuAcceleration&&prefixedProperty){styles[prefixedProperty]='translate3d('+left+'px, '+top+'px, 0)';styles[sideA]=0;styles[sideB]=0;styles.willChange='transform';}else{// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\nvar invertTop=sideA==='bottom'?-1:1;var invertLeft=sideB==='right'?-1:1;styles[sideA]=top*invertTop;styles[sideB]=left*invertLeft;styles.willChange=sideA+', '+sideB;}// Attributes\nvar attributes={'x-placement':data.placement};// Update `data` attributes, styles and arrowStyles\ndata.attributes=_extends({},attributes,data.attributes);data.styles=_extends({},styles,data.styles);data.arrowStyles=_extends({},data.offsets.arrow,data.arrowStyles);return data;}/**\n   * Helper used to know if the given modifier depends from another one.<br />\n   * It checks if the needed modifier is listed and enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Array} modifiers - list of modifiers\n   * @param {String} requestingName - name of requesting modifier\n   * @param {String} requestedName - name of requested modifier\n   * @returns {Boolean}\n   */function isModifierRequired(modifiers,requestingName,requestedName){var requesting=find(modifiers,function(_ref){var name=_ref.name;return name===requestingName;});var isRequired=!!requesting&&modifiers.some(function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order;});if(!isRequired){var _requesting='`'+requestingName+'`';var requested='`'+requestedName+'`';console.warn(requested+' modifier is required by '+_requesting+' modifier in order to work, be sure to include it before '+_requesting+'!');}return isRequired;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function arrow(data,options){var _data$offsets$arrow;// arrow depends on keepTogether in order to work\nif(!isModifierRequired(data.instance.modifiers,'arrow','keepTogether')){return data;}var arrowElement=options.element;// if arrowElement is a string, suppose it's a CSS selector\nif(typeof arrowElement==='string'){arrowElement=data.instance.popper.querySelector(arrowElement);// if arrowElement is not found, don't run the modifier\nif(!arrowElement){return data;}}else{// if the arrowElement isn't a query selector we must check that the\n// provided DOM node is child of its popper node\nif(!data.instance.popper.contains(arrowElement)){console.warn('WARNING: `arrow.element` must be child of its popper element!');return data;}}var placement=data.placement.split('-')[0];var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var isVertical=['left','right'].indexOf(placement)!==-1;var len=isVertical?'height':'width';var sideCapitalized=isVertical?'Top':'Left';var side=sideCapitalized.toLowerCase();var altSide=isVertical?'left':'top';var opSide=isVertical?'bottom':'right';var arrowElementSize=getOuterSizes(arrowElement)[len];//\n// extends keepTogether behavior making sure the popper and its\n// reference have enough pixels in conjunction\n//\n// top/left side\nif(reference[opSide]-arrowElementSize<popper[side]){data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize);}// bottom/right side\nif(reference[side]+arrowElementSize>popper[opSide]){data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide];}data.offsets.popper=getClientRect(data.offsets.popper);// compute center of the popper\nvar center=reference[side]+reference[len]/2-arrowElementSize/2;// Compute the sideValue using the updated popper offsets\n// take popper margin in account because we don't have this info available\nvar css=getStyleComputedProperty(data.instance.popper);var popperMarginSide=parseFloat(css['margin'+sideCapitalized],10);var popperBorderSide=parseFloat(css['border'+sideCapitalized+'Width'],10);var sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;// prevent arrowElement from being placed not contiguously to its popper\nsideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0);data.arrowElement=arrowElement;data.offsets.arrow=(_data$offsets$arrow={},defineProperty$1(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty$1(_data$offsets$arrow,altSide,''),_data$offsets$arrow);return data;}/**\n   * Get the opposite placement variation of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement variation\n   * @returns {String} flipped placement variation\n   */function getOppositeVariation(variation){if(variation==='end'){return'start';}else if(variation==='start'){return'end';}return variation;}/**\n   * List of accepted placements to use as values of the `placement` option.<br />\n   * Valid placements are:\n   * - `auto`\n   * - `top`\n   * - `right`\n   * - `bottom`\n   * - `left`\n   *\n   * Each placement can have a variation from this list:\n   * - `-start`\n   * - `-end`\n   *\n   * Variations are interpreted easily if you think of them as the left to right\n   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n   * is right.<br />\n   * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n   *\n   * Some valid examples are:\n   * - `top-end` (on top of reference, right aligned)\n   * - `right-start` (on right of reference, top aligned)\n   * - `bottom` (on bottom, centered)\n   * - `auto-end` (on the side with more space available, alignment depends by placement)\n   *\n   * @static\n   * @type {Array}\n   * @enum {String}\n   * @readonly\n   * @method placements\n   * @memberof Popper\n   */var placements=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'];// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements=placements.slice(3);/**\n   * Given an initial placement, returns all the subsequent placements\n   * clockwise (or counter-clockwise).\n   *\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement - A valid placement (it accepts variations)\n   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n   * @returns {Array} placements including their variations\n   */function clockwise(placement){var counter=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var index=validPlacements.indexOf(placement);var arr=validPlacements.slice(index+1).concat(validPlacements.slice(0,index));return counter?arr.reverse():arr;}var BEHAVIORS={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'};/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function flip(data,options){// if `inner` modifier is enabled, we can't use the `flip` modifier\nif(isModifierEnabled(data.instance.modifiers,'inner')){return data;}if(data.flipped&&data.placement===data.originalPlacement){// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\nreturn data;}var boundaries=getBoundaries(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed);var placement=data.placement.split('-')[0];var placementOpposite=getOppositePlacement(placement);var variation=data.placement.split('-')[1]||'';var flipOrder=[];switch(options.behavior){case BEHAVIORS.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS.CLOCKWISE:flipOrder=clockwise(placement);break;case BEHAVIORS.COUNTERCLOCKWISE:flipOrder=clockwise(placement,true);break;default:flipOrder=options.behavior;}flipOrder.forEach(function(step,index){if(placement!==step||flipOrder.length===index+1){return data;}placement=data.placement.split('-')[0];placementOpposite=getOppositePlacement(placement);var popperOffsets=data.offsets.popper;var refOffsets=data.offsets.reference;// using floor because the reference offsets may contain decimals we are not going to consider here\nvar floor=Math.floor;var overlapsRef=placement==='left'&&floor(popperOffsets.right)>floor(refOffsets.left)||placement==='right'&&floor(popperOffsets.left)<floor(refOffsets.right)||placement==='top'&&floor(popperOffsets.bottom)>floor(refOffsets.top)||placement==='bottom'&&floor(popperOffsets.top)<floor(refOffsets.bottom);var overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left);var overflowsRight=floor(popperOffsets.right)>floor(boundaries.right);var overflowsTop=floor(popperOffsets.top)<floor(boundaries.top);var overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom);var overflowsBoundaries=placement==='left'&&overflowsLeft||placement==='right'&&overflowsRight||placement==='top'&&overflowsTop||placement==='bottom'&&overflowsBottom;// flip the variation if required\nvar isVertical=['top','bottom'].indexOf(placement)!==-1;var flippedVariation=!!options.flipVariations&&(isVertical&&variation==='start'&&overflowsLeft||isVertical&&variation==='end'&&overflowsRight||!isVertical&&variation==='start'&&overflowsTop||!isVertical&&variation==='end'&&overflowsBottom);if(overlapsRef||overflowsBoundaries||flippedVariation){// this boolean to detect any flip loop\ndata.flipped=true;if(overlapsRef||overflowsBoundaries){placement=flipOrder[index+1];}if(flippedVariation){variation=getOppositeVariation(variation);}data.placement=placement+(variation?'-'+variation:'');// this object contains `position`, we want to preserve it along with\n// any additional property we may add in the future\ndata.offsets.popper=_extends({},data.offsets.popper,getPopperOffsets(data.instance.popper,data.offsets.reference,data.placement));data=runModifiers(data.instance.modifiers,data,'flip');}});return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function keepTogether(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var placement=data.placement.split('-')[0];var floor=Math.floor;var isVertical=['top','bottom'].indexOf(placement)!==-1;var side=isVertical?'right':'bottom';var opSide=isVertical?'left':'top';var measurement=isVertical?'width':'height';if(popper[side]<floor(reference[opSide])){data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement];}if(popper[opSide]>floor(reference[side])){data.offsets.popper[opSide]=floor(reference[side]);}return data;}/**\n   * Converts a string containing value + unit into a px value number\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} str - Value + unit string\n   * @argument {String} measurement - `height` or `width`\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @returns {Number|String}\n   * Value in pixels, or original string if no values were extracted\n   */function toValue(str,measurement,popperOffsets,referenceOffsets){// separate value from unit\nvar split=str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);var value=+split[1];var unit=split[2];// If it's not a number it's an operator, I guess\nif(!value){return str;}if(unit.indexOf('%')===0){var element=void 0;switch(unit){case'%p':element=popperOffsets;break;case'%':case'%r':default:element=referenceOffsets;}var rect=getClientRect(element);return rect[measurement]/100*value;}else if(unit==='vh'||unit==='vw'){// if is a vh or vw, we calculate the size based on the viewport\nvar size=void 0;if(unit==='vh'){size=Math.max(document.documentElement.clientHeight,window.innerHeight||0);}else{size=Math.max(document.documentElement.clientWidth,window.innerWidth||0);}return size/100*value;}else{// if is an explicit pixel unit, we get rid of the unit and keep the value\n// if is an implicit unit, it's px, and we return just the value\nreturn value;}}/**\n   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} offset\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @argument {String} basePlacement\n   * @returns {Array} a two cells array with x and y offsets in numbers\n   */function parseOffset(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0];// Use height if placement is left or right and index is 0 otherwise use width\n// in this way the first offset will use an axis and the second one\n// will use the other one\nvar useHeight=['right','left'].indexOf(basePlacement)!==-1;// Split the offset string to obtain a list of values and operands\n// The regex addresses values with the plus or minus sign in front (+10, -20, etc)\nvar fragments=offset.split(/(\\+|\\-)/).map(function(frag){return frag.trim();});// Detect if the offset string contains a pair of values or a single one\n// they could be separated by comma or space\nvar divider=fragments.indexOf(find(fragments,function(frag){return frag.search(/,|\\s/)!==-1;}));if(fragments[divider]&&fragments[divider].indexOf(',')===-1){console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');}// If divider is found, we divide the list of values and operands to divide\n// them by ofset X and Y.\nvar splitRegex=/\\s*,\\s*|\\s+/;var ops=divider!==-1?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];// Convert the values with units to absolute pixels to allow our computations\nops=ops.map(function(op,index){// Most of the units rely on the orientation of the popper\nvar measurement=(index===1?!useHeight:useHeight)?'height':'width';var mergeWithPrevious=false;return op// This aggregates any `+` or `-` sign that aren't considered operators\n// e.g.: 10 + +5 => [10, +, +5]\n.reduce(function(a,b){if(a[a.length-1]===''&&['+','-'].indexOf(b)!==-1){a[a.length-1]=b;mergeWithPrevious=true;return a;}else if(mergeWithPrevious){a[a.length-1]+=b;mergeWithPrevious=false;return a;}else{return a.concat(b);}},[])// Here we convert the string values into number values (in px)\n.map(function(str){return toValue(str,measurement,popperOffsets,referenceOffsets);});});// Loop trough the offsets arrays and execute the operations\nops.forEach(function(op,index){op.forEach(function(frag,index2){if(isNumeric(frag)){offsets[index]+=frag*(op[index2-1]==='-'?-1:1);}});});return offsets;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @argument {Number|String} options.offset=0\n   * The offset value as described in the modifier description\n   * @returns {Object} The data object, properly modified\n   */function offset$1(data,_ref){var offset=_ref.offset;var placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var basePlacement=placement.split('-')[0];var offsets=void 0;if(isNumeric(+offset)){offsets=[+offset,0];}else{offsets=parseOffset(offset,popper,reference,basePlacement);}if(basePlacement==='left'){popper.top+=offsets[0];popper.left-=offsets[1];}else if(basePlacement==='right'){popper.top+=offsets[0];popper.left+=offsets[1];}else if(basePlacement==='top'){popper.left+=offsets[0];popper.top-=offsets[1];}else if(basePlacement==='bottom'){popper.left+=offsets[0];popper.top+=offsets[1];}data.popper=popper;return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function preventOverflow(data,options){var boundariesElement=options.boundariesElement||getOffsetParent(data.instance.popper);// If offsetParent is the reference element, we really want to\n// go one step up and use the next offsetParent as reference to\n// avoid to make this modifier completely useless and look like broken\nif(data.instance.reference===boundariesElement){boundariesElement=getOffsetParent(boundariesElement);}// NOTE: DOM access here\n// resets the popper's position so that the document size can be calculated excluding\n// the size of the popper element itself\nvar transformProp=getSupportedPropertyName('transform');var popperStyles=data.instance.popper.style;// assignment to help minification\nvar top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top='';popperStyles.left='';popperStyles[transformProp]='';var boundaries=getBoundaries(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);// NOTE: DOM access here\n// restores the original style properties after the offsets have been computed\npopperStyles.top=top;popperStyles.left=left;popperStyles[transformProp]=transform;options.boundaries=boundaries;var order=options.priority;var popper=data.offsets.popper;var check={primary:function primary(placement){var value=popper[placement];if(popper[placement]<boundaries[placement]&&!options.escapeWithReference){value=Math.max(popper[placement],boundaries[placement]);}return defineProperty$1({},placement,value);},secondary:function secondary(placement){var mainSide=placement==='right'?'left':'top';var value=popper[mainSide];if(popper[placement]>boundaries[placement]&&!options.escapeWithReference){value=Math.min(popper[mainSide],boundaries[placement]-(placement==='right'?popper.width:popper.height));}return defineProperty$1({},mainSide,value);}};order.forEach(function(placement){var side=['left','top'].indexOf(placement)!==-1?'primary':'secondary';popper=_extends({},popper,check[side](placement));});data.offsets.popper=popper;return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function shift(data){var placement=data.placement;var basePlacement=placement.split('-')[0];var shiftvariation=placement.split('-')[1];// if shift shiftvariation is specified, run the modifier\nif(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper;var isVertical=['bottom','top'].indexOf(basePlacement)!==-1;var side=isVertical?'left':'top';var measurement=isVertical?'width':'height';var shiftOffsets={start:defineProperty$1({},side,reference[side]),end:defineProperty$1({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends({},popper,shiftOffsets[shiftvariation]);}return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function hide(data){if(!isModifierRequired(data.instance.modifiers,'hide','preventOverflow')){return data;}var refRect=data.offsets.reference;var bound=find(data.instance.modifiers,function(modifier){return modifier.name==='preventOverflow';}).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){// Avoid unnecessary DOM access if visibility hasn't changed\nif(data.hide===true){return data;}data.hide=true;data.attributes['x-out-of-boundaries']='';}else{// Avoid unnecessary DOM access if visibility hasn't changed\nif(data.hide===false){return data;}data.hide=false;data.attributes['x-out-of-boundaries']=false;}return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function inner(data){var placement=data.placement;var basePlacement=placement.split('-')[0];var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var isHoriz=['left','right'].indexOf(basePlacement)!==-1;var subtractLength=['top','left'].indexOf(basePlacement)===-1;popper[isHoriz?'left':'top']=reference[basePlacement]-(subtractLength?popper[isHoriz?'width':'height']:0);data.placement=getOppositePlacement(placement);data.offsets.popper=getClientRect(popper);return data;}/**\n   * Modifier function, each modifier can have a function of this type assigned\n   * to its `fn` property.<br />\n   * These functions will be called on each update, this means that you must\n   * make sure they are performant enough to avoid performance bottlenecks.\n   *\n   * @function ModifierFn\n   * @argument {dataObject} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {dataObject} The data object, properly modified\n   */ /**\n   * Modifiers are plugins used to alter the behavior of your poppers.<br />\n   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n   * needed by the library.\n   *\n   * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n   * All the other properties are configurations that could be tweaked.\n   * @namespace modifiers\n   */var modifiers={/**\n     * Modifier used to shift the popper on the start or end of its reference\n     * element.<br />\n     * It will read the variation of the `placement` property.<br />\n     * It can be one either `-end` or `-start`.\n     * @memberof modifiers\n     * @inner\n     */shift:{/** @prop {number} order=100 - Index used to define the order of execution */order:100,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:shift},/**\n     * The `offset` modifier can shift your popper on both its axis.\n     *\n     * It accepts the following units:\n     * - `px` or unit-less, interpreted as pixels\n     * - `%` or `%r`, percentage relative to the length of the reference element\n     * - `%p`, percentage relative to the length of the popper element\n     * - `vw`, CSS viewport width unit\n     * - `vh`, CSS viewport height unit\n     *\n     * For length is intended the main axis relative to the placement of the popper.<br />\n     * This means that if the placement is `top` or `bottom`, the length will be the\n     * `width`. In case of `left` or `right`, it will be the `height`.\n     *\n     * You can provide a single value (as `Number` or `String`), or a pair of values\n     * as `String` divided by a comma or one (or more) white spaces.<br />\n     * The latter is a deprecated method because it leads to confusion and will be\n     * removed in v2.<br />\n     * Additionally, it accepts additions and subtractions between different units.\n     * Note that multiplications and divisions aren't supported.\n     *\n     * Valid examples are:\n     * ```\n     * 10\n     * '10%'\n     * '10, 10'\n     * '10%, 10'\n     * '10 + 10%'\n     * '10 - 5vh + 3%'\n     * '-10px + 5vh, 5px - 6%'\n     * ```\n     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n     *\n     * @memberof modifiers\n     * @inner\n     */offset:{/** @prop {number} order=200 - Index used to define the order of execution */order:200,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:offset$1,/** @prop {Number|String} offset=0\n       * The offset value as described in the modifier description\n       */offset:0},/**\n     * Modifier used to prevent the popper from being positioned outside the boundary.\n     *\n     * A scenario exists where the reference itself is not within the boundaries.<br />\n     * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n     * In this case we need to decide whether the popper should either:\n     *\n     * - detach from the reference and remain \"trapped\" in the boundaries, or\n     * - if it should ignore the boundary and \"escape with its reference\"\n     *\n     * When `escapeWithReference` is set to`true` and reference is completely\n     * outside its boundaries, the popper will overflow (or completely leave)\n     * the boundaries in order to remain attached to the edge of the reference.\n     *\n     * @memberof modifiers\n     * @inner\n     */preventOverflow:{/** @prop {number} order=300 - Index used to define the order of execution */order:300,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:preventOverflow,/**\n       * @prop {Array} [priority=['left','right','top','bottom']]\n       * Popper will try to prevent overflow following these priorities by default,\n       * then, it could overflow on the left and on top of the `boundariesElement`\n       */priority:['left','right','top','bottom'],/**\n       * @prop {number} padding=5\n       * Amount of pixel used to define a minimum distance between the boundaries\n       * and the popper. This makes sure the popper always has a little padding\n       * between the edges of its container\n       */padding:5,/**\n       * @prop {String|HTMLElement} boundariesElement='scrollParent'\n       * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n       * `viewport` or any DOM element.\n       */boundariesElement:'scrollParent'},/**\n     * Modifier used to make sure the reference and its popper stay near each other\n     * without leaving any gap between the two. Especially useful when the arrow is\n     * enabled and you want to ensure that it points to its reference element.\n     * It cares only about the first axis. You can still have poppers with margin\n     * between the popper and its reference element.\n     * @memberof modifiers\n     * @inner\n     */keepTogether:{/** @prop {number} order=400 - Index used to define the order of execution */order:400,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:keepTogether},/**\n     * This modifier is used to move the `arrowElement` of the popper to make\n     * sure it is positioned between the reference element and its popper element.\n     * It will read the outer size of the `arrowElement` node to detect how many\n     * pixels of conjunction are needed.\n     *\n     * It has no effect if no `arrowElement` is provided.\n     * @memberof modifiers\n     * @inner\n     */arrow:{/** @prop {number} order=500 - Index used to define the order of execution */order:500,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:arrow,/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */element:'[x-arrow]'},/**\n     * Modifier used to flip the popper's placement when it starts to overlap its\n     * reference element.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     *\n     * **NOTE:** this modifier will interrupt the current update cycle and will\n     * restart it if it detects the need to flip the placement.\n     * @memberof modifiers\n     * @inner\n     */flip:{/** @prop {number} order=600 - Index used to define the order of execution */order:600,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:flip,/**\n       * @prop {String|Array} behavior='flip'\n       * The behavior used to change the popper's placement. It can be one of\n       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n       * placements (with optional variations)\n       */behavior:'flip',/**\n       * @prop {number} padding=5\n       * The popper will flip if it hits the edges of the `boundariesElement`\n       */padding:5,/**\n       * @prop {String|HTMLElement} boundariesElement='viewport'\n       * The element which will define the boundaries of the popper position.\n       * The popper will never be placed outside of the defined boundaries\n       * (except if `keepTogether` is enabled)\n       */boundariesElement:'viewport'},/**\n     * Modifier used to make the popper flow toward the inner of the reference element.\n     * By default, when this modifier is disabled, the popper will be placed outside\n     * the reference element.\n     * @memberof modifiers\n     * @inner\n     */inner:{/** @prop {number} order=700 - Index used to define the order of execution */order:700,/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */enabled:false,/** @prop {ModifierFn} */fn:inner},/**\n     * Modifier used to hide the popper when its reference element is outside of the\n     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n     * be used to hide with a CSS selector the popper when its reference is\n     * out of boundaries.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     * @memberof modifiers\n     * @inner\n     */hide:{/** @prop {number} order=800 - Index used to define the order of execution */order:800,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:hide},/**\n     * Computes the style that will be applied to the popper element to gets\n     * properly positioned.\n     *\n     * Note that this modifier will not touch the DOM, it just prepares the styles\n     * so that `applyStyle` modifier can apply it. This separation is useful\n     * in case you need to replace `applyStyle` with a custom implementation.\n     *\n     * This modifier has `850` as `order` value to maintain backward compatibility\n     * with previous versions of Popper.js. Expect the modifiers ordering method\n     * to change in future major versions of the library.\n     *\n     * @memberof modifiers\n     * @inner\n     */computeStyle:{/** @prop {number} order=850 - Index used to define the order of execution */order:850,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:computeStyle,/**\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */gpuAcceleration:true,/**\n       * @prop {string} [x='bottom']\n       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n       * Change this if your popper should grow in a direction different from `bottom`\n       */x:'bottom',/**\n       * @prop {string} [x='left']\n       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n       * Change this if your popper should grow in a direction different from `right`\n       */y:'right'},/**\n     * Applies the computed styles to the popper element.\n     *\n     * All the DOM manipulations are limited to this modifier. This is useful in case\n     * you want to integrate Popper.js inside a framework or view library and you\n     * want to delegate all the DOM manipulations to it.\n     *\n     * Note that if you disable this modifier, you must make sure the popper element\n     * has its position set to `absolute` before Popper.js can do its work!\n     *\n     * Just disable this modifier and define your own to achieve the desired effect.\n     *\n     * @memberof modifiers\n     * @inner\n     */applyStyle:{/** @prop {number} order=900 - Index used to define the order of execution */order:900,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:applyStyle,/** @prop {Function} */onLoad:applyStyleOnLoad,/**\n       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */gpuAcceleration:undefined}};/**\n   * The `dataObject` is an object containing all the information used by Popper.js.\n   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n   * @name dataObject\n   * @property {Object} data.instance The Popper.js instance\n   * @property {String} data.placement Placement applied to popper\n   * @property {String} data.originalPlacement Placement originally defined on init\n   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.boundaries Offsets of the popper boundaries\n   * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n   */ /**\n   * Default options provided to Popper.js constructor.<br />\n   * These can be overridden using the `options` argument of Popper.js.<br />\n   * To override an option, simply pass an object with the same\n   * structure of the `options` object, as the 3rd argument. For example:\n   * ```\n   * new Popper(ref, pop, {\n   *   modifiers: {\n   *     preventOverflow: { enabled: false }\n   *   }\n   * })\n   * ```\n   * @type {Object}\n   * @static\n   * @memberof Popper\n   */var Defaults={/**\n     * Popper's placement.\n     * @prop {Popper.placements} placement='bottom'\n     */placement:'bottom',/**\n     * Set this to true if you want popper to position it self in 'fixed' mode\n     * @prop {Boolean} positionFixed=false\n     */positionFixed:false,/**\n     * Whether events (resize, scroll) are initially enabled.\n     * @prop {Boolean} eventsEnabled=true\n     */eventsEnabled:true,/**\n     * Set to true if you want to automatically remove the popper when\n     * you call the `destroy` method.\n     * @prop {Boolean} removeOnDestroy=false\n     */removeOnDestroy:false,/**\n     * Callback called when the popper is created.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onCreate}\n     */onCreate:function onCreate(){},/**\n     * Callback called when the popper is updated. This callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onUpdate}\n     */onUpdate:function onUpdate(){},/**\n     * List of modifiers used to modify the offsets before they are applied to the popper.\n     * They provide most of the functionalities of Popper.js.\n     * @prop {modifiers}\n     */modifiers:modifiers};/**\n   * @callback onCreate\n   * @param {dataObject} data\n   */ /**\n   * @callback onUpdate\n   * @param {dataObject} data\n   */ // Utils\n// Methods\nvar Popper=function(){/**\n     * Creates a new Popper.js instance.\n     * @class Popper\n     * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n     * @param {HTMLElement} popper - The HTML element used as the popper\n     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n     * @return {Object} instance - The generated Popper.js instance\n     */function Popper(reference,popper){var _this=this;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};classCallCheck(this,Popper);this.scheduleUpdate=function(){return requestAnimationFrame(_this.update);};// make update() debounced, so that it only runs at most once-per-tick\nthis.update=debounce(this.update.bind(this));// with {} we create a new object with the options inside it\nthis.options=_extends({},Popper.Defaults,options);// init state\nthis.state={isDestroyed:false,isCreated:false,scrollParents:[]};// get reference and popper elements (allow jQuery wrappers)\nthis.reference=reference&&reference.jquery?reference[0]:reference;this.popper=popper&&popper.jquery?popper[0]:popper;// Deep merge modifiers options\nthis.options.modifiers={};Object.keys(_extends({},Popper.Defaults.modifiers,options.modifiers)).forEach(function(name){_this.options.modifiers[name]=_extends({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{});});// Refactoring modifiers' list (Object => Array)\nthis.modifiers=Object.keys(this.options.modifiers).map(function(name){return _extends({name:name},_this.options.modifiers[name]);})// sort the modifiers by order\n.sort(function(a,b){return a.order-b.order;});// modifiers have the ability to execute arbitrary code when Popper.js get inited\n// such code is executed in the same order of its modifier\n// they could add new properties to their options configuration\n// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\nthis.modifiers.forEach(function(modifierOptions){if(modifierOptions.enabled&&isFunction(modifierOptions.onLoad)){modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state);}});// fire the first update to position the popper in the right place\nthis.update();var eventsEnabled=this.options.eventsEnabled;if(eventsEnabled){// setup event listeners, they will take care of update the position in specific situations\nthis.enableEventListeners();}this.state.eventsEnabled=eventsEnabled;}// We can't use class properties because they don't get listed in the\n// class prototype and break stuff like Sinon stubs\ncreateClass(Popper,[{key:'update',value:function update$$1(){return update.call(this);}},{key:'destroy',value:function destroy$$1(){return destroy.call(this);}},{key:'enableEventListeners',value:function enableEventListeners$$1(){return enableEventListeners.call(this);}},{key:'disableEventListeners',value:function disableEventListeners$$1(){return disableEventListeners.call(this);}/**\n       * Schedules an update. It will run on the next UI update available.\n       * @method scheduleUpdate\n       * @memberof Popper\n       */ /**\n       * Collection of utilities useful when writing custom modifiers.\n       * Starting from version 1.7, this method is available only if you\n       * include `popper-utils.js` before `popper.js`.\n       *\n       * **DEPRECATION**: This way to access PopperUtils is deprecated\n       * and will be removed in v2! Use the PopperUtils module directly instead.\n       * Due to the high instability of the methods contained in Utils, we can't\n       * guarantee them to follow semver. Use them at your own risk!\n       * @static\n       * @private\n       * @type {Object}\n       * @deprecated since version 1.8\n       * @member Utils\n       * @memberof Popper\n       */}]);return Popper;}();/**\n   * The `referenceObject` is an object that provides an interface compatible with Popper.js\n   * and lets you use it as replacement of a real DOM node.<br />\n   * You can use this method to position a popper relatively to a set of coordinates\n   * in case you don't have a DOM node to use as reference.\n   *\n   * ```\n   * new Popper(referenceObject, popperNode);\n   * ```\n   *\n   * NB: This feature isn't supported in Internet Explorer 10.\n   * @name referenceObject\n   * @property {Function} data.getBoundingClientRect\n   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n   * @property {number} data.clientWidth\n   * An ES6 getter that will return the width of the virtual reference element.\n   * @property {number} data.clientHeight\n   * An ES6 getter that will return the height of the virtual reference element.\n   */Popper.Utils=(typeof window!=='undefined'?window:global).PopperUtils;Popper.placements=placements;Popper.Defaults=Defaults;var clickOutMixin={data:function data(){return{listenForClickOut:false};},watch:{listenForClickOut:function listenForClickOut(newValue,oldValue){if(newValue!==oldValue){eventOff(this.clickOutElement,this.clickOutEventName,this._clickOutHandler,false);if(newValue){eventOn(this.clickOutElement,this.clickOutEventName,this._clickOutHandler,false);}}}},beforeCreate:function beforeCreate(){// Declare non-reactive properties\nthis.clickOutElement=null;this.clickOutEventName=null;},mounted:function mounted(){if(!this.clickOutElement){this.clickOutElement=document;}if(!this.clickOutEventName){this.clickOutEventName='ontouchstart'in document.documentElement?'touchstart':'click';}if(this.listenForClickOut){eventOn(this.clickOutElement,this.clickOutEventName,this._clickOutHandler,false);}},beforeDestroy:function beforeDestroy()/* istanbul ignore next */{eventOff(this.clickOutElement,this.clickOutEventName,this._clickOutHandler,false);},methods:{isClickOut:function isClickOut(evt){return!contains(this.$el,evt.target);},_clickOutHandler:function _clickOutHandler(evt){if(this.clickOutHandler&&this.isClickOut(evt)){this.clickOutHandler(evt);}}}};var focusInMixin={data:function data(){return{listenForFocusIn:false};},watch:{listenForFocusIn:function listenForFocusIn(newValue,oldValue){if(newValue!==oldValue){eventOff(this.focusInElement,'focusin',this._focusInHandler,false);if(newValue){eventOn(this.focusInElement,'focusin',this._focusInHandler,false);}}}},beforeCreate:function beforeCreate(){// Declare non-reactive properties\nthis.focusInElement=null;},mounted:function mounted(){if(!this.focusInElement){this.focusInElement=document;}if(this.listenForFocusIn){eventOn(this.focusInElement,'focusin',this._focusInHandler,false);}},beforeDestroy:function beforeDestroy()/* istanbul ignore next */{eventOff(this.focusInElement,'focusin',this._focusInHandler,false);},methods:{_focusInHandler:function _focusInHandler(evt){if(this.focusInHandler){this.focusInHandler(evt);}}}};var BvEvent=/*#__PURE__*/function(){function BvEvent(type){var eventInit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,BvEvent);// Start by emulating native Event constructor.\nif(!type){/* istanbul ignore next */throw new TypeError(\"Failed to construct '\".concat(this.constructor.name,\"'. 1 argument required, \").concat(arguments.length,\" given.\"));}// Assign defaults first, the eventInit,\n// and the type last so it can't be overwritten.\nassign(this,BvEvent.defaults(),eventInit,{type:type});// Freeze some props as readonly, but leave them enumerable.\ndefineProperties(this,{type:readonlyDescriptor(),cancelable:readonlyDescriptor(),nativeEvent:readonlyDescriptor(),target:readonlyDescriptor(),relatedTarget:readonlyDescriptor(),vueTarget:readonlyDescriptor()});// Create a private variable using closure scoping.\nvar defaultPrevented=false;// Recreate preventDefault method. One way setter.\nthis.preventDefault=function preventDefault(){if(this.cancelable){defaultPrevented=true;}};// Create 'defaultPrevented' publicly accessible prop\n// that can only be altered by the preventDefault method.\ndefineProperty(this,'defaultPrevented',{enumerable:true,get:function get(){return defaultPrevented;}});}_createClass(BvEvent,null,[{key:\"defaults\",value:function defaults(){return{type:'',cancelable:true,nativeEvent:null,target:null,relatedTarget:null,vueTarget:null};}}]);return BvEvent;}();/**\n   * Log a warning message to the console with bootstrap-vue formatting sugar.\n   * @param {string} message\n   */ /* istanbul ignore next */var warn=function warn(message){console.warn(\"[BootstrapVue warn]: \".concat(message));};function filterVisible(els){return(els||[]).filter(isVisible);}// Dropdown item CSS selectors\n// TODO: .dropdown-form handling\nvar Selector={FORM_CHILD:'.dropdown form',NAVBAR_NAV:'.navbar-nav',ITEM_SELECTOR:'.dropdown-item:not(.disabled):not([disabled])'// Popper attachment positions\n};var AttachmentMap={// Dropup left align\nTOP:'top-start',// Dropup right align\nTOPEND:'top-end',// Dropdown left align\nBOTTOM:'bottom-start',// Dropdown right align\nBOTTOMEND:'bottom-end',// Dropright left align\nRIGHT:'right-start',// Dropright right align\nRIGHTEND:'right-end',// Dropleft left align\nLEFT:'left-start',// Dropleft right align\nLEFTEND:'left-end'// @vue/component\n};var dropdownMixin={mixins:[clickOutMixin,focusInMixin],provide:function provide(){return{bvDropdown:this};},props:{disabled:{type:Boolean,default:false},text:{// Button label\ntype:String,default:''},html:{// Button label\ntype:String},dropup:{// place on top if possible\ntype:Boolean,default:false},dropright:{// place right if possible\ntype:Boolean,default:false},dropleft:{// place left if possible\ntype:Boolean,default:false},right:{// Right align menu (default is left align)\ntype:Boolean,default:false},offset:{// Number of pixels to offset menu, or a CSS unit value (i.e. 1px, 1rem, etc)\ntype:[Number,String],default:0},noFlip:{// Disable auto-flipping of menu from bottom<=>top\ntype:Boolean,default:false},popperOpts:{// type: Object,\ndefault:function _default(){}}},data:function data(){return{visible:false,inNavbar:null,visibleChangePrevented:false};},computed:{toggler:function toggler(){var toggle=this.$refs.toggle;return toggle?toggle.$el||toggle:null;}},watch:{visible:function visible(newValue,oldValue){if(this.visibleChangePrevented){this.visibleChangePrevented=false;return;}if(newValue!==oldValue){var evtName=newValue?'show':'hide';var bvEvt=new BvEvent(evtName,{cancelable:true,vueTarget:this,target:this.$refs.menu,relatedTarget:null});this.emitEvent(bvEvt);if(bvEvt.defaultPrevented){// Reset value and exit if canceled\nthis.visibleChangePrevented=true;this.visible=oldValue;// Just in case a child element triggereded this.hide(true)\nthis.$off('hidden',this.focusToggler);return;}if(evtName==='show'){this.showMenu();}else{this.hideMenu();}}},disabled:function disabled(newValue,oldValue){if(newValue!==oldValue&&newValue&&this.visible){// Hide dropdown if disabled changes to true\nthis.visible=false;}}},created:function created(){// Create non-reactive property\nthis._popper=null;},deactivated:function deactivated()/* istanbul ignore next: not easy to test */{// In case we are inside a `<keep-alive>`\nthis.visible=false;this.whileOpenListen(false);this.removePopper();},beforeDestroy:function beforeDestroy()/* istanbul ignore next: not easy to test */{this.visible=false;this.whileOpenListen(false);this.removePopper();},methods:{// Event emitter\nemitEvent:function emitEvent(bvEvt){var type=bvEvt.type;this.$emit(type,bvEvt);this.$root.$emit(\"bv::dropdown::\".concat(type),bvEvt);},showMenu:function showMenu(){var _this=this;if(this.disabled){return;}// Ensure other menus are closed\nthis.$root.$emit('bv::dropdown::shown',this);// Are we in a navbar ?\nif(this.inNavbar===null&&this.isNav){this.inNavbar=Boolean(closest('.navbar',this.$el));}// Disable totally Popper.js for Dropdown in Navbar\n/* istanbul ignore next: cant test popper in JSDOM */if(!this.inNavbar){if(typeof Popper==='undefined'){warn('b-dropdown: Popper.js not found. Falling back to CSS positioning.');}else{// for dropup with alignment we use the parent element as popper container\nvar element=this.dropup&&this.right||this.split?this.$el:this.$refs.toggle;// Make sure we have a reference to an element, not a component!\nelement=element.$el||element;// Instantiate popper.js\nthis.createPopper(element);}}this.whileOpenListen(true);// Wrap in nextTick to ensure menu is fully rendered/shown\nthis.$nextTick(function(){// Focus on the menu container on show\n_this.focusMenu();// Emit the shown event\n_this.$emit('shown');});},hideMenu:function hideMenu(){this.whileOpenListen(false);this.$root.$emit('bv::dropdown::hidden',this);this.$emit('hidden');this.removePopper();},createPopper:function createPopper(element)/* istanbul ignore next: cant test popper in JSDOM */{this.removePopper();this._popper=new Popper(element,this.$refs.menu,this.getPopperConfig());},removePopper:function removePopper()/* istanbul ignore next: cant test popper in JSDOM */{if(this._popper){// Ensure popper event listeners are removed cleanly\nthis._popper.destroy();}this._popper=null;},getPopperConfig:function getPopperConfig()/* istanbul ignore next: can't test popper in JSDOM */{var placement=AttachmentMap.BOTTOM;if(this.dropup){placement=this.right?AttachmentMap.TOPEND:AttachmentMap.TOP;}else if(this.dropright){placement=AttachmentMap.RIGHT;}else if(this.dropleft){placement=AttachmentMap.LEFT;}else if(this.right){placement=AttachmentMap.BOTTOMEND;}var popperConfig={placement:placement,modifiers:{offset:{offset:this.offset||0},flip:{enabled:!this.noFlip}}};if(this.boundary){popperConfig.modifiers.preventOverflow={boundariesElement:this.boundary};}return _objectSpread({},popperConfig,this.popperOpts||{});},whileOpenListen:function whileOpenListen(open){// turn listeners on/off while open\nif(open){// If another dropdown is opened\nthis.$root.$on('bv::dropdown::shown',this.rootCloseListener);// Hide the dropdown when clicked outside\nthis.listenForClickOut=true;// Hide the dropdown when it loses focus\nthis.listenForFocusIn=true;}else{this.$root.$off('bv::dropdown::shown',this.rootCloseListener);this.listenForClickOut=false;this.listenForFocusIn=false;}},rootCloseListener:function rootCloseListener(vm){if(vm!==this){this.visible=false;}},show:function show(){// Public method to show dropdown\nif(this.disabled){return;}this.visible=true;},hide:function hide(){var refocus=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;// Public method to hide dropdown\nif(this.disabled){return;}this.visible=false;if(refocus){// Child element is closing the dropdown on click\nthis.$once('hidden',this.focusToggler);}},toggle:function toggle(evt){// Called only by a button that toggles the menu\nevt=evt||{};var type=evt.type;var key=evt.keyCode;if(type!=='click'&&!(type==='keydown'&&(key===KEY_CODES.ENTER||key===KEY_CODES.SPACE||key===KEY_CODES.DOWN))){// We only toggle on Click, Enter, Space, and Arrow Down\nreturn;}if(this.disabled){this.visible=false;return;}this.$emit('toggle',evt);if(evt.defaultPrevented){// Exit if canceled\nreturn;}evt.preventDefault();evt.stopPropagation();// Toggle visibility\nthis.visible=!this.visible;},click:function click(evt){// Called only in split button mode, for the split button\nif(this.disabled){this.visible=false;return;}this.$emit('click',evt);},onKeydown:function onKeydown(evt)/* istanbul ignore next: not easy to test */{// Called from dropdown menu context\nvar key=evt.keyCode;if(key===KEY_CODES.ESC){// Close on ESC\nthis.onEsc(evt);}else if(key===KEY_CODES.TAB){// Close on tab out\nthis.onTab(evt);}else if(key===KEY_CODES.DOWN){// Down Arrow\nthis.focusNext(evt,false);}else if(key===KEY_CODES.UP){// Up Arrow\nthis.focusNext(evt,true);}},onEsc:function onEsc(evt)/* istanbul ignore next: not easy to test */{if(this.visible){this.visible=false;evt.preventDefault();evt.stopPropagation();// Return focus to original trigger button\nthis.$once('hidden',this.focusToggler);}},onTab:function onTab(evt)/* istanbul ignore next: not easy to test */{// TODO: Need special handler for dealing with form inputs\n// Tab, if in a text-like input, we should just focus next item in the dropdown\n// Note: Inputs are in a special .dropdown-form container\n},onMouseOver:function onMouseOver(evt)/* istanbul ignore next: not easy to test */{// Removed mouseover focus handler\n},// Document click out listener\nclickOutHandler:function clickOutHandler(){if(this.visible){this.visible=false;}},// Document focusin listener\nfocusInHandler:function focusInHandler(evt){// If focus leaves dropdown, hide it\nif(this.visible&&!contains(this.$refs.menu,evt.target)&&!contains(this.$refs.toggle,evt.target)){this.visible=false;}},// Keyboard nav\nfocusNext:function focusNext(evt,up){var _this2=this;if(!this.visible){return;}evt.preventDefault();evt.stopPropagation();this.$nextTick(function(){var items=_this2.getItems();if(items.length<1){return;}var index=items.indexOf(evt.target);if(up&&index>0){index--;}else if(!up&&index<items.length-1){index++;}if(index<0){index=0;}_this2.focusItem(index,items);});},focusItem:function focusItem(idx,items){var el=items.find(function(el,i){return i===idx;});if(el&&getAttr(el,'tabindex')!=='-1'){el.focus();}},getItems:function getItems(){// Get all items\nreturn filterVisible(selectAll(Selector.ITEM_SELECTOR,this.$refs.menu));},focusMenu:function focusMenu(){this.$refs.menu.focus&&this.$refs.menu.focus();},focusToggler:function focusToggler(){var toggler=this.toggler;if(toggler&&toggler.focus){toggler.focus();}}}};var BDropdown={name:'BDropdown',components:{BButton:BButton},mixins:[idMixin,dropdownMixin],props:{toggleText:{type:String,default:'Toggle Dropdown'},size:{type:String,default:null},variant:{type:String,default:null},menuClass:{type:[String,Array],default:null},toggleTag:{type:String,default:'button'},toggleClass:{type:[String,Array],default:null},noCaret:{type:Boolean,default:false},split:{type:Boolean,default:false},splitHref:{type:String// default: undefined\n},splitTo:{type:[String,Object]// default: undefined\n},splitVariant:{type:String,default:null},role:{type:String,default:'menu'},boundary:{// String: `scrollParent`, `window` or `viewport`\n// Object: HTML Element reference\ntype:[String,Object],default:'scrollParent'}},computed:{dropdownClasses:function dropdownClasses(){// Position `static` is needed to allow menu to \"breakout\" of the scrollParent boundaries\n// when boundary is anything other than `scrollParent`\n// See https://github.com/twbs/bootstrap/issues/24251#issuecomment-341413786\nvar positionStatic=this.boundary!=='scrollParent'||!this.boundary;var direction='';if(this.dropup){direction='dropup';}else if(this.dropright){direction='dropright';}else if(this.dropleft){direction='dropleft';}return['btn-group','b-dropdown','dropdown',direction,{show:this.visible,'position-static':positionStatic}];},menuClasses:function menuClasses(){return['dropdown-menu',{'dropdown-menu-right':this.right,show:this.visible},this.menuClass];},toggleClasses:function toggleClasses(){return['dropdown-toggle',{'dropdown-toggle-split':this.split,'dropdown-toggle-no-caret':this.noCaret&&!this.split},this.toggleClass];}},render:function render(h){var split=h(false);if(this.split){var btnProps={disabled:this.disabled,variant:this.splitVariant||this.variant,size:this.size// We add these as needed due to router-link issues with defined property with undefined/null values\n};if(this.splitTo){btnProps.to=this.splitTo;}if(this.splitHref){btnProps.href=this.splitHref;}split=h('b-button',{ref:'button',props:btnProps,attrs:{id:this.safeId('_BV_button_')},on:{click:this.click}},[this.$slots['button-content']||this.$slots.text||this.html||stripTags(this.text)]);}var toggle=h('b-button',{ref:'toggle',class:this.toggleClasses,props:{variant:this.variant,size:this.size,disabled:this.disabled,tag:this.toggleTag},attrs:{id:this.safeId('_BV_toggle_'),'aria-haspopup':'true','aria-expanded':this.visible?'true':'false'},on:{click:this.toggle,// click\nkeydown:this.toggle// enter, space, down\n}},[this.split?h('span',{class:['sr-only']},[this.toggleText]):this.$slots['button-content']||this.$slots.text||this.html||stripTags(this.text)]);var menu=h('div',{ref:'menu',class:this.menuClasses,attrs:{role:this.role,tabindex:'-1','aria-labelledby':this.safeId(this.split?'_BV_button_':'_BV_toggle_')},on:{mouseover:this.onMouseOver,keydown:this.onKeydown// tab, up, down, esc\n}},[this.$slots.default]);return h('div',{attrs:{id:this.safeId()},class:this.dropdownClasses},[split,toggle,menu]);}};var props$n=propsFactory();// @vue/component\nvar BDropdownItem={name:'BDropdownItem',inject:{bvDropdown:{default:null}},props:props$n,methods:{closeDropdown:function closeDropdown(){if(this.bvDropdown){this.bvDropdown.hide(true);}},onClick:function onClick(evt){this.$emit('click',evt);this.closeDropdown();}},render:function render(h){return h(BLink,{props:this.$props,staticClass:'dropdown-item',attrs:{role:'menuitem'},on:{click:this.onClick}},this.$slots.default);}};var props$o={active:{type:Boolean,default:false},activeClass:{type:String,default:'active'},disabled:{type:Boolean,default:false// @vue/component\n}};var BDropdownItemButton={name:'BDropdownItemButton',inject:{bvDropdown:{default:null}},props:props$o,methods:{closeDropdown:function closeDropdown(){if(this.bvDropdown){this.bvDropdown.hide(true);}},onClick:function onClick(evt){this.$emit('click',evt);this.closeDropdown();}},render:function render(h){return h('button',{staticClass:'dropdown-item',class:_defineProperty({},this.activeClass,this.active),attrs:{role:'menuitem',type:'button',disabled:this.disabled},on:{click:this.onClick}},this.$slots.default);}};var props$p={id:{type:String,default:null},tag:{type:String,default:'h6'// @vue/component\n}};var BDropdownHeader={name:'BDropdownHeader',functional:true,props:props$p,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{staticClass:'dropdown-header',attrs:{id:props.id||null}}),children);}};var props$q={tag:{type:String,default:'div'// @vue/component\n}};var BDropdownDivider={name:'BDropdownDivider',functional:true,props:props$q,render:function render(h,_ref){var props=_ref.props,data=_ref.data;return h(props.tag,mergeData(data,{staticClass:'dropdown-divider',attrs:{role:'separator'}}));}};var props$r={id:{type:String,default:null},inline:{type:Boolean,default:false},novalidate:{type:Boolean,default:false},validated:{type:Boolean,default:false// @vue/component\n}};var BForm={name:'BForm',functional:true,props:props$r,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h('form',mergeData(data,{class:{'form-inline':props.inline,'was-validated':props.validated},attrs:{id:props.id,novalidate:props.novalidate}}),children);}};var BDropdownForm={name:'BDropdownForm',functional:true,props:_objectSpread({},props$r),render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(BForm,mergeData(data,{props:props,staticClass:'b-dropdown-form'}),children);}};var BDropdownText={name:'BDropdownText',functional:true,props:{tag:{type:String,default:'p'}},render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{props:props,staticClass:'b-dropdown-text'}),children);}};var components$b={BDropdown:BDropdown,BDd:BDropdown,BDropdownItem:BDropdownItem,BDdItem:BDropdownItem,BDropdownItemButton:BDropdownItemButton,BDropdownItemBtn:BDropdownItemButton,BDdItemButton:BDropdownItemButton,BDdItemBtn:BDropdownItemButton,BDropdownHeader:BDropdownHeader,BDdHeader:BDropdownHeader,BDropdownDivider:BDropdownDivider,BDdDivider:BDropdownDivider,BDropdownForm:BDropdownForm,BDdForm:BDropdownForm,BDropdownText:BDropdownText,BDdText:BDropdownText};var dropdownPlugin={install:function install(Vue){registerComponents(Vue,components$b);}};var props$s={type:{type:String,default:'iframe',validator:function validator(str){return arrayIncludes(['iframe','embed','video','object','img','b-img','b-img-lazy'],str);}},tag:{type:String,default:'div'},aspect:{type:String,default:'16by9'// @vue/component\n}};var BEmbed={name:'BEmbed',functional:true,props:props$s,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,{ref:data.ref,staticClass:'embed-responsive',class:_defineProperty({},\"embed-responsive-\".concat(props.aspect),Boolean(props.aspect))},[h(props.type,mergeData(data,{ref:'',staticClass:'embed-responsive-item'}),children)]);}};var components$c={BEmbed:BEmbed};var index$a={install:function install(Vue){registerComponents(Vue,components$c);}};var props$t={id:{type:String,default:null},tag:{type:String,default:'small'},textVariant:{type:String,default:'muted'},inline:{type:Boolean,default:false// @vue/component\n}};var BFormText={name:'BFormText',functional:true,props:props$t,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{class:_defineProperty({'form-text':!props.inline},\"text-\".concat(props.textVariant),Boolean(props.textVariant)),attrs:{id:props.id}}),children);}};var props$u={id:{type:String,default:null},tag:{type:String,default:'div'},tooltip:{type:Boolean,default:false},forceShow:{type:Boolean,default:false},state:{type:[Boolean,String],default:null// @vue/component\n}};var BFormInvalidFeedback={name:'BFormInvalidFeedback',functional:true,props:props$u,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var show=props.forceShow===true||props.state===false||props.state==='invalid';return h(props.tag,mergeData(data,{class:{'invalid-feedback':!props.tooltip,'invalid-tooltip':props.tooltip,'d-block':show},attrs:{id:props.id}}),children);}};var props$v={id:{type:String,default:null},tag:{type:String,default:'div'},tooltip:{type:Boolean,default:false},forceShow:{type:Boolean,default:false},state:{type:[Boolean,String],default:null// @vue/component\n}};var BFormValidFeedback={name:'BFormValidFeedback',functional:true,props:props$v,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var show=props.forceShow===true||props.state===true||props.state==='valid';return h(props.tag,mergeData(data,{class:{'valid-feedback':!props.tooltip,'valid-tooltip':props.tooltip,'d-block':show},attrs:{id:props.id}}),children);}};var components$d={BForm:BForm,BFormRow:BFormRow,BFormText:BFormText,BFormInvalidFeedback:BFormInvalidFeedback,BFormFeedback:BFormInvalidFeedback,BFormValidFeedback:BFormValidFeedback};var index$b={install:function install(Vue){registerComponents(Vue,components$d);}};/* Form control contextual state class computation\n   *\n   * Returned class is either 'is-valid' or 'is-invalid' based on the 'state' prop\n   * state can be one of five values:\n   *  - true or 'valid' for is-valid\n   *  - false or 'invalid' for is-invalid\n   *  - null (or empty string) for no contextual state\n   */ // @vue/component\nvar formStateMixin={props:{state:{// true/'valid', false/'invalid', '',null\n// The order must be String first, then Boolean!\ntype:[String,Boolean],default:null}},computed:{computedState:function computedState(){var state=this.state;if(state===''){return null;}else if(state===true||state==='valid'){return true;}else if(state===false||state==='invalid'){return false;}return null;},stateClass:function stateClass(){var state=this.computedState;if(state===true){return'is-valid';}else if(state===false){return'is-invalid';}return null;}}};var SELECTOR='input:not(:disabled),textarea:not(:disabled),select:not(:disabled)';// Breakpoint names for label-cols and label-align props\nvar BREAKPOINTS$1=['','sm','md','lg','xl'];// Memoize this function to return cached values to save time in computed functions\nvar makePropName=memoize(function(){var breakpoint=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';var prefix=arguments.length>1?arguments[1]:undefined;return\"\".concat(prefix).concat(upperFirst(breakpoint));});// Generate the labelCol breakpoint props\nvar bpLabelColProps=BREAKPOINTS$1.reduce(function(props,breakpoint){// label-cols, label-cols-sm, label-cols-md, ...\nprops[makePropName(breakpoint,'labelCols')]={type:[Number,String,Boolean],default:breakpoint?false:null};return props;},create(null));// Generate the labelAlign breakpoint props\nvar bpLabelAlignProps=BREAKPOINTS$1.reduce(function(props,breakpoint){// label-align, label-align-sm, label-align-md, ...\nprops[makePropName(breakpoint,'labelAlign')]={type:String,// left, right, center\ndefault:null};return props;},create(null));// render helper functions (here rather than polluting the instance with more methods)\nfunction renderInvalidFeedback(h,ctx){var content=ctx.$slots['invalid-feedback']||ctx.invalidFeedback;var invalidFeedback=h(false);if(content){invalidFeedback=h('b-form-invalid-feedback',{props:{id:ctx.invalidFeedbackId,// If state is explicitly false, always show the feedback\nstate:ctx.computedState,tooltip:ctx.tooltip},attrs:{tabindex:content?'-1':null,role:'alert','aria-live':'assertive','aria-atomic':'true'}},[content]);}return invalidFeedback;}function renderValidFeedback(h,ctx){var content=ctx.$slots['valid-feedback']||ctx.validFeedback;var validFeedback=h(false);if(content){validFeedback=h('b-form-valid-feedback',{props:{id:ctx.validFeedbackId,// If state is explicitly true, always show the feedback\nstate:ctx.computedState,tooltip:ctx.tooltip},attrs:{tabindex:'-1',role:'alert','aria-live':'assertive','aria-atomic':'true'}},[content]);}return validFeedback;}function renderHelpText(h,ctx){// Form help text (description)\nvar content=ctx.$slots['description']||ctx.description;var description=h(false);if(content){description=h('b-form-text',{attrs:{id:ctx.descriptionId,tabindex:'-1'}},[content]);}return description;}function renderLabel(h,ctx){// render label/legend inside b-col if necessary\nvar content=ctx.$slots['label']||ctx.label;var labelFor=ctx.labelFor;var isLegend=!labelFor;var isHorizontal=ctx.isHorizontal;var labelTag=isLegend?'legend':'label';if(!content&&!isHorizontal){return h(false);}else if(ctx.labelSrOnly){var label=h(false);if(content){label=h(labelTag,{class:'sr-only',attrs:{id:ctx.labelId,for:labelFor||null}},[content]);}return h(isHorizontal?'b-col':'div',{props:isHorizontal?ctx.labelColProps:{}},[label]);}else{return h(isHorizontal?'b-col':labelTag,{on:isLegend?{click:ctx.legendClick}:{},props:isHorizontal?_objectSpread({tag:labelTag},ctx.labelColProps):{},attrs:{id:ctx.labelId,for:labelFor||null,// We add a tab index to legend so that screen readers will properly read the aria-labelledby in IE.\ntabindex:isLegend?'-1':null},class:[// When horizontal or if a legend is rendered, add col-form-label for correct sizing\n// as Bootstrap has inconsitent font styling for legend in non-horiontal form-groups.\n// See: https://github.com/twbs/bootstrap/issues/27805\nisHorizontal||isLegend?'col-form-label':'',// Emulate label padding top of 0 on legend when not horizontal\n!isHorizontal&&isLegend?'pt-0':'',// If not horizontal and not a legend, we add d-block to label so that label-align works\n!isHorizontal&&!isLegend?'d-block':'',ctx.labelSize?\"col-form-label-\".concat(ctx.labelSize):'',ctx.labelAlignClasses,ctx.labelClass]},[content]);}}// bFormGroup\n// @vue/component\nvar BFormGroup={name:'BFormGroup',components:{BFormRow:BFormRow,BCol:BCol,BFormInvalidFeedback:BFormInvalidFeedback,BFormValidFeedback:BFormValidFeedback,BFormText:BFormText},mixins:[idMixin,formStateMixin],props:_objectSpread({label:{type:String,default:null},labelFor:{type:String,default:null},labelSize:{type:String,default:null},labelSrOnly:{type:Boolean,default:false},labelClass:{type:[String,Array,Object],default:null},description:{type:String,default:null},invalidFeedback:{type:String,default:null},validFeedback:{type:String,default:null},tooltip:{// Enable tooltip style feedback\ntype:Boolean,default:false},validated:{type:Boolean,default:false},disabled:{type:Boolean,default:false}},bpLabelColProps,bpLabelAlignProps,{horizontal:{// Deprecated\ntype:Boolean,default:false},breakpoint:{// Deprecated (ignored if horizontal is not true)\ntype:String,default:null// legacy value 'sm'\n}}),computed:{labelColProps:function labelColProps(){var _this=this;var props={};/* istanbul ignore next: deprecated */if(this.horizontal){// Deprecated setting of horizontal/breakpoint props\n/* istanbul ignore next */warn(\"b-form-group: Props 'horizontal' and 'breakpoint' are deprecated. Use 'label-cols(-{breakpoint})' props instead.\");// Legacy default is breakpoint sm and cols 3\nvar bp=this.breakpoint||'sm';var cols=parseInt(this.labelCols,10)||3;props[bp]=cols>0?cols:3;// We then return the single breakpoint prop for legacy compatability\nreturn props;}BREAKPOINTS$1.forEach(function(breakpoint){// Grab the value if the label column breakpoint prop\nvar propVal=_this[makePropName(breakpoint,'labelCols')];// Handle case where the prop's value is an empty string, which represents true\npropVal=propVal===''?true:propVal||false;if(typeof propVal!=='boolean'){// Convert to column size to number\npropVal=parseInt(propVal,10)||0;// Ensure column size is greater than 0\npropVal=propVal>0?propVal:false;}if(propVal){// Add the prop to the list of props to give to b-col.\n// if breakpoint is '' (labelCols=true), then we use the col prop to make equal width at xs\nvar bColPropName=breakpoint||(typeof propVal==='boolean'?'col':'cols');// Add it to the props\nprops[bColPropName]=propVal;}});return props;},labelAlignClasses:function labelAlignClasses(){var _this2=this;var classes=[];BREAKPOINTS$1.forEach(function(breakpoint){// assemble the label column breakpoint align classes\nvar propVal=_this2[makePropName(breakpoint,'labelAlign')]||null;if(propVal){var className=breakpoint?\"text-\".concat(breakpoint,\"-\").concat(propVal):\"text-\".concat(propVal);classes.push(className);}});return classes;},isHorizontal:function isHorizontal(){// Determine if the resultant form-group will be rendered\n// horizontal (meaning it has label-col breakpoints)\nreturn keys(this.labelColProps).length>0;},labelId:function labelId(){return this.$slots['label']||this.label?this.safeId('_BV_label_'):null;},descriptionId:function descriptionId(){return this.$slots['description']||this.description?this.safeId('_BV_description_'):null;},hasInvalidFeedback:function hasInvalidFeedback(){// used for computing aria-describedby\nvar $slots=this.$slots;return this.computedState===false&&($slots['invalid-feedback']||this.invalidFeedback);},invalidFeedbackId:function invalidFeedbackId(){return this.hasInvalidFeedback?this.safeId('_BV_feedback_invalid_'):null;},hasValidFeedback:function hasValidFeedback(){// used for computing aria-describedby\nreturn this.computedState===true&&(this.$slots['valid-feedback']||this.validFeedback);},validFeedbackId:function validFeedbackId(){return this.hasValidFeedback?this.safeId('_BV_feedback_valid_'):null;},describedByIds:function describedByIds(){// Screen readers will read out any content linked to by aria-describedby\n// even if the content is hidden with 'display: none', hence we only include\n// feedback IDs if the form-group's state is explicitly valid or invalid.\nreturn[this.descriptionId,this.invalidFeedbackId,this.validFeedbackId].filter(function(i){return i;}).join(' ')||null;}},watch:{describedByIds:function describedByIds(add,remove){if(add!==remove){this.setInputDescribedBy(add,remove);}}},mounted:function mounted(){var _this3=this;this.$nextTick(function(){// Set the adia-describedby IDs on the input specified by label-for\n// We do this in a nextTick to ensure the children have finished rendering\n_this3.setInputDescribedBy(_this3.describedByIds);});},methods:{legendClick:function legendClick(evt){if(this.labelFor){// don't do anything if labelFor is set\nreturn;}var tagName=evt.target?evt.target.tagName:'';if(/^(input|select|textarea|label|button|a)$/i.test(tagName)){// If clicked an interactive element inside legend, we just let the default happen\nreturn;}var inputs=selectAll(SELECTOR,this.$refs.content).filter(isVisible);if(inputs&&inputs.length===1&&inputs[0].focus){// if only a single input, focus it, emulating label behaviour\ninputs[0].focus();}},setInputDescribedBy:function setInputDescribedBy(add,remove){// Sets the `aria-describedby` attribute on the input if label-for is set.\n// Optionally accepts a string of IDs to remove as the second parameter\nif(this.labelFor&&typeof document!=='undefined'){var input=select(\"#\".concat(this.labelFor),this.$refs.content);if(input){var adb='aria-describedby';var ids=(getAttr(input,adb)||'').split(/\\s+/);remove=(remove||'').split(/\\s+/);// Update ID list, preserving any original IDs\nids=ids.filter(function(id){return!arrayIncludes(remove,id);}).concat(add||'').join(' ').trim();if(ids){setAttr(input,adb,ids);}else{// No IDs, so remove the attribute\nremoveAttr(input,adb);}}}}},render:function render(h){var isFieldset=!this.labelFor;var isHorizontal=this.isHorizontal;// Generate the label\nvar label=renderLabel(h,this);// Generate the content\nvar content=h(isHorizontal?'b-col':'div',{ref:'content',attrs:{tabindex:isFieldset?'-1':null,role:isFieldset?'group':null,'aria-labelledby':isFieldset?this.labelId:null,'aria-describedby':isFieldset?this.ariaDescribedBy:null}},[this.$slots['default']||h(false),renderInvalidFeedback(h,this),renderValidFeedback(h,this),renderHelpText(h,this)]);// Create the form-group\nvar data={staticClass:'form-group',class:[this.validated?'was-validated':null,this.stateClass],attrs:{id:this.safeId(),disabled:isFieldset?this.disabled:null,role:isFieldset?null:'group','aria-invalid':this.computedState===false?'true':null,'aria-labelledby':this.labelId||null,'aria-describedby':this.describedByIds||null// Return it wrapped in a form-group.\n// Note: fieldsets do not support adding `row` or `form-row` directly to them\n// due to browser specific render issues, so we move the form-row to an\n// inner wrapper div when horizontal and using a fieldset\n}};return h(isFieldset?'fieldset':isHorizontal?'b-form-row':'div',data,isHorizontal&&isFieldset?[h('b-form-row',{},[label,content])]:[label,content]);}};var components$e={BFormGroup:BFormGroup,BFormFieldset:BFormGroup};var index$c={install:function install(Vue){registerComponents(Vue,components$e);}};// @vue/component\nvar formRadioCheckMixin={model:{prop:'checked',event:'input'},props:{value:{// Value when checked\n// type: Object,\n// default: undefined\n},checked:{// This is the v-model\n// type: Object,\n// default: undefined\n},inline:{type:Boolean,default:false},plain:{type:Boolean,default:false},button:{// Only applicable in standalone mode (non group)\ntype:Boolean,default:false},buttonVariant:{// Only applicable when rendered with button style\ntype:String,default:null}},data:function data(){return{localChecked:this.is_Group?this.bvGroup.checked:this.checked,hasFocus:false};},computed:{computedLocalChecked:{get:function get(){return this.is_Group?this.bvGroup.localChecked:this.localChecked;},set:function set(val){if(this.is_Group){this.bvGroup.localChecked=val;}else{this.localChecked=val;}}},is_Group:function is_Group(){// Is this check/radio a child of check-group or radio-group?\nreturn Boolean(this.bvGroup);},is_BtnMode:function is_BtnMode(){// Support button style in single input mode\nreturn this.is_Group?this.bvGroup.buttons:this.button;},is_Plain:function is_Plain(){return this.is_BtnMode?false:this.is_Group?this.bvGroup.plain:this.plain;},is_Custom:function is_Custom(){return this.is_BtnMode?false:!this.is_Plain;},is_Switch:function is_Switch(){// Custom switch styling (checkboxes only)\nreturn this.is_BtnMode||this.is_Radio||this.is_Plain?false:this.is_Group?this.bvGroup.switches:this.switch;},is_Inline:function is_Inline(){return this.is_Group?this.bvGroup.inline:this.inline;},is_Disabled:function is_Disabled(){// Child can be disabled while parent isn't, but is always disabled if group is\nreturn this.is_Group?this.bvGroup.disabled||this.disabled:this.disabled;},is_Required:function is_Required(){// Required only works when a name is provided for the input(s)\n// Child can only be required when parent is\n// Groups will always have a name (either user supplied or auto generated)\nreturn Boolean(this.get_Name&&(this.is_Group?this.bvGroup.required:this.required));},get_Name:function get_Name(){// Group name preferred over local name\nreturn(this.is_Group?this.bvGroup.groupName:this.name)||null;},get_Form:function get_Form(){return(this.is_Group?this.bvGroup.form:this.form)||null;},get_Size:function get_Size(){return(this.is_Group?this.bvGroup.size:this.size)||'';},get_State:function get_State(){return this.is_Group?this.bvGroup.computedState:this.computedState;},get_ButtonVariant:function get_ButtonVariant(){// Local variant preferred over group variant\nif(this.buttonVariant){return this.buttonVariant;}else if(this.is_Group&&this.bvGroup.buttonVariant){return this.bvGroup.buttonVariant;}// default variant\nreturn'secondary';},buttonClasses:function buttonClasses(){// Same for radio & check\nreturn['btn',\"btn-\".concat(this.get_ButtonVariant),this.get_Size?\"btn-\".concat(this.get_Size):'',// 'disabled' class makes \"button\" look disabled\nthis.is_Disabled?'disabled':'',// 'active' class makes \"button\" look pressed\nthis.is_Checked?'active':'',// Focus class makes button look focused\nthis.hasFocus?'focus':''];}},watch:{checked:function checked(newVal,oldVal){this.computedLocalChecked=newVal;}},methods:{handleFocus:function handleFocus(evt){// When in buttons mode, we need to add 'focus' class to label when input focused\n// As it is the hidden input which has actual focus\nif(evt.target){if(evt.type==='focus'){this.hasFocus=true;}else if(evt.type==='blur'){this.hasFocus=false;}}},// Convenience methods for focusing the input\nfocus:function focus(){if(!this.is_Disabled&&this.$refs.input&&this.$refs.input.focus){this.$refs.input.focus();}},blur:function blur(){if(!this.is_Disabled&&this.$refs.input&&this.$refs.input.blur){this.$refs.input.blur();}}},render:function render(h){var defaultSlot=this.$slots.default;// Generate the input element\nvar on={change:this.handleChange};if(this.is_BtnMode){// Handlers for focus styling when in button mode\non.focus=on.blur=this.handleFocus;}var input=h('input',{ref:'input',key:'input',on:on,class:{'form-check-input':this.is_Plain,'custom-control-input':this.is_Custom,'is-valid':this.get_State===true&&!this.is_BtnMode,'is-invalid':this.get_State===false&&!this.is_BtnMode},directives:[{name:'model',rawName:'v-model',value:this.computedLocalChecked,expression:'computedLocalChecked'}],attrs:{id:this.safeId(),type:this.is_Radio?'radio':'checkbox',name:this.get_Name,form:this.get_Form,disabled:this.is_Disabled,required:this.is_Required,autocomplete:'off','aria-required':this.is_Required||null},domProps:{value:this.value,checked:this.is_Checked}});if(this.is_BtnMode){// Button mode\nvar button=h('label',{class:this.buttonClasses},[input,defaultSlot]);if(!this.is_Group){// Standalone button mode, so wrap in 'btn-group-toggle'\n// and flag it as inline-block to mimic regular buttons\nbutton=h('div',{class:['btn-group-toggle','d-inline-block']},[button]);}return button;}else{// Not button mode\nvar label=h('label',{class:{'form-check-label':this.is_Plain,'custom-control-label':this.is_Custom},attrs:{for:this.safeId()}},defaultSlot);// Wrap it in a div\nreturn h('div',{class:_defineProperty({'form-check':this.is_Plain,'form-check-inline':this.is_Plain&&this.is_Inline,'custom-control':this.is_Custom,'custom-control-inline':this.is_Custom&&this.is_Inline,'custom-checkbox':this.is_Custom&&this.is_Check&&!this.is_Switch,'custom-switch':this.is_Switch,'custom-radio':this.is_Custom&&this.is_Radio},\"form-control-\".concat(this.get_Size),Boolean(this.get_Size&&!this.is_BtnMode))},[input,label]);}}};// @vue/component\nvar formMixin={props:{name:{type:String// default: undefined\n},id:{type:String// default: undefined\n},disabled:{type:Boolean},required:{type:Boolean,default:false},form:{type:String,default:null}}};// @vue/component\nvar formSizeMixin={props:{size:{type:String,default:null}},computed:{sizeFormClass:function sizeFormClass(){return[this.size?\"form-control-\".concat(this.size):null];},sizeBtnClass:function sizeBtnClass()/* istanbul ignore next: don't think this is used */{return[this.size?\"btn-\".concat(this.size):null];}}};var isDate=function isDate(obj){return obj instanceof Date;};// Assumes both a and b are arrays!\n// Handles when arrays are \"sparse\" (array.every(...) doesn't handle sparse)\nvar compareArrays=function compareArrays(a,b){if(a.length!==b.length){return false;}var equal=true;for(var i=0;equal&&i<a.length;i++){equal=looseEqual(a[i],b[i]);}return equal;};/**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   * Returns boolean true or false\n   */var looseEqual=function looseEqual(a,b){if(a===b){return true;}var aValidType=isDate(a);var bValidType=isDate(b);if(aValidType||bValidType){return aValidType&&bValidType?a.getTime()===b.getTime():false;}aValidType=isArray(a);bValidType=isArray(b);if(aValidType||bValidType){return aValidType&&bValidType?compareArrays(a,b):false;}aValidType=isObject(a);bValidType=isObject(b);if(aValidType||bValidType){/* istanbul ignore if: this if will probably never be called */if(!aValidType||!bValidType){return false;}var aKeysCount=keys(a).length;var bKeysCount=keys(b).length;if(aKeysCount!==bKeysCount){return false;}for(var key in a){var aHasKey=a.hasOwnProperty(key);var bHasKey=b.hasOwnProperty(key);if(aHasKey&&!bHasKey||!aHasKey&&bHasKey||!looseEqual(a[key],b[key])){return false;}}}return String(a)===String(b);};var looseIndexOf=function looseIndexOf(arr,val){// Assumes that the first argument is an array\nfor(var i=0;i<arr.length;i++){if(looseEqual(arr[i],val)){return i;}}return-1;};var BFormCheckbox={name:'BFormCheckbox',mixins:[formRadioCheckMixin,// Includes shared render function\nidMixin,formMixin,formSizeMixin,formStateMixin],inject:{bvGroup:{from:'bvCheckGroup',default:false}},props:{value:{// type: [Object, Boolean],\ndefault:true},uncheckedValue:{// type: [Object, Boolean],\n// Not applicable in multi-check mode\ndefault:false},indeterminate:{// Not applicable in multi-check mode\ntype:Boolean,default:false},switch:{// Custom switch styling\ntype:Boolean,default:false},checked:{// v-model\ntype:[String,Number,Object,Array,Boolean],default:null}},computed:{is_Checked:function is_Checked(){var checked=this.computedLocalChecked;var value=this.value;if(isArray(checked)){return looseIndexOf(checked,value)>-1;}else{return looseEqual(checked,value);}},is_Radio:function is_Radio(){return false;},is_Check:function is_Check(){return true;}},watch:{computedLocalChecked:function computedLocalChecked(newVal,oldVal){this.$emit('input',newVal);if(this.$refs&&this.$refs.input){this.$emit('update:indeterminate',this.$refs.input.indeterminate);}},indeterminate:function indeterminate(newVal,oldVal){this.setIndeterminate(newVal);}},mounted:function mounted(){// Set initial indeterminate state\nthis.setIndeterminate(this.indeterminate);},methods:{handleChange:function handleChange(_ref){var _ref$target=_ref.target,checked=_ref$target.checked,indeterminate=_ref$target.indeterminate;var localChecked=this.computedLocalChecked;var value=this.value;var isArr=isArray(localChecked);var uncheckedValue=isArr?null:this.uncheckedValue;// Update computedLocalChecked\nif(isArr){var idx=looseIndexOf(localChecked,value);if(checked&&idx<0){// Add value to array\nlocalChecked=localChecked.concat(value);}else if(!checked&&idx>-1){// Remove value from array\nlocalChecked=localChecked.slice(0,idx).concat(localChecked.slice(idx+1));}}else{localChecked=checked?value:uncheckedValue;}this.computedLocalChecked=localChecked;// Change is only emitted on user interaction\nthis.$emit('change',checked?value:uncheckedValue);// If this is a child of form-checkbox-group, we emit a change event on it as well\nif(this.is_Group){this.bvGroup.$emit('change',localChecked);}this.$emit('update:indeterminate',indeterminate);},setIndeterminate:function setIndeterminate(state){// Indeterminate only supported in single checkbox mode\nif(isArray(this.computedLocalChecked)){state=false;}if(this.$refs&&this.$refs.input){this.$refs.input.indeterminate=state;// Emit update event to prop\nthis.$emit('update:indeterminate',state);}}}};function isObject$1(obj){return obj&&{}.toString.call(obj)==='[object Object]';}// @vue/component\nvar formOptionsMixin={props:{options:{type:[Array,Object],default:function _default(){return[];}},valueField:{type:String,default:'value'},textField:{type:String,default:'text'},htmlField:{type:String,default:'html'},disabledField:{type:String,default:'disabled'}},computed:{formOptions:function formOptions(){var options=this.options;var valueField=this.valueField;var textField=this.textField;var htmlField=this.htmlField;var disabledField=this.disabledField;if(isArray(options)){// Normalize flat-ish arrays to Array of Objects\nreturn options.map(function(option){if(isObject$1(option)){var value=option[valueField];var text=String(option[textField]);return{value:typeof value==='undefined'?text:value,text:stripTags(text),html:option[htmlField],disabled:Boolean(option[disabledField])};}return{value:option,text:stripTags(String(option)),disabled:false};});}else{// options is Object\n// Normalize Objects to Array of Objects\nreturn keys(options).map(function(key){var option=options[key]||{};if(isObject$1(option)){var value=option[valueField];var text=option[textField];return{value:typeof value==='undefined'?key:value,text:typeof text==='undefined'?stripTags(String(key)):stripTags(String(text)),html:option[htmlField],disabled:Boolean(option[disabledField])};}return{value:key,text:stripTags(String(option)),disabled:false};});}}}};var formRadioCheckGroupMixin={model:{prop:'checked',event:'input'},props:{validated:{type:Boolean,default:false},ariaInvalid:{type:[Boolean,String],default:false},stacked:{type:Boolean,default:false},plain:{type:Boolean,default:false},buttons:{// Render as button style\ntype:Boolean,default:false},buttonVariant:{// Only applicable when rendered with button style\ntype:String,default:'secondary'}},computed:{inline:function inline(){return!this.stacked;},groupName:function groupName(){// Checks/Radios tied to the same model must have the same name,\n// especially for ARIA accessibility.\nreturn this.name||this.safeId();},groupClasses:function groupClasses(){if(this.buttons){return['btn-group-toggle',this.inline?'btn-group':'btn-group-vertical',this.size?\"btn-group-\".concat(this.size):'',this.validated?\"was-validated\":''];}return[this.validated?\"was-validated\":''];},computedAriaInvalid:function computedAriaInvalid(){var ariaInvalid=this.ariaInvalid;if(ariaInvalid===true||ariaInvalid==='true'||ariaInvalid===''){return'true';}return this.computedState===false?'true':null;}},watch:{checked:function checked(newVal,oldVal){this.localChecked=newVal;},localChecked:function localChecked(newVal,oldVal){this.$emit('input',newVal);}},render:function render(h){var _this=this;var $slots=this.$slots;var inputs=this.formOptions.map(function(option,idx){var uid=\"_BV_option_\".concat(idx,\"_\");return h(_this.is_RadioGroup?'b-form-radio':'b-form-checkbox',{key:uid,props:{id:_this.safeId(uid),value:option.value,// Individual radios or checks can be disabled in a group\ndisabled:option.disabled||false// We don't need to include these, since the input's will know they are inside here\n// name: this.groupName,\n// form: this.form || null,\n// required: Boolean(this.name && this.required)\n}},[h('span',{domProps:htmlOrText(option.html,option.text)})]);});return h('div',{class:this.groupClasses,attrs:{id:this.safeId(),role:this.is_RadioGroup?'radiogroup':'group',// Tabindex to allow group to be focused if needed\ntabindex:'-1','aria-required':this.required?'true':null,'aria-invalid':this.computedAriaInvalid}},[$slots.first,inputs,$slots.default]);}};var BFormCheckboxGroup={name:'BFormCheckboxGroup',components:{BFormCheckbox:BFormCheckbox},mixins:[idMixin,formMixin,formRadioCheckGroupMixin,// Includes render function\nformOptionsMixin,formSizeMixin,formStateMixin],provide:function provide(){return{bvCheckGroup:this};},props:{switches:{// Custom switch styling\ntype:Boolean,default:false},checked:{type:[String,Number,Object,Array,Boolean],default:null}},data:function data(){return{localChecked:this.checked||[]};},computed:{is_RadioGroup:function is_RadioGroup(){return false;}}};var components$f={BFormCheckbox:BFormCheckbox,BCheckbox:BFormCheckbox,BCheck:BFormCheckbox,BFormCheckboxGroup:BFormCheckboxGroup,BCheckboxGroup:BFormCheckboxGroup,BCheckGroup:BFormCheckboxGroup};var index$d={install:function install(Vue){registerComponents(Vue,components$f);}};var BFormRadio={name:'BFormRadio',mixins:[idMixin,formRadioCheckMixin,// Includes shared render function\nformMixin,formSizeMixin,formStateMixin],inject:{bvGroup:{from:'bvRadioGroup',default:false}},props:{checked:{// v-model\ntype:[String,Object,Number,Boolean],default:null}},computed:{// Radio Groups can only have a single value, so determining if checked is simple\nis_Checked:function is_Checked(){return looseEqual(this.value,this.computedLocalChecked);},// Flags for form-radio-check mixin\nis_Radio:function is_Radio(){return true;},is_Check:function is_Check(){return false;}},watch:{// Radio Groups can only have a single value, so our watchers are simple\ncomputedLocalChecked:function computedLocalChecked(newVal,oldVal){this.$emit('input',this.computedLocalChecked);}},methods:{handleChange:function handleChange(_ref){var checked=_ref.target.checked;var value=this.value;this.computedLocalChecked=value;// Change is only emitted on user interaction\nthis.$emit('change',checked?value:null);// If this is a child of form-radio-group, we emit a change event on it as well\nif(this.is_Group){this.bvGroup.$emit('change',checked?value:null);}}}};var BFormRadioGroup={name:'BFormRadioGroup',components:{BFormRadio:BFormRadio},mixins:[idMixin,formMixin,formRadioCheckGroupMixin,// Includes render function\nformOptionsMixin,formSizeMixin,formStateMixin],provide:function provide(){return{bvRadioGroup:this};},props:{checked:{type:[String,Object,Number,Boolean],default:null}},data:function data(){return{localChecked:this.checked};},computed:{is_RadioGroup:function is_RadioGroup(){return true;}}};var components$g={BFormRadio:BFormRadio,BRadio:BFormRadio,BFormRadioGroup:BFormRadioGroup,BRadioGroup:BFormRadioGroup};var index$e={install:function install(Vue){registerComponents(Vue,components$g);}};// @vue/component\nvar formTextMixin={model:{prop:'value',event:'update'},props:{value:{type:[String,Number],default:''},ariaInvalid:{type:[Boolean,String],default:false},readonly:{type:Boolean,default:false},plaintext:{type:Boolean,default:false},autocomplete:{type:String,default:null},placeholder:{type:String,default:null},formatter:{type:Function,default:null},trim:{type:Boolean,default:false},number:{type:Boolean,default:false},lazyFormatter:{type:Boolean,value:false}},data:function data(){return{localValue:this.stringifyValue(this.value)};},computed:{computedClass:function computedClass(){return[{// Range input needs class custom-range\n'custom-range':this.type==='range',// plaintext not supported by type=range or type=color\n'form-control-plaintext':this.plaintext&&this.type!=='range'&&this.type!=='color',// form-control not used by type=range or plaintext. Always used by type=color\n'form-control':!this.plaintext&&this.type!=='range'||this.type==='color'},this.sizeFormClass,this.stateClass];},computedAriaInvalid:function computedAriaInvalid(){if(!this.ariaInvalid||this.ariaInvalid==='false'){// this.ariaInvalid is null or false or 'false'\nreturn this.computedState===false?'true':null;}if(this.ariaInvalid===true){// User wants explicit aria-invalid=true\nreturn'true';}// Most likely a string value (which could be the string 'true')\nreturn this.ariaInvalid;}},watch:{value:function value(newVal,oldVal){if(newVal!==oldVal&&newVal!==this.localValue){this.localValue=this.stringifyValue(newVal);}}},mounted:function mounted(){var value=this.stringifyValue(this.value);if(value!==this.localValue){/* istanbul ignore next */this.localValue=value;}},methods:{stringifyValue:function stringifyValue(value){return value===null||typeof value==='undefined'?'':String(value);},getFormatted:function getFormatted(value,event){var force=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;value=this.stringifyValue(value);if((!this.lazyFormatter||force)&&typeof this.formatter==='function'){value=this.formatter(value,event);}return value;},updateValue:function updateValue(value){value=this.stringifyValue(value);if(this.localValue!==value){// keep the input set to the value before modifiers\nthis.localValue=value;if(this.number){// Emulate .number modifier behaviour\nvar num=parseFloat(value);value=isNaN(num)?value:num;}else if(this.trim){// Emulate .trim modifier behaviour\nvalue=value.trim();}// Update the v-model\nthis.$emit('update',value);}},onInput:function onInput(evt){// evt.target.composing is set by Vue\n// https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js\n/* istanbul ignore if: hard to test composition events */if(evt.target.composing){return;}var formatted=this.getFormatted(evt.target.value,evt);if(formatted===false||evt.defaultPrevented){evt.preventDefault();return;}this.updateValue(formatted);this.$emit('input',formatted);},onChange:function onChange(evt){// evt.target.composing is set by Vue\n// https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js\n/* istanbul ignore if: hard to test composition events */if(evt.target.composing){return;}var formatted=this.getFormatted(evt.target.value,evt);if(formatted===false){return;}this.updateValue(formatted);this.$emit('change',formatted);},onBlur:function onBlur(evt){// lazy formatter\nif(this.lazyFormatter){var formatted=this.getFormatted(evt.target.value,evt,true);if(formatted===false){return;}this.updateValue(formatted);}// Emit native blur event\nthis.$emit('blur',evt);},focus:function focus(){// For external handler that may want a focus method\nif(!this.disabled){this.$el.focus();}},blur:function blur(){// For external handler that may want a blur method\nif(!this.disabled){this.$el.blur();}}}};// @vue/component\nvar formSelectionMixin={computed:{selectionStart:{// Expose selectionStart for formatters, etc\ncache:false,get:function get()/* istanbul ignore next */{return this.$refs.input.selectionStart;},set:function set(val)/* istanbul ignore next */{this.$refs.input.selectionStart=val;}},selectionEnd:{// Expose selectionEnd for formatters, etc\ncache:false,get:function get()/* istanbul ignore next */{return this.$refs.input.selectionEnd;},set:function set(val)/* istanbul ignore next */{this.$refs.input.selectionEnd=val;}},selectionDirection:{// Expose selectionDirection for formatters, etc\ncache:false,get:function get()/* istanbul ignore next */{return this.$refs.input.selectionDirection;},set:function set(val)/* istanbul ignore next */{this.$refs.input.selectionDirection=val;}}},methods:{select:function select()/* istanbul ignore next */{var _this$$refs$input;// For external handler that may want a select() method\n(_this$$refs$input=this.$refs.input).select.apply(_this$$refs$input,arguments);},setSelectionRange:function setSelectionRange()/* istanbul ignore next */{var _this$$refs$input2;// For external handler that may want a setSelectionRange(a,b,c) method\n(_this$$refs$input2=this.$refs.input).setSelectionRange.apply(_this$$refs$input2,arguments);},setRangeText:function setRangeText()/* istanbul ignore next */{var _this$$refs$input3;// For external handler that may want a setRangeText(a,b,c) method\n(_this$$refs$input3=this.$refs.input).setRangeText.apply(_this$$refs$input3,arguments);}}};// @vue/component\nvar formValidityMixin={computed:{validity:{// Expose validity property\ncache:false,get:function get()/* istanbul ignore next */{return this.$refs.input.validity;}},validationMessage:{// Expose validationMessage property\ncache:false,get:function get()/* istanbul ignore next */{return this.$refs.input.validationMessage;}},willValidate:{// Expose willValidate property\ncache:false,get:function get()/* istanbul ignore next */{return this.$refs.input.willValidate;}}},methods:{setCustomValidity:function setCustomValidity()/* istanbul ignore next */{var _this$$refs$input;// For external handler that may want a setCustomValidity(...) method\nreturn(_this$$refs$input=this.$refs.input).setCustomValidity.apply(_this$$refs$input,arguments);},checkValidity:function checkValidity()/* istanbul ignore next */{var _this$$refs$input2;// For external handler that may want a checkValidity(...) method\nreturn(_this$$refs$input2=this.$refs.input).checkValidity.apply(_this$$refs$input2,arguments);},reportValidity:function reportValidity()/* istanbul ignore next */{var _this$$refs$input3;// For external handler that may want a reportValidity(...) method\nreturn(_this$$refs$input3=this.$refs.input).reportValidity.apply(_this$$refs$input3,arguments);}}};var TYPES=['text','password','email','number','url','tel','search','range','color','date','time','datetime','datetime-local','month','week'];// @vue/component\nvar BFormInput={name:'BFormInput',mixins:[idMixin,formMixin,formSizeMixin,formStateMixin,formTextMixin,formSelectionMixin,formValidityMixin],props:{// value prop defined in form-text mixin\n// value: { },\ntype:{type:String,default:'text',validator:function validator(type){return arrayIncludes(TYPES,type);}},noWheel:{// Disable mousewheel to prevent wheel from changing values (i.e. number/date).\ntype:Boolean,default:false},min:{type:[String,Number],default:null},max:{type:[String,Number],default:null},step:{type:[String,Number],default:null},list:{type:String,default:null}},computed:{localType:function localType(){// We only allow certain types\nreturn arrayIncludes(TYPES,this.type)?this.type:'text';}},watch:{noWheel:function noWheel(newVal){this.setWheelStopper(newVal);}},mounted:function mounted(){this.setWheelStopper(this.noWheel);},deactivated:function deactivated(){// Turn off listeners when keep-alive component deactivated\n/* istanbul ignore next */this.setWheelStopper(false);},activated:function activated(){// Turn on listeners (if no-wheel) when keep-alive component activated\n/* istanbul ignore next */this.setWheelStopper(this.noWheel);},beforeDestroy:function beforeDestroy(){/* istanbul ignore next */this.setWheelStopper(false);},methods:{setWheelStopper:function setWheelStopper(on){var input=this.$el;// We use native events, so that we don't interfere with propgation\nif(on){eventOn(input,'focus',this.onWheelFocus);eventOn(input,'blur',this.onWheelBlur);}else{eventOff(input,'focus',this.onWheelFocus);eventOff(input,'blur',this.onWheelBlur);eventOff(document,'wheel',this.stopWheel);}},onWheelFocus:function onWheelFocus(evt){eventOn(document,'wheel',this.stopWheel);},onWheelBlur:function onWheelBlur(evt){eventOff(document,'wheel',this.stopWheel);},stopWheel:function stopWheel(evt){evt.preventDefault();this.$el.blur();}},render:function render(h){var self=this;return h('input',{ref:'input',class:self.computedClass,directives:[{name:'model',rawName:'v-model',value:self.localValue,expression:'localValue'}],attrs:{id:self.safeId(),name:self.name,form:self.form||null,type:self.localType,disabled:self.disabled,placeholder:self.placeholder,required:self.required,autocomplete:self.autocomplete||null,readonly:self.readonly||self.plaintext,min:self.min,max:self.max,step:self.step,list:self.localType!=='password'?self.list:null,'aria-required':self.required?'true':null,'aria-invalid':self.computedAriaInvalid},domProps:{value:self.localValue},on:_objectSpread({},self.$listeners,{input:self.onInput,change:self.onChange,blur:self.onBlur})});}};var components$h={BFormInput:BFormInput,BInput:BFormInput};var index$f={install:function install(Vue){registerComponents(Vue,components$h);}};var BFormTextarea={name:'BFormTextarea',mixins:[idMixin,formMixin,formSizeMixin,formStateMixin,formTextMixin,formSelectionMixin,formValidityMixin],props:{rows:{type:[Number,String],default:2},maxRows:{type:[Number,String],default:null},wrap:{// 'soft', 'hard' or 'off'. Browser default is 'soft'\ntype:String,default:'soft'},noResize:{// Disable the resize handle of textarea\ntype:Boolean,default:false},noAutoShrink:{// When in auto resize mode, disable shrinking to content height\ntype:Boolean,default:false}},data:function data(){return{dontResize:true};},computed:{computedStyle:function computedStyle(){var styles={// Setting `noResize` to true will disable the ability for the user to\n// manually resize the textarea. We also disable when in auto resize mode\nresize:!this.computedRows||this.noResize?'none':null};if(!this.computedRows){// The computed height for auto resize.\n// We avoid setting the style to null, which can override user manual resize.\nstyles.height=this.computedHeight;}return styles;},computedMinRows:function computedMinRows(){// Ensure rows is at least 2 and positive (2 is the native textarea value).\n// A value of 1 can cause issues in some browsers, and most browsers only support\n// 2 as the smallest value.\nreturn Math.max(parseInt(this.rows,10)||2,2);},computedMaxRows:function computedMaxRows(){return Math.max(this.computedMinRows,parseInt(this.maxRows,10)||0);},computedRows:function computedRows(){// This is used to set the attribute 'rows' on the textarea.\n// If auto-resize is enabled, then we return null as we use CSS to control height.\nreturn this.computedMinRows===this.computedMaxRows?this.computedMinRows:null;},computedHeight:function computedHeight()/* istanbul ignore next: can't test getComputedProperties */{// We compare `computedRows` and `localValue` to `true`, a value\n// they both can't have at any time, to ensure reactivity\nif(this.$isServer||this.dontResize||this.computedRows===true||this.localValue===true){return null;}var el=this.$el;// Element must be visible (not hidden) and in document\n// *Must* be checked after above checks\nif(!isVisible(el)){return null;}// Remember old height (includes `px` units) and reset it temporarily to `auto`\nvar oldHeight=el.style.height;el.style.height='auto';// Get current computed styles\nvar computedStyle=getCS(el);// Height of one line of text in px\nvar lineHeight=parseFloat(computedStyle.lineHeight);// Minimum height for min rows (browser dependant)\nvar minHeight=parseInt(computedStyle.height,10)||lineHeight*this.computedMinRows;// Calculate height of content\nvar offset=(parseFloat(computedStyle.borderTopWidth)||0)+(parseFloat(computedStyle.borderBottomWidth)||0)+(parseFloat(computedStyle.paddingTop)||0)+(parseFloat(computedStyle.paddingBottom)||0);// Calculate content height in \"rows\"\nvar contentRows=Math.max((el.scrollHeight-offset)/lineHeight,2);// Calculate number of rows to display (limited within min/max rows)\nvar rows=Math.min(Math.max(contentRows,this.computedMinRows),this.computedMaxRows);// Calculate the required height of the textarea including border and padding (in pixels)\nvar height=Math.max(Math.ceil(rows*lineHeight+offset),minHeight);// Place old height back on element, just in case this computed prop returns the same value\nel.style.height=oldHeight;// Value of previous height (without px units appended)\nvar oldHeightPx=parseFloat(oldHeight)||0;if(this.noAutoShrink&&oldHeightPx>height){// Computed height remains the larger of oldHeight and new height\n// When height is `sticky` (no-auto-shrink is true)\nreturn oldHeight;}// Return the new computed height in px units\nreturn\"\".concat(height,\"px\");}},mounted:function mounted(){var _this=this;// Enable opt-in resizing once mounted\nthis.$nextTick(function(){_this.dontResize=false;});},activated:function activated(){var _this2=this;// If we are being re-activated in <keep-alive>, enable opt-in resizing\nthis.$nextTick(function(){_this2.dontResize=false;});},deactivated:function deactivated(){// If we are in a deactivated <keep-alive>, disable opt-in resizing\nthis.dontResize=true;},beforeDestroy:function beforeDestroy(){/* istanbul ignore next */this.dontResize=true;},render:function render(h){// Using self instead of this helps reduce code size during minification\nvar self=this;return h('textarea',{ref:'input',class:self.computedClass,style:self.computedStyle,directives:[{name:'model',rawName:'v-model',value:self.localValue,expression:'localValue'}],attrs:{id:self.safeId(),name:self.name,form:self.form||null,disabled:self.disabled,placeholder:self.placeholder,required:self.required,autocomplete:self.autocomplete||null,readonly:self.readonly||self.plaintext,rows:self.computedRows,wrap:self.wrap||null,'aria-required':self.required?'true':null,'aria-invalid':self.computedAriaInvalid},domProps:{value:self.localValue},on:_objectSpread({},self.$listeners,{input:self.onInput,change:self.onChange,blur:self.onBlur})});}};var components$i={BFormTextarea:BFormTextarea,BTextarea:BFormTextarea};var index$g={install:function install(Vue){registerComponents(Vue,components$i);}};// @vue/component\nvar formCustomMixin={props:{plain:{type:Boolean,default:false}},computed:{custom:function custom(){return!this.plain;}}};var BFormFile={name:'BFormFile',mixins:[idMixin,formMixin,formStateMixin,formCustomMixin],props:{value:{// type: Object,\ndefault:null},accept:{type:String,default:''},// Instruct input to capture from camera\ncapture:{type:Boolean,default:false},placeholder:{type:String,default:'No file chosen'// Chrome default file prompt\n},browseText:{type:String,default:null},dropPlaceholder:{type:String,default:null},multiple:{type:Boolean,default:false},directory:{type:Boolean,default:false},noTraverse:{type:Boolean,default:false},noDrop:{type:Boolean,default:false}},data:function data(){return{selectedFile:null,dragging:false,hasFocus:false};},computed:{selectLabel:function selectLabel(){// Draging active\nif(this.dragging&&this.dropPlaceholder){return this.dropPlaceholder;}// No file chosen\nif(!this.selectedFile||this.selectedFile.length===0){return this.placeholder;}// Multiple files\nif(this.multiple){return this.selectedFile.map(function(file){return file.name;}).join(', ');}// Single file\nreturn this.selectedFile.name;}},watch:{selectedFile:function selectedFile(newVal,oldVal){// The following test is needed when the file input is \"reset\" or the\n// exact same file(s) are selected to prevent an infinite loop.\n// When in `multiple` mode we need to check for two empty arrays or\n// two arrays with identical files\nif(newVal===oldVal||isArray(newVal)&&isArray(oldVal)&&newVal.length===oldVal.length&&newVal.every(function(v,i){return v===oldVal[i];})){return;}if(!newVal&&this.multiple){this.$emit('input',[]);}else{this.$emit('input',newVal);}},value:function value(newVal){if(!newVal||isArray(newVal)&&newVal.length===0){this.reset();}}},methods:{focusHandler:function focusHandler(evt){// Bootstrap v4 doesn't have focus styling for custom file input\n// Firefox has a '[type=file]:focus ~ sibling' selector issue,\n// so we add a 'focus' class to get around these bugs\nif(this.plain||evt.type==='focusout'){this.hasFocus=false;}else{// Add focus styling for custom file input\nthis.hasFocus=true;}},reset:function reset(){try{// Wrapped in try in case IE 11 craps out\nthis.$refs.input.value='';}catch(e){}// IE 11 doesn't support setting `input.value` to '' or null\n// So we use this little extra hack to reset the value, just in case.\n// This also appears to work on modern browsers as well.\nthis.$refs.input.type='';this.$refs.input.type='file';this.selectedFile=this.multiple?[]:null;},onFileChange:function onFileChange(evt){var _this=this;// Always emit original event\nthis.$emit('change',evt);// Check if special `items` prop is available on event (drop mode)\n// Can be disabled by setting no-traverse\nvar items=evt.dataTransfer&&evt.dataTransfer.items;if(items&&!this.noTraverse){/* istanbul ignore next: not supported in JSDOM */var queue=[];for(var i=0;i<items.length;i++){var item=items[i].webkitGetAsEntry();if(item){queue.push(this.traverseFileTree(item));}}Promise.all(queue).then(function(filesArr){_this.setFiles(from(filesArr));});return;}// Normal handling\nthis.setFiles(evt.target.files||evt.dataTransfer.files);},setFiles:function setFiles(){var files=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];if(!files){/* istanbul ignore next: this will probably not happen */this.selectedFile=null;}else if(this.multiple){// Convert files to array\nvar filesArray=[];for(var i=0;i<files.length;i++){filesArray.push(files[i]);}// Return file(s) as array\nthis.selectedFile=filesArray;}else{// Return single file object\nthis.selectedFile=files[0]||null;}},onReset:function onReset(){// Triggered when the parent form (if any) is reset\nthis.selectedFile=this.multiple?[]:null;},onDragover:function onDragover(evt){evt.preventDefault();evt.stopPropagation();if(this.noDrop||!this.custom){return;}this.dragging=true;evt.dataTransfer.dropEffect='copy';},onDragleave:function onDragleave(evt){evt.preventDefault();evt.stopPropagation();this.dragging=false;},onDrop:function onDrop(evt){evt.preventDefault();evt.stopPropagation();if(this.noDrop){return;}this.dragging=false;if(evt.dataTransfer.files&&evt.dataTransfer.files.length>0){this.onFileChange(evt);}},traverseFileTree:function traverseFileTree(item,path)/* istanbul ignore next: not supported in JSDOM */{var _this2=this;// Based on http://stackoverflow.com/questions/3590058\nreturn new Promise(function(resolve){path=path||'';if(item.isFile){// Get file\nitem.file(function(file){file.$path=path;// Inject $path to file obj\nresolve(file);});}else if(item.isDirectory){// Get folder contents\nitem.createReader().readEntries(function(entries){var queue=[];for(var i=0;i<entries.length;i++){queue.push(_this2.traverseFileTree(entries[i],path+item.name+'/'));}Promise.all(queue).then(function(filesArr){resolve(from(filesArr));});});}});}},render:function render(h){// Form Input\nvar input=h('input',{ref:'input',class:[{'form-control-file':this.plain,'custom-file-input':this.custom,focus:this.custom&&this.hasFocus},this.stateClass],attrs:{type:'file',id:this.safeId(),name:this.name,disabled:this.disabled,required:this.required,form:this.form||null,capture:this.capture||null,accept:this.accept||null,multiple:this.multiple,webkitdirectory:this.directory,'aria-required':this.required?'true':null},on:{change:this.onFileChange,focusin:this.focusHandler,focusout:this.focusHandler,reset:this.onReset}});if(this.plain){return input;}// Overlay Labels\nvar label=h('label',{class:['custom-file-label',this.dragging?'dragging':null],attrs:{for:this.safeId(),'data-browse':this.browseText||null}},this.selectLabel);// Return rendered custom file input\nreturn h('div',{class:['custom-file','b-form-file',this.stateClass],attrs:{id:this.safeId('_BV_file_outer_')},on:{dragover:this.onDragover,dragleave:this.onDragleave,drop:this.onDrop}},[input,label]);}};var components$j={BFormFile:BFormFile,BFile:BFormFile};var index$h={install:function install(Vue){registerComponents(Vue,components$j);}};var BFormSelect={name:'BFormSelect',mixins:[idMixin,formMixin,formSizeMixin,formStateMixin,formCustomMixin,formOptionsMixin],props:{value:{// type: Object,\n// default: undefined\n},multiple:{type:Boolean,default:false},selectSize:{// Browsers default size to 0, which shows 4 rows in most browsers in multiple mode\n// Size of 1 can bork out Firefox\ntype:Number,default:0},ariaInvalid:{type:[Boolean,String],default:false}},data:function data(){return{localValue:this.value};},computed:{computedSelectSize:function computedSelectSize(){// Custom selects with a size of zero causes the arrows to be hidden,\n// so dont render the size attribute in this case\nreturn!this.plain&&this.selectSize===0?null:this.selectSize;},inputClass:function inputClass(){return[this.plain?'form-control':'custom-select',this.size&&this.plain?\"form-control-\".concat(this.size):null,this.size&&!this.plain?\"custom-select-\".concat(this.size):null,this.stateClass];},computedAriaInvalid:function computedAriaInvalid(){if(this.ariaInvalid===true||this.ariaInvalid==='true'){return'true';}return this.stateClass==='is-invalid'?'true':null;}},watch:{value:function value(newVal,oldVal){this.localValue=newVal;},localValue:function localValue(newVal,oldVal){this.$emit('input',this.localValue);}},methods:{focus:function focus(){this.$refs.input.focus();},blur:function blur(){this.$refs.input.blur();}},render:function render(h){var _this=this;var $slots=this.$slots;var options=this.formOptions.map(function(option,index){return h('option',{key:\"option_\".concat(index,\"_opt\"),attrs:{disabled:Boolean(option.disabled)},domProps:_objectSpread({},htmlOrText(option.html,option.text),{value:option.value})});});return h('select',{ref:'input',class:this.inputClass,directives:[{name:'model',rawName:'v-model',value:this.localValue,expression:'localValue'}],attrs:{id:this.safeId(),name:this.name,form:this.form||null,multiple:this.multiple||null,size:this.computedSelectSize,disabled:this.disabled,required:this.required,'aria-required':this.required?'true':null,'aria-invalid':this.computedAriaInvalid},on:{change:function change(evt){var target=evt.target;var selectedVal=from(target.options).filter(function(o){return o.selected;}).map(function(o){return'_value'in o?o._value:o.value;});_this.localValue=target.multiple?selectedVal:selectedVal[0];_this.$nextTick(function(){_this.$emit('change',_this.localValue);});}}},[$slots.first,options,$slots.default]);}};var components$k={BFormSelect:BFormSelect,BSelect:BFormSelect};var index$i={install:function install(Vue){registerComponents(Vue,components$k);}};var components$l={BImg:BImg,BImgLazy:BImgLazy};var index$j={install:function install(Vue){registerComponents(Vue,components$l);}};var props$w={fluid:{type:Boolean,default:false},containerFluid:{type:Boolean,default:false},header:{type:String,default:null},headerHtml:{type:String,default:null},headerTag:{type:String,default:'h1'},headerLevel:{type:[Number,String],default:'3'},lead:{type:String,default:null},leadHtml:{type:String,default:null},leadTag:{type:String,default:'p'},tag:{type:String,default:'div'},bgVariant:{type:String,default:null},borderVariant:{type:String,default:null},textVariant:{type:String,default:null// @vue/component\n}};var BJumbotron={name:'BJumbotron',functional:true,props:props$w,render:function render(h,_ref){var _class2;var props=_ref.props,data=_ref.data,slots=_ref.slots;// The order of the conditionals matter.\n// We are building the component markup in order.\nvar childNodes=[];var $slots=slots();// Header\nif(props.header||$slots.header||props.headerHtml){childNodes.push(h(props.headerTag,{class:_defineProperty({},\"display-\".concat(props.headerLevel),Boolean(props.headerLevel))},$slots.header||props.headerHtml||stripTags(props.header)));}// Lead\nif(props.lead||$slots.lead||props.leadHtml){childNodes.push(h(props.leadTag,{staticClass:'lead'},$slots.lead||props.leadHtml||stripTags(props.lead)));}// Default slot\nif($slots.default){childNodes.push($slots.default);}// If fluid, wrap content in a container/container-fluid\nif(props.fluid){// Children become a child of a container\nchildNodes=[h(Container,{props:{fluid:props.containerFluid}},childNodes)];}// Return the jumbotron\nreturn h(props.tag,mergeData(data,{staticClass:'jumbotron',class:(_class2={'jumbotron-fluid':props.fluid},_defineProperty(_class2,\"text-\".concat(props.textVariant),Boolean(props.textVariant)),_defineProperty(_class2,\"bg-\".concat(props.bgVariant),Boolean(props.bgVariant)),_defineProperty(_class2,\"border-\".concat(props.borderVariant),Boolean(props.borderVariant)),_defineProperty(_class2,\"border\",Boolean(props.borderVariant)),_class2)}),childNodes);}};var components$m={BJumbotron:BJumbotron};var index$k={install:function install(Vue){registerComponents(Vue,components$m);}};var components$n={BLink:BLink};var index$l={install:function install(Vue){registerComponents(Vue,components$n);}};var props$x={tag:{type:String,default:'div'},flush:{type:Boolean,default:false},horizontal:{type:[Boolean,String],default:false// @vue/component\n}};var BListGroup={name:'BListGroup',functional:true,props:props$x,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var horizontal=props.horizontal===''?true:props.horizontal;horizontal=props.flush?false:horizontal;var componentData={staticClass:'list-group',class:_defineProperty({'list-group-flush':props.flush,'list-group-horizontal':horizontal===true},\"list-group-horizontal-\".concat(horizontal),typeof horizontal==='string')};return h(props.tag,mergeData(data,componentData),children);}};var actionTags=['a','router-link','button','b-link'];var linkProps$2=propsFactory();delete linkProps$2.href.default;delete linkProps$2.to.default;var props$y=_objectSpread({tag:{type:String,default:'div'},action:{type:Boolean,default:null},button:{type:Boolean,default:null},variant:{type:String,default:null}},linkProps$2);// @vue/component\nvar BListGroupItem={name:'BListGroupItem',functional:true,props:props$y,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,children=_ref.children;var tag=props.button?'button':!props.href&&!props.to?props.tag:BLink;var isAction=Boolean(props.href||props.to||props.action||props.button||arrayIncludes(actionTags,props.tag));var attrs={};var itemProps={};if(tag==='button'){if(!data.attrs||!data.attrs.type){// Add a type for button is one not provided in passed attributes\nattrs.type='button';}if(props.disabled){// Set disabled attribute if button and disabled\nattrs.disabled=true;}}else{itemProps=pluckProps(linkProps$2,props);}var componentData={attrs:attrs,props:itemProps,staticClass:'list-group-item',class:(_class={},_defineProperty(_class,\"list-group-item-\".concat(props.variant),Boolean(props.variant)),_defineProperty(_class,'list-group-item-action',isAction),_defineProperty(_class,\"active\",props.active),_defineProperty(_class,\"disabled\",props.disabled),_class)};return h(tag,mergeData(data,componentData),children);}};var components$o={BListGroup:BListGroup,BListGroupItem:BListGroupItem};var index$m={install:function install(Vue){registerComponents(Vue,components$o);}};var props$z={tag:{type:String,default:'div'}};var BMediaBody={name:'BMediaBody',functional:true,props:props$z,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{staticClass:'media-body'}),children);}};var props$A={tag:{type:String,default:'div'},verticalAlign:{type:String,default:'top'// @vue/component\n}};var BMediaAside={name:'BMediaAside',functional:true,props:props$A,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{staticClass:'d-flex',class:_defineProperty({},\"align-self-\".concat(props.verticalAlign),props.verticalAlign)}),children);}};var props$B={tag:{type:String,default:'div'},rightAlign:{type:Boolean,default:false},verticalAlign:{type:String,default:'top'},noBody:{type:Boolean,default:false// @vue/component\n}};var BMedia={name:'BMedia',functional:true,props:props$B,render:function render(h,_ref){var props=_ref.props,data=_ref.data,slots=_ref.slots,children=_ref.children;var childNodes=props.noBody?children:[];var $slots=slots();if(!props.noBody){if($slots.aside&&!props.rightAlign){childNodes.push(h(BMediaAside,{staticClass:'mr-3',props:{verticalAlign:props.verticalAlign}},$slots.aside));}childNodes.push(h(BMediaBody,$slots.default));if($slots.aside&&props.rightAlign){childNodes.push(h(BMediaAside,{staticClass:'ml-3',props:{verticalAlign:props.verticalAlign}},$slots.aside));}}return h(props.tag,mergeData(data,{staticClass:'media'}),childNodes);}};var components$p={BMedia:BMedia,BMediaAside:BMediaAside,BMediaBody:BMediaBody};var index$n={install:function install(Vue){registerComponents(Vue,components$p);}};var Selector$1={FIXED_CONTENT:'.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',STICKY_CONTENT:'.sticky-top',NAVBAR_TOGGLER:'.navbar-toggler'// ObserveDom config\n};var OBSERVER_CONFIG={subtree:true,childList:true,characterData:true,attributes:true,attributeFilter:['style','class']// modal wrapper ZINDEX offset incrememnt\n};var ZINDEX_OFFSET=2000;// Modal open count helpers\nfunction getModalOpenCount(){return parseInt(getAttr(document.body,'data-modal-open-count')||0,10);}function setModalOpenCount(count){setAttr(document.body,'data-modal-open-count',String(count));return count;}function incrementModalOpenCount(){return setModalOpenCount(getModalOpenCount()+1);}function decrementModalOpenCount(){return setModalOpenCount(Math.max(getModalOpenCount()-1,0));}// Returns the current visible modal highest z-index\nfunction getModalMaxZIndex(){return selectAll('div.modal')/* find all modals that are in document */.filter(isVisible)/* filter only visible ones */.map(function(m){return m.parentElement;})/* select the outer div */.reduce(function(max,el){/* compute the highest z-index */return Math.max(max,parseInt(el.style.zIndex||0,10));},0);}// Returns the next z-index to be used by a modal to ensure proper stacking\n// regardless of document order. Increments by 2000\nfunction getModalNextZIndex(){return getModalMaxZIndex()+ZINDEX_OFFSET;}// @vue/component\nvar BModal={name:'BModal',components:{BButton:BButton,BButtonClose:BButtonClose},mixins:[idMixin,listenOnRootMixin],model:{prop:'visible',event:'change'},props:{title:{type:String,default:''},titleHtml:{type:String},titleTag:{type:String,default:'h5'},size:{type:String,default:'md'},centered:{type:Boolean,default:false},scrollable:{type:Boolean,default:false},buttonSize:{type:String,default:''},noStacking:{type:Boolean,default:false},noFade:{type:Boolean,default:false},noCloseOnBackdrop:{type:Boolean,default:false},noCloseOnEsc:{type:Boolean,default:false},noEnforceFocus:{type:Boolean,default:false},headerBgVariant:{type:String,default:null},headerBorderVariant:{type:String,default:null},headerTextVariant:{type:String,default:null},headerCloseVariant:{type:String,default:null},headerClass:{type:[String,Array],default:null},bodyBgVariant:{type:String,default:null},bodyTextVariant:{type:String,default:null},modalClass:{type:[String,Array],default:null},dialogClass:{type:[String,Array],default:null},contentClass:{type:[String,Array],default:null},bodyClass:{type:[String,Array],default:null},footerBgVariant:{type:String,default:null},footerBorderVariant:{type:String,default:null},footerTextVariant:{type:String,default:null},footerClass:{type:[String,Array],default:null},hideHeader:{type:Boolean,default:false},hideFooter:{type:Boolean,default:false},hideHeaderClose:{type:Boolean,default:false},hideBackdrop:{type:Boolean,default:false},okOnly:{type:Boolean,default:false},okDisabled:{type:Boolean,default:false},cancelDisabled:{type:Boolean,default:false},visible:{type:Boolean,default:false},returnFocus:{// type: Object,\ndefault:null},headerCloseLabel:{type:String,default:'Close'},cancelTitle:{type:String,default:'Cancel'},cancelTitleHtml:{type:String},okTitle:{type:String,default:'OK'},okTitleHtml:{type:String},cancelVariant:{type:String,default:'secondary'},okVariant:{type:String,default:'primary'},lazy:{type:Boolean,default:false},busy:{type:Boolean,default:false}},data:function data(){return{is_hidden:this.lazy||false,// for lazy modals\nis_visible:false,// controls modal visible state\nis_transitioning:false,// Used for style control\nis_show:false,// Used for style control\nis_block:false,// Used for style control\nis_opening:false,// Semaphore for previnting incorrect modal open counts\nis_closing:false,// Semapbore for preventing incorrect modal open counts\nscrollbarWidth:0,zIndex:ZINDEX_OFFSET,// z-index for modal stacking\nisTop:true,// If the modal is the topmost opened modal\nisBodyOverflowing:false,return_focus:this.returnFocus||null};},computed:{contentClasses:function contentClasses(){return['modal-content',this.contentClass];},modalClasses:function modalClasses(){return[{fade:!this.noFade,show:this.is_show,'d-block':this.is_block},this.modalClass];},dialogClasses:function dialogClasses(){var _ref;return[(_ref={},_defineProperty(_ref,\"modal-\".concat(this.size),Boolean(this.size)),_defineProperty(_ref,'modal-dialog-centered',this.centered),_defineProperty(_ref,'modal-dialog-scrollable',this.scrollable),_ref),this.dialogClass];},backdropClasses:function backdropClasses(){return{fade:!this.noFade,show:this.is_show||this.noFade};},headerClasses:function headerClasses(){var _ref2;return[(_ref2={},_defineProperty(_ref2,\"bg-\".concat(this.headerBgVariant),Boolean(this.headerBgVariant)),_defineProperty(_ref2,\"text-\".concat(this.headerTextVariant),Boolean(this.headerTextVariant)),_defineProperty(_ref2,\"border-\".concat(this.headerBorderVariant),Boolean(this.headerBorderVariant)),_ref2),this.headerClass];},bodyClasses:function bodyClasses(){var _ref3;return[(_ref3={},_defineProperty(_ref3,\"bg-\".concat(this.bodyBgVariant),Boolean(this.bodyBgVariant)),_defineProperty(_ref3,\"text-\".concat(this.bodyTextVariant),Boolean(this.bodyTextVariant)),_ref3),this.bodyClass];},footerClasses:function footerClasses(){var _ref4;return[(_ref4={},_defineProperty(_ref4,\"bg-\".concat(this.footerBgVariant),Boolean(this.footerBgVariant)),_defineProperty(_ref4,\"text-\".concat(this.footerTextVariant),Boolean(this.footerTextVariant)),_defineProperty(_ref4,\"border-\".concat(this.footerBorderVariant),Boolean(this.footerBorderVariant)),_ref4),this.footerClass];},modalOuterStyle:function modalOuterStyle(){return{// We only set these styles on the stacked modals (ones with next z-index > 0).\nposition:'absolute',zIndex:this.zIndex};}},watch:{visible:function visible(newVal,oldVal){if(newVal===oldVal){return;}this[newVal?'show':'hide']();}},created:function created(){// create non-reactive property\nthis._observer=null;},mounted:function mounted(){// Listen for events from others to either open or close ourselves\n// And listen to all modals to enable/disable enforce focus\nthis.listenOnRoot('bv::show::modal',this.showHandler);this.listenOnRoot('bv::modal::shown',this.shownHandler);this.listenOnRoot('bv::hide::modal',this.hideHandler);this.listenOnRoot('bv::modal::hidden',this.hiddenHandler);this.listenOnRoot('bv::toggle::modal',this.toggleHandler);// Listen for bv:modal::show events, and close ourselves if the opening modal not us\nthis.listenOnRoot('bv::modal::show',this.modalListener);// Initially show modal?\nif(this.visible===true){this.show();}},beforeDestroy:function beforeDestroy()/* instanbul ignore next */{// Ensure everything is back to normal\nif(this._observer){this._observer.disconnect();this._observer=null;}// Ensure our root \"once\" listener is gone\nthis.$root.$off('bv::modal::hidden',this.doShow);this.setEnforceFocus(false);this.setResizeEvent(false);if(this.is_visible){this.is_visible=false;this.is_show=false;this.is_transitioning=false;var count=decrementModalOpenCount();if(count===0){// Re-adjust body/navbar/fixed padding/margins (as we were the last modal open)\nthis.setModalOpenClass(false);this.resetScrollbar();this.resetDialogAdjustments();}}},methods:{// Public Methods\nshow:function show(){if(this.is_visible||this.is_opening){// if already open, on in the process of opening, do nothing\nreturn;}if(this.is_closing){// if we are in the process of closing, wait until hidden before re-opening\nthis.$once('hidden',this.show);return;}this.is_opening=true;var showEvt=new BvEvent('show',{cancelable:true,vueTarget:this,target:this.$refs.modal,modalId:this.safeId(),relatedTarget:null});this.emitEvent(showEvt);// Don't show if canceled\nif(showEvt.defaultPrevented||this.is_visible){this.is_opening=false;return;}if(!this.noStacking){// Find the z-index to use\nthis.zIndex=getModalNextZIndex();// Show the modal\nthis.doShow();return;}if(hasClass(document.body,'modal-open')){// If another modal is already open, wait for it to close\nthis.$root.$once('bv::modal::hidden',this.doShow);return;}// Show the modal\nthis.doShow();},hide:function hide(trigger){if(!this.is_visible||this.is_closing){return;}this.is_closing=true;var hideEvt=new BvEvent('hide',{cancelable:true,vueTarget:this,target:this.$refs.modal,modalId:this.safeId(),// this could be the trigger element/component reference\nrelatedTarget:null,isOK:trigger||null,trigger:trigger||null,cancel:function cancel(){// Backwards compatibility\nwarn('b-modal: evt.cancel() is deprecated. Please use evt.preventDefault().');this.preventDefault();}});if(trigger==='ok'){this.$emit('ok',hideEvt);}else if(trigger==='cancel'){this.$emit('cancel',hideEvt);}this.emitEvent(hideEvt);// Hide if not canceled\nif(hideEvt.defaultPrevented||!this.is_visible){this.is_closing=false;return;}// stop observing for content changes\nif(this._observer){this._observer.disconnect();this._observer=null;}this.is_visible=false;this.$emit('change',false);},// Public method to toggle modal visibility\ntoggle:function toggle(triggerEl){if(triggerEl){this.return_focus=triggerEl;}if(this.is_visible){this.hide('toggle');}else{this.show();}},// Private method to finish showing modal\ndoShow:function doShow(){var _this=this;// Place modal in DOM if lazy\nthis.is_hidden=false;this.$nextTick(function(){// We do this in nextTick to ensure the modal is in DOM first before we show it\n_this.is_visible=true;_this.is_opening=false;_this.$emit('change',true);// Observe changes in modal content and adjust if necessary\n_this._observer=observeDom(_this.$refs.content,_this.adjustDialog.bind(_this),OBSERVER_CONFIG);});},// Transition Handlers\nonBeforeEnter:function onBeforeEnter(){this.getScrollbarWidth();this.is_transitioning=true;this.checkScrollbar();var count=incrementModalOpenCount();if(count===1){this.setScrollbar();}this.adjustDialog();this.setModalOpenClass(true);this.setResizeEvent(true);},onEnter:function onEnter(){this.is_block=true;},onAfterEnter:function onAfterEnter(){var _this2=this;this.is_show=true;this.is_transitioning=false;this.$nextTick(function(){var shownEvt=new BvEvent('shown',{cancelable:false,vueTarget:_this2,target:_this2.$refs.modal,modalId:_this2.safeId(),relatedTarget:null});_this2.emitEvent(shownEvt);_this2.focusFirst();_this2.setEnforceFocus(true);});},onBeforeLeave:function onBeforeLeave(){this.is_transitioning=true;this.setResizeEvent(false);},onLeave:function onLeave(){// Remove the 'show' class\nthis.is_show=false;},onAfterLeave:function onAfterLeave(){var _this3=this;this.is_block=false;this.resetDialogAdjustments();this.is_transitioning=false;var count=decrementModalOpenCount();if(count===0){this.resetScrollbar();this.setModalOpenClass(false);}this.setEnforceFocus(false);this.$nextTick(function(){_this3.is_hidden=_this3.lazy||false;_this3.zIndex=ZINDEX_OFFSET;_this3.returnFocusTo();_this3.is_closing=false;var hiddenEvt=new BvEvent('hidden',{cancelable:false,vueTarget:_this3,target:_this3.lazy?null:_this3.$refs.modal,modalId:_this3.safeId(),relatedTarget:null});_this3.emitEvent(hiddenEvt);});},// Event emitter\nemitEvent:function emitEvent(bvEvt){var type=bvEvt.type;this.$emit(type,bvEvt);this.$root.$emit(\"bv::modal::\".concat(type),bvEvt,this.safeId());},// UI Event Handlers\nonClickOut:function onClickOut(evt){// Do nothing if not visible, backdrop click disabled, or element that generated\n// click event is no longer in document\nif(!this.is_visible||this.noCloseOnBackdrop||!contains(document,evt.target)){return;}// If backdrop clicked, hide modal\nif(!contains(this.$refs.content,evt.target)){this.hide('backdrop');}},onEsc:function onEsc(evt){// If ESC pressed, hide modal\nif(evt.keyCode===KEY_CODES.ESC&&this.is_visible&&!this.noCloseOnEsc){this.hide('esc');}},// Document focusin listener\nfocusHandler:function focusHandler(evt){// If focus leaves modal, bring it back\nvar modal=this.$refs.modal;if(!this.noEnforceFocus&&this.isTop&&this.is_visible&&modal&&document!==evt.target&&!contains(modal,evt.target)){modal.focus({preventScroll:true});}},// Turn on/off focusin listener\nsetEnforceFocus:function setEnforceFocus(on){var options={passive:true,capture:false};if(on){eventOn(document,'focusin',this.focusHandler,options);}else{eventOff(document,'focusin',this.focusHandler,options);}},// Resize Listener\nsetResizeEvent:function setResizeEvent(on)/* istanbul ignore next: can't easily test in JSDOM */{var _this4=this;['resize','orientationchange'].forEach(function(evtName){var options={passive:true,capture:false};if(on){eventOn(window,evtName,_this4.adjustDialog,options);}else{eventOff(window,evtName,_this4.adjustDialog,options);}});},// Root Listener handlers\nshowHandler:function showHandler(id,triggerEl){if(id===this.id){this.return_focus=triggerEl||null;this.show();}},hideHandler:function hideHandler(id){if(id===this.id){this.hide('event');}},toggleHandler:function toggleHandler(id,triggerEl){if(id===this.id){this.toggle(triggerEl);}},shownHandler:function shownHandler(){this.setTop();},hiddenHandler:function hiddenHandler(){this.setTop();},setTop:function setTop(){// Determine if we are the topmost visible modal\nthis.isTop=this.zIndex>=getModalMaxZIndex();},modalListener:function modalListener(bvEvt){// If another modal opens, close this one\nif(this.noStacking&&bvEvt.vueTarget!==this){this.hide();}},// Focus control handlers\nfocusFirst:function focusFirst(){// Don't try and focus if we are SSR\nif(typeof document==='undefined'){return;}var modal=this.$refs.modal;var activeElement=document.activeElement;if(activeElement&&contains(modal,activeElement)){// If activeElement is child of modal or is modal, no need to change focus\nreturn;}if(modal){// make sure top of modal is showing (if longer than the viewport) and\n// focus the modal content wrapper\nthis.$nextTick(function(){modal.scrollTop=0;modal.focus();});}},returnFocusTo:function returnFocusTo(){// Prefer returnFocus prop over event specified return_focus value\nvar el=this.returnFocus||this.return_focus||null;if(typeof el==='string'){// CSS Selector\nel=select(el);}if(el){el=el.$el||el;if(isVisible(el)){el.focus();}}},// Utility methods\ngetScrollbarWidth:function getScrollbarWidth(){var scrollDiv=document.createElement('div');scrollDiv.className='modal-scrollbar-measure';document.body.appendChild(scrollDiv);this.scrollbarWidth=getBCR(scrollDiv).width-scrollDiv.clientWidth;document.body.removeChild(scrollDiv);},setModalOpenClass:function setModalOpenClass(open){if(open){addClass(document.body,'modal-open');}else{removeClass(document.body,'modal-open');}},adjustDialog:function adjustDialog(){if(!this.is_visible){return;}var modal=this.$refs.modal;var isModalOverflowing=modal.scrollHeight>document.documentElement.clientHeight;if(!this.isBodyOverflowing&&isModalOverflowing){modal.style.paddingLeft=\"\".concat(this.scrollbarWidth,\"px\");}else{modal.style.paddingLeft='';}if(this.isBodyOverflowing&&!isModalOverflowing){modal.style.paddingRight=\"\".concat(this.scrollbarWidth,\"px\");}else{modal.style.paddingRight='';}},resetDialogAdjustments:function resetDialogAdjustments(){var modal=this.$refs.modal;if(modal){modal.style.paddingLeft='';modal.style.paddingRight='';}},checkScrollbar:function checkScrollbar()/* istanbul ignore next: getBCR can't be tested in JSDOM */{var _getBCR=getBCR(document.body),left=_getBCR.left,right=_getBCR.right,height=_getBCR.height;// Extra check for body.height needed for stacked modals\nthis.isBodyOverflowing=left+right<window.innerWidth||height>window.innerHeight;},setScrollbar:function setScrollbar(){/* istanbul ignore if: get Computed Style can't be tested in JSDOM */if(this.isBodyOverflowing){// Note: DOMNode.style.paddingRight returns the actual value or '' if not set\n//   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\nvar body=document.body;var scrollbarWidth=this.scrollbarWidth;body._paddingChangedForModal=[];body._marginChangedForModal=[];// Adjust fixed content padding\nselectAll(Selector$1.FIXED_CONTENT).forEach(function(el){var actualPadding=el.style.paddingRight;var calculatedPadding=getCS(el).paddingRight||0;setAttr(el,'data-padding-right',actualPadding);el.style.paddingRight=\"\".concat(parseFloat(calculatedPadding)+scrollbarWidth,\"px\");body._paddingChangedForModal.push(el);});// Adjust sticky content margin\nselectAll(Selector$1.STICKY_CONTENT).forEach(function(el){var actualMargin=el.style.marginRight;var calculatedMargin=getCS(el).marginRight||0;setAttr(el,'data-margin-right',actualMargin);el.style.marginRight=\"\".concat(parseFloat(calculatedMargin)-scrollbarWidth,\"px\");body._marginChangedForModal.push(el);});// Adjust navbar-toggler margin\nselectAll(Selector$1.NAVBAR_TOGGLER).forEach(function(el){var actualMargin=el.style.marginRight;var calculatedMargin=getCS(el).marginRight||0;setAttr(el,'data-margin-right',actualMargin);el.style.marginRight=\"\".concat(parseFloat(calculatedMargin)+scrollbarWidth,\"px\");body._marginChangedForModal.push(el);});// Adjust body padding\nvar actualPadding=body.style.paddingRight;var calculatedPadding=getCS(body).paddingRight;setAttr(body,'data-padding-right',actualPadding);body.style.paddingRight=\"\".concat(parseFloat(calculatedPadding)+scrollbarWidth,\"px\");}},resetScrollbar:function resetScrollbar(){var body=document.body;if(body._paddingChangedForModal){// Restore fixed content padding\nbody._paddingChangedForModal.forEach(function(el){if(hasAttr(el,'data-padding-right')){el.style.paddingRight=getAttr(el,'data-padding-right')||'';removeAttr(el,'data-padding-right');}});}if(body._marginChangedForModal){// Restore sticky content and navbar-toggler margin\nbody._marginChangedForModal.forEach(function(el){if(hasAttr(el,'data-margin-right')){el.style.marginRight=getAttr(el,'data-margin-right')||'';removeAttr(el,'data-margin-right');}});}body._paddingChangedForModal=null;body._marginChangedForModal=null;// Restore body padding\nif(hasAttr(body,'data-padding-right')){body.style.paddingRight=getAttr(body,'data-padding-right')||'';removeAttr(body,'data-padding-right');}}},render:function render(h){var _this5=this;var $slots=this.$slots;// Modal Header\nvar header=h(false);if(!this.hideHeader){var modalHeader=$slots['modal-header'];if(!modalHeader){var closeButton=h(false);if(!this.hideHeaderClose){closeButton=h('b-button-close',{props:{disabled:this.is_transitioning,ariaLabel:this.headerCloseLabel,textVariant:this.headerCloseVariant||this.headerTextVariant},on:{click:function click(evt){_this5.hide('headerclose');}}},[$slots['modal-header-close']]);}modalHeader=[h(this.titleTag,{class:['modal-title']},[$slots['modal-title']||this.titleHtml||stripTags(this.title)]),closeButton];}header=h('header',{ref:'header',staticClass:'modal-header',class:this.headerClasses,attrs:{id:this.safeId('__BV_modal_header_')}},[modalHeader]);}// Modal Body\nvar body=h('div',{ref:'body',staticClass:'modal-body',class:this.bodyClasses,attrs:{id:this.safeId('__BV_modal_body_')}},[$slots.default]);// Modal Footer\nvar footer=h(false);if(!this.hideFooter){var modalFooter=$slots['modal-footer'];if(!modalFooter){var cancelButton=h(false);if(!this.okOnly){cancelButton=h('b-button',{props:{variant:this.cancelVariant,size:this.buttonSize,disabled:this.cancelDisabled||this.busy||this.is_transitioning},on:{click:function click(evt){_this5.hide('cancel');}}},[$slots['modal-cancel']||this.cancelTitleHtml||stripTags(this.cancelTitle)]);}var okButton=h('b-button',{props:{variant:this.okVariant,size:this.buttonSize,disabled:this.okDisabled||this.busy||this.is_transitioning},on:{click:function click(evt){_this5.hide('ok');}}},[$slots['modal-ok']||this.okTitleHtml||stripTags(this.okTitle)]);modalFooter=[cancelButton,okButton];}footer=h('footer',{ref:'footer',staticClass:'modal-footer',class:this.footerClasses,attrs:{id:this.safeId('__BV_modal_footer_')}},[modalFooter]);}// Assemble Modal Content\nvar modalContent=h('div',{ref:'content',class:this.contentClasses,attrs:{role:'document',id:this.safeId('__BV_modal_content_'),'aria-labelledby':this.hideHeader?null:this.safeId('__BV_modal_header_'),'aria-describedby':this.safeId('__BV_modal_body_')}},[header,body,footer]);// Modal Dialog wrapper\nvar modalDialog=h('div',{staticClass:'modal-dialog',class:this.dialogClasses},[modalContent]);// Modal\nvar modal=h('div',{ref:'modal',staticClass:'modal',class:this.modalClasses,directives:[{name:'show',rawName:'v-show',value:this.is_visible,expression:'is_visible'}],attrs:{id:this.safeId(),role:'dialog',tabindex:'-1','aria-hidden':this.is_visible?null:'true','aria-modal':this.is_visible?'true':null},on:{keydown:this.onEsc,click:this.onClickOut}},[modalDialog]);// Wrap modal in transition\nmodal=h('transition',{props:{enterClass:'',enterToClass:'',enterActiveClass:'',leaveClass:'',leaveActiveClass:'',leaveToClass:''},on:{'before-enter':this.onBeforeEnter,enter:this.onEnter,'after-enter':this.onAfterEnter,'before-leave':this.onBeforeLeave,leave:this.onLeave,'after-leave':this.onAfterLeave}},[modal]);// Modal Backdrop\nvar backdrop=h(false);if(!this.hideBackdrop&&(this.is_visible||this.is_transitioning)){backdrop=h('div',{staticClass:'modal-backdrop',class:this.backdropClasses,attrs:{id:this.safeId('__BV_modal_backdrop_')}},[$slots['modal-backdrop']]);}// Tab trap to prevent page from scrolling to next element in tab index during enforce focus tab cycle\nvar tabTrap=h(false);if(this.is_visible&&this.isTop&&!this.noEnforceFocus){tabTrap=h('div',{attrs:{tabindex:'0'}});}// Assemble modal and backdrop in an outer div needed for lazy modals\nvar outer=h(false);if(!this.is_hidden){outer=h('div',{key:'modal-outer',style:this.modalOuterStyle,attrs:{id:this.safeId('__BV_modal_outer_')}},[modal,tabTrap,backdrop]);}// Wrap in DIV to maintain thi.$el reference for hide/show method aceess\nreturn h('div',{},[outer]);}};var listenTypes$1={click:true};var bModal={// eslint-disable-next-line no-shadow-restricted-names\nbind:function bind(el,binding,vnode){bindTargets(vnode,binding,listenTypes$1,function(_ref){var targets=_ref.targets,vnode=_ref.vnode;targets.forEach(function(target){vnode.context.$root.$emit('bv::show::modal',target,vnode.elm);});});if(el.tagName!=='BUTTON'){// If element is not a button, we add `role=\"button\"` for accessibility\nsetAttr(el,'role','button');}},unbind:function unbind(el,binding,vnode){unbindTargets(vnode,binding,listenTypes$1);if(el.tagName!=='BUTTON'){// If element is not a button, we add `role=\"button\"` for accessibility\nremoveAttr(el,'role','button');}}};var directives$1={bModal:bModal};var modalDirectivePlugin={install:function install(Vue){registerDirectives(Vue,directives$1);}};var components$q={BModal:BModal};var index$o={install:function install(Vue){registerComponents(Vue,components$q);Vue.use(modalDirectivePlugin);}};var props$C={tag:{type:String,default:'ul'},fill:{type:Boolean,default:false},justified:{type:Boolean,default:false},tabs:{type:Boolean,default:false},pills:{type:Boolean,default:false},vertical:{type:Boolean,default:false},isNavBar:{type:Boolean,default:false// @vue/component\n}};var BNav={name:'BNav',functional:true,props:props$C,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;if(props.isNavBar){/* istanbul ignore next */warn(\"b-nav: Prop 'is-nav-bar' is deprecated. Please use component '<b-navbar-nav>' instead.\");}return h(props.tag,mergeData(data,{class:{nav:!props.isNavBar,'navbar-nav':props.isNavBar,'nav-tabs':props.tabs&&!props.isNavBar,'nav-pills':props.pills&&!props.isNavBar,'flex-column':props.vertical&&!props.isNavBar,'nav-fill':props.fill,'nav-justified':props.justified}}),children);}};var props$D=propsFactory();// @vue/component\nvar BNavItem={name:'BNavItem',functional:true,props:_objectSpread({},props$D,{linkAttrs:{type:Object,default:function _default(){return{};}},linkClasses:{type:[String,Object,Array],default:null}}),render:function render(h,_ref){var props=_ref.props,data=_ref.data,listeners=_ref.listeners,children=_ref.children;// We transfer the listeners to the link\ndelete data.on;return h('li',mergeData(data,{staticClass:'nav-item'}),[h(BLink,{staticClass:'nav-link',class:props.linkClasses,attrs:props.linkAttrs,props:props,on:listeners},children)]);}};var props$E={tag:{type:String,default:'span'// @vue/component\n}};var BNavText={name:'BNavText',functional:true,props:props$E,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{staticClass:'navbar-text'}),children);}};var BNavForm={name:'BNavForm',functional:true,props:{id:{type:String,default:null}},render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(BForm,mergeData(data,{attrs:{id:props.id},props:{inline:true}}),children);}};var BNavItemDropdown={name:'BNavItemDropdown',mixins:[idMixin,dropdownMixin],props:{noCaret:{type:Boolean,default:false},extraToggleClasses:{// Extra Toggle classes\ntype:String,default:''},extraMenuClasses:{// Extra Menu classes\ntype:String,default:''},role:{type:String,default:'menu'}},computed:{isNav:function isNav(){// Signal to dropdown mixin that we are in a navbar\nreturn true;},dropdownClasses:function dropdownClasses(){return['nav-item','b-nav-dropdown','dropdown',this.dropup?'dropup':'',this.visible?'show':''];},toggleClasses:function toggleClasses(){return['nav-link',this.noCaret?'':'dropdown-toggle',this.disabled?'disabled':'',this.extraToggleClasses?this.extraToggleClasses:''];},menuClasses:function menuClasses(){return['dropdown-menu',this.right?'dropdown-menu-right':'dropdown-menu-left',this.visible?'show':'',this.extraMenuClasses?this.extraMenuClasses:''];}},render:function render(h){var button=h('a',{class:this.toggleClasses,ref:'toggle',attrs:{href:'#',id:this.safeId('_BV_button_'),disabled:this.disabled,'aria-haspopup':'true','aria-expanded':this.visible?'true':'false'},on:{click:this.toggle,keydown:this.toggle// space, enter, down\n}},[this.$slots['button-content']||this.$slots.text||h('span',{domProps:htmlOrText(this.html,this.text)})]);var menu=h('div',{class:this.menuClasses,ref:'menu',attrs:{tabindex:'-1','aria-labelledby':this.safeId('_BV_button_')},on:{mouseover:this.onMouseOver,keydown:this.onKeydown// tab, up, down, esc\n}},[this.$slots.default]);return h('li',{attrs:{id:this.safeId()},class:this.dropdownClasses},[button,menu]);}};var components$r={BNav:BNav,BNavItem:BNavItem,BNavText:BNavText,BNavForm:BNavForm,BNavItemDropdown:BNavItemDropdown,BNavItemDd:BNavItemDropdown,BNavDropdown:BNavItemDropdown,BNavDd:BNavItemDropdown};var navPlugin={install:function install(Vue){registerComponents(Vue,components$r);Vue.use(dropdownPlugin);}};var props$F={tag:{type:String,default:'nav'},type:{type:String,default:'light'},variant:{type:String},toggleable:{type:[Boolean,String],default:false},fixed:{type:String},sticky:{type:Boolean,default:false},print:{type:Boolean,default:false// @vue/component\n}};var BNavbar={name:'BNavbar',functional:true,props:props$F,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,children=_ref.children;var breakpoint='';if(props.toggleable&&typeof props.toggleable==='string'&&props.toggleable!=='xs'){breakpoint=\"navbar-expand-\".concat(props.toggleable);}else if(props.toggleable===false){breakpoint='navbar-expand';}return h(props.tag,mergeData(data,{staticClass:'navbar',class:(_class={'d-print':props.print,'sticky-top':props.sticky},_defineProperty(_class,\"navbar-\".concat(props.type),Boolean(props.type)),_defineProperty(_class,\"bg-\".concat(props.variant),Boolean(props.variant)),_defineProperty(_class,\"fixed-\".concat(props.fixed),Boolean(props.fixed)),_defineProperty(_class,\"\".concat(breakpoint),Boolean(breakpoint)),_class),attrs:{role:props.tag==='nav'?null:'navigation'}}),children);}};var props$G={tag:{type:String,default:'ul'},fill:{type:Boolean,default:false},justified:{type:Boolean,default:false// @vue/component\n}};var BNavbarNav={name:'BNavbarNav',functional:true,props:props$G,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,mergeData(data,{staticClass:'navbar-nav',class:{'nav-fill':props.fill,'nav-justified':props.justified}}),children);}};var linkProps$3=propsFactory();linkProps$3.href.default=undefined;linkProps$3.to.default=undefined;var props$H=_objectSpread({},linkProps$3,{tag:{type:String,default:'div'// @vue/component\n}});var BNavbarBrand={name:'BNavbarBrand',functional:true,props:props$H,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var isLink=Boolean(props.to||props.href);var tag=isLink?BLink:props.tag;return h(tag,mergeData(data,{staticClass:'navbar-brand',props:isLink?pluckProps(linkProps$3,props):{}}),children);}};var BNavbarToggle={name:'BNavbarToggle',mixins:[listenOnRootMixin],props:{label:{type:String,default:'Toggle navigation'},target:{type:String,required:true}},data:function data(){return{toggleState:false};},created:function created(){this.listenOnRoot('bv::collapse::state',this.handleStateEvt);},methods:{onClick:function onClick(evt){this.$emit('click',evt);/* istanbul ignore next */if(!evt.defaultPrevented){this.$root.$emit('bv::toggle::collapse',this.target);}},handleStateEvt:function handleStateEvt(id,state){if(id===this.target){this.toggleState=state;}}},render:function render(h){return h('button',{class:['navbar-toggler'],attrs:{type:'button','aria-label':this.label,'aria-controls':this.target,'aria-expanded':this.toggleState?'true':'false'},on:{click:this.onClick}},[this.$slots.default||h('span',{class:['navbar-toggler-icon']})]);}};var components$s={BNavbar:BNavbar,BNavbarNav:BNavbarNav,BNavbarBrand:BNavbarBrand,BNavbarToggle:BNavbarToggle,BNavToggle:BNavbarToggle};var index$p={install:function install(Vue){registerComponents(Vue,components$s);Vue.use(navPlugin);Vue.use(collapsePlugin);Vue.use(dropdownPlugin);}};/**\n   * @param {number} length\n   * @return {Array}\n   */var range=function range(length){return Array.apply(null,{length:length});};/**\n   * Returns vNodes for named slot either scoped or unscoped\n   *\n   * @param {String} name\n   * @param {String} scope\n   * @param {Object} scopedSlots\n   * @param {Object} slots\n   * @returns {Array|undefined} vNodes\n   */var normalizeSlot=function normalizeSlot(name){var scope=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var $scopedSlots=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var $slots=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};// Note: in Vue 2.6.x, all names slots are also scoped slots\nvar slot=$scopedSlots[name]||$slots[name];return typeof slot==='function'?slot(scope):slot;};var normalizeSlotMixin={methods:{hasNormalizedSlot:function hasNormalizedSlot(name){// Returns true if the either a $scopedSlot or $slot exists with the specified name\nreturn Boolean(this.$scopedSlots[name]||this.$slots[name]);},normalizeSlot:function normalizeSlot$1(name){var scope=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Returns an array of rendered vNodes if slot found.\n// Returns undefined if not found.\nvar vNodes=normalizeSlot(name,scope,this.$scopedSlots,this.$slots);return vNodes?concat(vNodes):vNodes;}}};/*\n   * Comon props, computed, data, render function, and methods for b-pagination and b-pagination-nav\n   */var ELLIPSIS_THRESHOLD=3;// Default # of buttons limit\nvar DEFAULT_LIMIT=5;// Make an array of N to N+X\nfunction makePageArray(startNum,numPages){return range(numPages).map(function(value,index){return{number:index+startNum,classes:null};});}// Sanitize the provided Limit value (converting to a number)\nfunction sanitizeLimit(value){var limit=parseInt(value,10)||1;return limit<1?DEFAULT_LIMIT:limit;}// Sanitize the provided current page number (converting to a number)\nfunction sanitizeCurPage(value,numPages){var page=parseInt(value,10)||1;return page>numPages?numPages:page<1?1:page;}// Links don't normally respond to SPACE, so we add that functionality via this handler\nfunction onSpaceKey(evt){if(evt.keyCode===KEY_CODES.SPACE){evt.preventDefault();// Stop page from scrolling\nevt.stopImmediatePropagation();evt.stopPropagation();// Trigger the click event on the link\nevt.currentTarget.click();return false;}}// Props object\nvar props$I={disabled:{type:Boolean,default:false},value:{type:[Number,String],default:null,validator:function validator(value){var num=parseInt(value,10);/* istanbul ignore if */if(value!==null&&(isNaN(num)||num<1)){warn('pagination: v-model value must be a number greater than 0');return false;}return true;}},limit:{type:[Number,String],default:DEFAULT_LIMIT,validator:function validator(value){var num=parseInt(value,10);/* istanbul ignore if */if(isNaN(num)||num<1){warn('pagination: prop \"limit\" must be a number greater than 0');return false;}return true;}},size:{type:String,default:'md'},align:{type:String,default:'left'},hideGotoEndButtons:{type:Boolean,default:false},ariaLabel:{type:String,default:'Pagination'},labelFirstPage:{type:String,default:'Go to first page'},firstText:{type:String,default:'«'},labelPrevPage:{type:String,default:'Go to previous page'},prevText:{type:String,default:'‹'},labelNextPage:{type:String,default:'Go to next page'},nextText:{type:String,default:'›'},labelLastPage:{type:String,default:'Go to last page'},lastText:{type:String,default:'»'},labelPage:{type:[String,Function],default:'Go to page'},hideEllipsis:{type:Boolean,default:false},ellipsisText:{type:String,default:'…'// @vue/component\n}};var paginationMixin={components:{BLink:BLink},mixins:[normalizeSlotMixin],props:props$I,data:function data(){var curr=parseInt(this.value,10);return{// -1 signifies no page initially selected\ncurrentPage:curr>0?curr:-1,localNumPages:1,localLimit:DEFAULT_LIMIT};},computed:{btnSize:function btnSize(){return this.size?\"pagination-\".concat(this.size):'';},alignment:function alignment(){var align=this.align;if(align==='center'){return'justify-content-center';}else if(align==='end'||align==='right'){return'justify-content-end';}else if(align==='fill'){// The page-items will also have 'flex-fill' added.\n// We ad text centering to make the button appearance better in fill mode.\nreturn'text-center';}return'';},computedCurrentPage:function computedCurrentPage(){return sanitizeCurPage(this.currentPage,this.localNumPages);},paginationParams:function paginationParams(){// Determine if we should show the the ellipsis\nvar limit=this.limit;var numPages=this.localNumPages;var curPage=this.computedCurrentPage;var hideEllipsis=this.hideEllipsis;var showFirstDots=false;var showLastDots=false;var numLinks=limit;var startNum=1;if(numPages<=limit){// Special Case: Less pages available than the limit of displayed pages\nnumLinks=numPages;}else if(curPage<limit-1&&limit>ELLIPSIS_THRESHOLD){// We are near the beginning of the page list\nif(!hideEllipsis){showLastDots=true;numLinks=limit-1;}}else if(numPages-curPage+2<limit&&limit>ELLIPSIS_THRESHOLD){// We are near the end of the list\nif(!hideEllipsis){numLinks=limit-1;showFirstDots=true;}startNum=numPages-numLinks+1;}else{// We are somewhere in the middle of the page list\nif(limit>ELLIPSIS_THRESHOLD&&!hideEllipsis){numLinks=limit-2;showFirstDots=showLastDots=true;}startNum=curPage-Math.floor(numLinks/2);}// Sanity checks\nif(startNum<1){/* istanbul ignore next */startNum=1;}else if(startNum>numPages-numLinks){startNum=numPages-numLinks+1;}return{showFirstDots:showFirstDots,showLastDots:showLastDots,numLinks:numLinks,startNum:startNum};},pageList:function pageList(){// Generates the pageList array\nvar _this$paginationParam=this.paginationParams,numLinks=_this$paginationParam.numLinks,startNum=_this$paginationParam.startNum;var currPage=this.computedCurrentPage;// Generate list of page numbers\nvar pages=makePageArray(startNum,numLinks);// We limit to a total of 3 page buttons on XS screens\n// So add classes to page links to hide them for XS breakpoint\n// Note: Ellipsis will also be hidden on XS screens\n// TODO: Make this visual limit configurable based on breakpoint(s)\nif(pages.length>3){var idx=currPage-startNum;// THe following is a bootstrap-vue custom utility class\nvar classes='bv-d-xs-down-none';if(idx===0){// Keep leftmost 3 buttons visible when current page is first page\nfor(var i=3;i<pages.length;i++){pages[i].classes=classes;}}else if(idx===pages.length-1){// Keep rightmost 3 buttons visible when current page is last page\nfor(var _i=0;_i<pages.length-3;_i++){pages[_i].classes=classes;}}else{// Hide all except current page, current page - 1 and current page + 1\nfor(var _i2=0;_i2<idx-1;_i2++){// hide some left button(s)\npages[_i2].classes=classes;}for(var _i3=pages.length-1;_i3>idx+1;_i3--){// hide some right button(s)\npages[_i3].classes=classes;}}}return pages;}},watch:{value:function value(newValue,oldValue){if(newValue!==oldValue){this.currentPage=sanitizeCurPage(newValue,this.localNumPages);}},currentPage:function currentPage(newValue,oldValue){if(newValue!==oldValue){// Emit null if no page selected\nthis.$emit('input',newValue>0?newValue:null);}},limit:function limit(newValue,oldValue){if(newValue!==oldValue){this.localLimit=sanitizeLimit(newValue);}}},created:function created(){var _this=this;// Set our default values in data\nthis.localLimit=sanitizeLimit(this.limit);this.$nextTick(function(){// Sanity check\n_this.currentPage=_this.currentPage>_this.localNumPages?_this.localNumPages:_this.currentPage;});},methods:{getButtons:function getButtons(){// Return only buttons that are visible\nreturn selectAll('a.page-link',this.$el).filter(function(btn){return isVisible(btn);});},setBtnFocus:function setBtnFocus(btn){btn.focus();},focusCurrent:function focusCurrent(){var _this2=this;// We do this in next tick to ensure buttons have finished rendering\nthis.$nextTick(function(){var btn=_this2.getButtons().find(function(el){return parseInt(getAttr(el,'aria-posinset'),10)===_this2.computedCurrentPage;});if(btn&&btn.focus){_this2.setBtnFocus(btn);}else{// Fallback if current page is not in button list\n_this2.focusFirst();}});},focusFirst:function focusFirst(){var _this3=this;// We do this in next tick to ensure buttons have finished rendering\nthis.$nextTick(function(){var btn=_this3.getButtons().find(function(el){return!isDisabled(el);});if(btn&&btn.focus&&btn!==document.activeElement){_this3.setBtnFocus(btn);}});},focusLast:function focusLast(){var _this4=this;// We do this in next tick to ensure buttons have finished rendering\nthis.$nextTick(function(){var btn=_this4.getButtons().reverse().find(function(el){return!isDisabled(el);});if(btn&&btn.focus&&btn!==document.activeElement){_this4.setBtnFocus(btn);}});},focusPrev:function focusPrev(){var _this5=this;// We do this in next tick to ensure buttons have finished rendering\nthis.$nextTick(function(){var buttons=_this5.getButtons();var idx=buttons.indexOf(document.activeElement);if(idx>0&&!isDisabled(buttons[idx-1])&&buttons[idx-1].focus){_this5.setBtnFocus(buttons[idx-1]);}});},focusNext:function focusNext(){var _this6=this;// We do this in next tick to ensure buttons have finished rendering\nthis.$nextTick(function(){var buttons=_this6.getButtons();var idx=buttons.indexOf(document.activeElement);var cnt=buttons.length-1;if(idx<cnt&&!isDisabled(buttons[idx+1])&&buttons[idx+1].focus){_this6.setBtnFocus(buttons[idx+1]);}});}},render:function render(h){var _this7=this;var buttons=[];var numberOfPages=this.localNumPages;var disabled=this.disabled;var _this$paginationParam2=this.paginationParams,showFirstDots=_this$paginationParam2.showFirstDots,showLastDots=_this$paginationParam2.showLastDots;var currPage=this.computedCurrentPage;var fill=this.align==='fill';// Helper function and flag\nvar isActivePage=function isActivePage(pageNum){return pageNum===currPage;};var noCurrPage=this.currentPage<1;// Factory function for prev/next/first/last buttons\nvar makeEndBtn=function makeEndBtn(linkTo,ariaLabel,btnSlot,btnText,pageTest,key){var isDisabled=disabled||isActivePage(pageTest)||noCurrPage||linkTo<1||linkTo>numberOfPages;var pageNum=linkTo<1?1:linkTo>numberOfPages?numberOfPages:linkTo;var scope={disabled:isDisabled,page:pageNum,index:pageNum-1};var btnContent=_this7.normalizeSlot(btnSlot,scope)||toString(btnText)||h(false);var inner=h(isDisabled?'span':'b-link',{staticClass:'page-link',props:isDisabled?{}:_this7.linkProps(linkTo),attrs:{role:'menuitem',tabindex:isDisabled?null:'-1','aria-label':ariaLabel,'aria-controls':_this7.ariaControls||null,'aria-disabled':isDisabled?'true':null},on:isDisabled?{}:{click:function click(evt){_this7.onClick(linkTo,evt);},keydown:onSpaceKey}},[btnContent]);return h('li',{key:key,staticClass:'page-item',class:{disabled:isDisabled,'flex-fill':fill},attrs:{role:'none presentation','aria-hidden':isDisabled?'true':null}},[inner]);};// Ellipsis factory\nvar makeEllipsis=function makeEllipsis(isLast){return h('li',{key:\"elipsis-\".concat(isLast?'last':'first'),staticClass:'page-item',class:['disabled','bv-d-xs-down-none',fill?'flex-fill':''],attrs:{role:'separator'}},[h('span',{staticClass:'page-link'},[_this7.normalizeSlot('ellipsis-text',{})||toString(_this7.ellipsisText)||h(false)])]);};// Goto First Page button bookend\nbuttons.push(this.hideGotoEndButtons?h(false):makeEndBtn(1,this.labelFirstPage,'first-text',this.firstText,1,'bookend-goto-first'));// Goto Previous page button bookend\nbuttons.push(makeEndBtn(currPage-1,this.labelPrevPage,'prev-text',this.prevText,1,'bookend-goto-prev'));// First Ellipsis Bookend\nbuttons.push(showFirstDots?makeEllipsis(false):h(false));// Individual Page links\nthis.pageList.forEach(function(page,idx){var active=isActivePage(page.number)&&!noCurrPage;// Active page will have tabindex of 0, or if no current page and first page button\nvar tabIndex=disabled?null:active||noCurrPage&&idx===0?'0':'-1';var attrs={role:'menuitemradio','aria-disabled':disabled?'true':null,'aria-controls':_this7.ariaControls||null,'aria-label':typeof _this7.labelPage==='function'?_this7.labelPage(page.number):\"\".concat(_this7.labelPage,\" \").concat(page.number),'aria-checked':active?'true':'false','aria-posinset':page.number,'aria-setsize':numberOfPages,// ARIA \"roving tabindex\" method\ntabindex:tabIndex};var btnContent=toString(_this7.makePage(page.number));var scope={page:page.number,index:page.number-1,content:btnContent,active:active,disabled:disabled};var inner=h(disabled?'span':'b-link',{props:disabled?{}:_this7.linkProps(page.number),staticClass:'page-link',attrs:attrs,on:disabled?{}:{click:function click(evt){_this7.onClick(page.number,evt);},keydown:onSpaceKey}},[_this7.normalizeSlot('page',scope)||btnContent]);buttons.push(h('li',{key:\"page-\".concat(page.number),staticClass:'page-item',class:[{disabled:disabled,active:active,'flex-fill':fill},page.classes],attrs:{role:'none presentation'}},[inner]));});// Last Ellipsis Bookend\nbuttons.push(showLastDots?makeEllipsis(true):h(false));// Goto Next page button bookend\nbuttons.push(makeEndBtn(currPage+1,this.labelNextPage,'next-text',this.nextText,numberOfPages,'bookend-goto-next'));// Goto Last Page button bookend\nbuttons.push(this.hideGotoEndButtons?h(false):makeEndBtn(numberOfPages,this.labelLastPage,'last-text',this.lastText,numberOfPages,'bookend-goto-last'));// Assemble the paginatiom buttons\nvar pagination=h('ul',{ref:'ul',staticClass:'pagination',class:['b-pagination',this.btnSize,this.alignment],attrs:{role:'menubar','aria-disabled':disabled?'true':'false','aria-label':this.ariaLabel||null},on:{keydown:function keydown(evt){var keyCode=evt.keyCode;var shift=evt.shiftKey;if(keyCode===KEY_CODES.LEFT){evt.preventDefault();shift?_this7.focusFirst():_this7.focusPrev();}else if(keyCode===KEY_CODES.RIGHT){evt.preventDefault();shift?_this7.focusLast():_this7.focusNext();}}}},buttons);// if we are pagination-nav, wrap in '<nav>' wrapper\nif(this.isNav){return h('nav',{attrs:{'aria-disabled':disabled?'true':null,'aria-hidden':disabled?'true':'false'}},[pagination]);}else{return pagination;}}};var DEFAULT_PER_PAGE=20;var DEFAULT_TOTAL_ROWS=0;function sanitizePerPage(value){var perPage=parseInt(value,10)||DEFAULT_PER_PAGE;return perPage<1?1:perPage;}function sanitizeTotalRows(value){var totalRows=parseInt(value,10)||DEFAULT_TOTAL_ROWS;return totalRows<0?0:totalRows;}var props$J={perPage:{type:[Number,String],default:DEFAULT_PER_PAGE},totalRows:{type:[Number,String],default:DEFAULT_TOTAL_ROWS},ariaControls:{type:String,default:null// Our render function is brought in from the pagination mixin\n// @vue/component\n}};var BPagination={name:'BPagination',mixins:[paginationMixin],props:props$J,computed:{numberOfPages:function numberOfPages(){var result=Math.ceil(sanitizeTotalRows(this.totalRows)/sanitizePerPage(this.perPage));return result<1?1:result;}},watch:{numberOfPages:function numberOfPages(newVal,OldVal){this.localNumPages=newVal;}},created:function created(){var _this=this;// Set the initial page count\nthis.localNumPages=this.numberOfPages;// Set the initial page value\nvar curr=parseInt(this.value,10)||0;if(curr>0){this.currentPage=curr;}else{this.$nextTick(function(){// If this value parses to NaN or a value less than 1\n// Trigger an initial emit of 'null' if no page specified\n_this.currentPage=0;});}},mounted:function mounted(){// Set the initial page count\nthis.localNumPages=this.numberOfPages;},methods:{// These methods are used by the render function\nonClick:function onClick(num,evt){var _this2=this;// Handle edge cases where number of pages has changed (i.e. if perPage changes)\n// This should normally not happen, but just in case.\nif(num>this.numberOfPages){/* istanbul ignore next */num=this.numberOfPages;}else if(num<1){/* istanbul ignore next */num=1;}// Update the v-model\nthis.currentPage=num;// Emit event triggered by user interaction\nthis.$emit('change',this.currentPage);this.$nextTick(function(){// Keep the current button focused if possible\nvar target=evt.target;if(isVisible(target)&&_this2.$el.contains(target)&&target.focus){target.focus();}else{_this2.focusCurrent();}});},makePage:function makePage(pageNum){return pageNum;},linkProps:function linkProps(pageNum){// Always '#' for pagination component\nreturn{href:'#'};}}};var components$t={BPagination:BPagination};var index$q={install:function install(Vue){registerComponents(Vue,components$t);}};function sanitizeNumPages(value){var num=parseInt(value,10)||1;return num<1?1:num;}// Props object\nvar props$K={// pagination-nav specific props\nnumberOfPages:{type:[Number,String],default:1,validator:function validator(value){var num=parseInt(value,10);/* istanbul ignore if */if(isNaN(num)||num<1){warn('b-pagination: prop \"number-of-pages\" must be a number greater than 0');return false;}return true;}},baseUrl:{type:String,default:'/'},useRouter:{type:Boolean,default:false},linkGen:{type:Function,default:null},pageGen:{type:Function,default:null},pages:{// Optional array of page links\ntype:Array,default:null},noPageDetect:{// Disable auto page number detection if true\ntype:Boolean,default:false},// router-link specific props\nactiveClass:{type:String// default: undefined\n},exact:{type:Boolean,default:false},exactActiveClass:{type:String// default: undefined\n},// nuxt-link specific prop(s)\nnoPrefetch:{type:Boolean,default:false// Our render function is brought in via the pagination mixin\n// @vue/component\n}};var BPaginationNav={name:'BPaginationNav',mixins:[paginationMixin],props:props$K,computed:{// Used by render function to trigger wrapping in '<nav>' element\nisNav:function isNav(){return true;},computedValue:function computedValue(){// Returns the value prop as a number or `null` if undefined or < 1\nvar val=parseInt(this.value,10);return isNaN(val)||val<1?null:val;}},watch:{numberOfPages:function numberOfPages(newVal,oldVal){var _this=this;this.$nextTick(function(){_this.setNumPages();});},pages:function pages(newVal,oldVal){var _this2=this;this.$nextTick(function(){_this2.setNumPages();});}},created:function created(){var _this3=this;this.setNumPages();// For SSR, assuming a page URL can be detected\nthis.$nextTick(function(){_this3.guessCurrentPage();});},mounted:function mounted(){var _this4=this;if(this.$router){// We only add the watcher if vue router is detected\nthis.$watch('$route',function(to,from){_this4.$nextTick(function(){requestAF(function(){_this4.guessCurrentPage();});});});}},methods:{setNumPages:function setNumPages(){if(isArray(this.pages)&&this.pages.length>0){this.localNumPages=this.pages.length;}else{this.localNumPages=sanitizeNumPages(this.numberOfPages);}},onClick:function onClick(pageNum,evt){var _this5=this;// Dont do anything if clicking the current active page\nif(pageNum===this.currentPage){return;}requestAF(function(){// Update the v-model\n// Done in in requestAF() to allow browser to complete the\n// native browser click handling of a link\n_this5.currentPage=pageNum;_this5.$emit('change',pageNum);});this.$nextTick(function(){// Done in a nextTick() to ensure rendering complete\ntry{// Emulate native link click page reloading behaviour by blurring the\n// paginator and returning focus to the document\nvar target=evt.currentTarget||evt.target;target.blur();}catch(e){}});},getPageInfo:function getPageInfo(pageNum){if(!isArray(this.pages)||this.pages.length===0||this.pages[pageNum-1]===undefined){var link=\"\".concat(this.baseUrl).concat(pageNum);return{link:this.useRouter?{path:link}:link,text:toString(pageNum)};}var info=this.pages[pageNum-1];if(isObject(info)){var _link=info.link;return{// Mormalize link for router use\nlink:isObject(_link)?_link:this.useRouter?{path:_link}:_link,// Make sure text has a value\ntext:toString(info.text||pageNum)};}else{return{link:toString(info),text:toString(pageNum)};}},makePage:function makePage(pageNum){var info=this.getPageInfo(pageNum);if(this.pageGen&&typeof this.pageGen==='function'){return this.pageGen(pageNum,info);}return info.text;},makeLink:function makeLink(pageNum){var info=this.getPageInfo(pageNum);if(this.linkGen&&typeof this.linkGen==='function'){return this.linkGen(pageNum,info);}return info.link;},linkProps:function linkProps(pageNum){var link=this.makeLink(pageNum);var props={target:this.target||null,rel:this.rel||null,disabled:this.disabled,// The following props are only used if BLink detects router\nexact:this.exact,activeClass:this.activeClass,exactActiveClass:this.exactActiveClass,append:this.append,replace:this.replace,// nuxt-link specific prop\nnoPrefetch:this.noPrefetch};if(this.useRouter||_typeof(link)==='object'){props.to=link;}else{props.href=link;}return props;},resolveLink:function resolveLink(){var to=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';// Given a to (or href string), convert to normalized route-like structure\n// Works only client side!!\ntry{var link=document.createElement('a');// Convert the `to` to a HREF via a temporary `a` tag\nlink.href=computeHref({to:to},'a','/','/');// Once href is assigned, the returned href will be normalized to the full URL bits\nreturn{path:link.pathname,hash:link.hash,query:parseQuery(link.search)};}catch(e){/* istanbul ignore next */return{};}},resolveRoute:function resolveRoute(){var to=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';// Given a to (or href string), convert to normalized route location structure\n// works only when router available!!\ntry{var route=this.$router.resolve(to,this.$route).route;return{path:route.path,hash:route.hash,query:route.query};}catch(e){/* istanbul ignore next */return{};}},guessCurrentPage:function guessCurrentPage(){var guess=this.computedValue;var $router=this.$router;var $route=this.$route;// This section only occurs if we are client side, or server-side with $router\n/* istanbul ignore else */if(!this.noPageDetect&&!guess&&(inBrowser||!inBrowser&&$router)){// Current route (if router available)\nvar currRoute=$router?{path:$route.path,hash:$route.hash,query:$route.query}:{};// Current page full HREF (if client side). Can't be done as a computed prop!\nvar loc=inBrowser?window.location||document.location:null;var currLink=loc?{path:loc.pathname,hash:loc.hash,query:parseQuery(loc.search)}:{};// Loop through the possible pages looking for a match until found\nfor(var page=1;!guess&&page<=this.localNumPages;page++){var to=this.makeLink(page);if($router&&(isObject(to)||this.useRouter)){// Resolve the page via the $router\nguess=looseEqual(this.resolveRoute(to),currRoute)?page:null;}else if(inBrowser){// If no $router available (or !this.useRouter when `to` is a string)\n// we compare using parsed URIs\nguess=looseEqual(this.resolveLink(to),currLink)?page:null;}else{// probably SSR, but no $router so we can't guess, so lets break out of loop\n/* istanbul ignore next */guess=-1;}}}// We set currentPage to 0 to trigger an $emit('input', null)\n// As the default for this.currentPage is -1 when no value is specified\n// And valid page numbers are greater than 0\nthis.currentPage=guess>0?guess:0;}}};var components$u={BPaginationNav:BPaginationNav};var index$r={install:function install(Vue){registerComponents(Vue,components$u);}};var NAME='tooltip';var CLASS_PREFIX='bs-tooltip';var BS_CLASS_PREFIX_REGEX=new RegExp(\"\\\\b\".concat(CLASS_PREFIX,\"\\\\S+\"),'g');var TRANSITION_DURATION=150;// Modal $root hidden event\nvar MODAL_CLOSE_EVENT='bv::modal::hidden';// Modal container for appending tip/popover\nvar MODAL_CLASS='.modal-content';var AttachmentMap$1={AUTO:'auto',TOP:'top',RIGHT:'right',BOTTOM:'bottom',LEFT:'left',TOPLEFT:'top',TOPRIGHT:'top',RIGHTTOP:'right',RIGHTBOTTOM:'right',BOTTOMLEFT:'bottom',BOTTOMRIGHT:'bottom',LEFTTOP:'left',LEFTBOTTOM:'left'};var OffsetMap={AUTO:0,TOPLEFT:-1,TOP:0,TOPRIGHT:+1,RIGHTTOP:-1,RIGHT:0,RIGHTBOTTOM:+1,BOTTOMLEFT:-1,BOTTOM:0,BOTTOMRIGHT:+1,LEFTTOP:-1,LEFT:0,LEFTBOTTOM:+1};var HoverState={SHOW:'show',OUT:'out'};var ClassName={FADE:'fade',SHOW:'show'};var Selector$2={TOOLTIP:'.tooltip',TOOLTIP_INNER:'.tooltip-inner',ARROW:'.arrow'// ESLINT: Not used\n// const Trigger = {\n//   HOVER: 'hover',\n//   FOCUS: 'focus',\n//   CLICK: 'click',\n//   BLUR: 'blur',\n//   MANUAL: 'manual'\n// }\n};var Defaults$1={animation:true,template:'<div class=\"tooltip\" role=\"tooltip\">'+'<div class=\"arrow\"></div>'+'<div class=\"tooltip-inner\"></div>'+'</div>',trigger:'hover focus',title:'',delay:0,html:false,placement:'top',offset:0,arrowPadding:6,container:false,fallbackPlacement:'flip',callbacks:{},boundary:'scrollParent'// Transition Event names\n};var TransitionEndEvents$1={WebkitTransition:['webkitTransitionEnd'],MozTransition:['transitionend'],OTransition:['otransitionend','oTransitionEnd'],transition:['transitionend']// Client Side Tip ID counter for aria-describedby attribute\n// Could use Alex's uid generator util\n// Each tooltip requires a unique client side ID\n};var NEXTID=1;/* istanbul ignore next */var generateId=function generateId(name){return\"__BV_\".concat(name,\"_\").concat(NEXTID++,\"__\");};/*\n   * ToolTip Class definition\n   */ /* istanbul ignore next: difficult to test in Jest/JSDOM environment */var ToolTip=/*#__PURE__*/function(){// Main constructor\nfunction ToolTip(element,config,$root){_classCallCheck(this,ToolTip);// New tooltip object\nthis.$isEnabled=true;this.$fadeTimeout=null;this.$hoverTimeout=null;this.$visibleInterval=null;this.$hoverState='';this.$activeTrigger={};this.$popper=null;this.$element=element;this.$tip=null;this.$id=generateId(this.constructor.NAME);this.$root=$root||null;this.$routeWatcher=null;// We use a bound version of the following handlers for root/modal\n// listeners to maintain the 'this' context\nthis.$forceHide=this.forceHide.bind(this);this.$doHide=this.doHide.bind(this);this.$doShow=this.doShow.bind(this);this.$doDisable=this.doDisable.bind(this);this.$doEnable=this.doEnable.bind(this);// Set the configuration\nthis.updateConfig(config);}// NOTE: Overridden by PopOver class\n_createClass(ToolTip,[{key:\"updateConfig\",// Update config\nvalue:function updateConfig(config){// Merge config into defaults. We use \"this\" here because PopOver overrides Default\nvar updatedConfig=_objectSpread({},this.constructor.Default,config);// Sanitize delay\nif(config.delay&&typeof config.delay==='number'){updatedConfig.delay={show:config.delay,hide:config.delay};}// Title for tooltip and popover\nif(config.title&&typeof config.title==='number'){updatedConfig.title=config.title.toString();}// Content only for popover\nif(config.content&&typeof config.content==='number'){updatedConfig.content=config.content.toString();}// Hide element original title if needed\nthis.fixTitle();// Update the config\nthis.$config=updatedConfig;// Stop/Restart listening\nthis.unListen();this.listen();}// Destroy this instance\n},{key:\"destroy\",value:function destroy(){// Stop listening to trigger events\nthis.unListen();// Disable while open listeners/watchers\nthis.setWhileOpenListeners(false);// Clear any timeouts\nclearTimeout(this.$hoverTimeout);this.$hoverTimeout=null;clearTimeout(this.$fadeTimeout);this.$fadeTimeout=null;// Remove popper\nif(this.$popper){this.$popper.destroy();}this.$popper=null;// Remove tip from document\nif(this.$tip&&this.$tip.parentElement){this.$tip.parentElement.removeChild(this.$tip);}this.$tip=null;// Null out other properties\nthis.$id=null;this.$isEnabled=null;this.$root=null;this.$element=null;this.$config=null;this.$hoverState=null;this.$activeTrigger=null;this.$forceHide=null;this.$doHide=null;this.$doShow=null;this.$doDisable=null;this.$doEnable=null;}},{key:\"enable\",value:function enable(){// Create a non-cancelable BvEvent\nvar enabledEvt=new BvEvent('enabled',{cancelable:false,target:this.$element,relatedTarget:null});this.$isEnabled=true;this.emitEvent(enabledEvt);}},{key:\"disable\",value:function disable(){// Create a non-cancelable BvEvent\nvar disabledEvt=new BvEvent('disabled',{cancelable:false,target:this.$element,relatedTarget:null});this.$isEnabled=false;this.emitEvent(disabledEvt);}// Click toggler\n},{key:\"toggle\",value:function toggle(event){if(!this.$isEnabled){return;}if(event){this.$activeTrigger.click=!this.$activeTrigger.click;if(this.isWithActiveTrigger()){this.enter(null);}else{this.leave(null);}}else{if(hasClass(this.getTipElement(),ClassName.SHOW)){this.leave(null);}else{this.enter(null);}}}// Show tooltip\n},{key:\"show\",value:function show(){var _this=this;if(!document.body.contains(this.$element)||!isVisible(this.$element)){// If trigger element isn't in the DOM or is not visible\nreturn;}// Build tooltip element (also sets this.$tip)\nvar tip=this.getTipElement();this.fixTitle();this.setContent(tip);if(!this.isWithContent(tip)){// if No content, don't bother showing\nthis.$tip=null;return;}// Set ID on tip and aria-describedby on element\nsetAttr(tip,'id',this.$id);this.addAriaDescribedby();// Set animation on or off\nif(this.$config.animation){addClass(tip,ClassName.FADE);}else{removeClass(tip,ClassName.FADE);}var placement=this.getPlacement();var attachment=this.constructor.getAttachment(placement);this.addAttachmentClass(attachment);// Create a cancelable BvEvent\nvar showEvt=new BvEvent('show',{cancelable:true,target:this.$element,relatedTarget:tip});this.emitEvent(showEvt);if(showEvt.defaultPrevented){// Don't show if event cancelled\nthis.$tip=null;return;}// Insert tooltip if needed\nvar container=this.getContainer();if(!document.body.contains(tip)){container.appendChild(tip);}// Refresh popper\nthis.removePopper();this.$popper=new Popper(this.$element,tip,this.getPopperConfig(placement,tip));// Transitionend Callback\nvar complete=function complete(){if(_this.$config.animation){_this.fixTransition(tip);}var prevHoverState=_this.$hoverState;_this.$hoverState=null;if(prevHoverState===HoverState.OUT){_this.leave(null);}// Create a non-cancelable BvEvent\nvar shownEvt=new BvEvent('shown',{cancelable:false,target:_this.$element,relatedTarget:tip});_this.emitEvent(shownEvt);};// Enable while open listeners/watchers\nthis.setWhileOpenListeners(true);// Show tip\naddClass(tip,ClassName.SHOW);// Start the transition/animation\nthis.transitionOnce(tip,complete);}// handler for periodic visibility check\n},{key:\"visibleCheck\",value:function visibleCheck(on){var _this2=this;clearInterval(this.$visibleInterval);this.$visibleInterval=null;if(on){this.$visibleInterval=setInterval(function(){var tip=_this2.getTipElement();if(tip&&!isVisible(_this2.$element)&&hasClass(tip,ClassName.SHOW)){// Element is no longer visible, so force-hide the tooltip\n_this2.forceHide();}},100);}}},{key:\"setWhileOpenListeners\",value:function setWhileOpenListeners(on){// Modal close events\nthis.setModalListener(on);// Periodic $element visibility check\n// For handling when tip is in <keepalive>, tabs, carousel, etc\nthis.visibleCheck(on);// Route change events\nthis.setRouteWatcher(on);// On-touch start listeners\nthis.setOnTouchStartListener(on);if(on&&/(focus|blur)/.test(this.$config.trigger)){// If focus moves between trigger element and tip container, dont close\neventOn(this.$tip,'focusout',this);}else{eventOff(this.$tip,'focusout',this);}}// force hide of tip (internal method)\n},{key:\"forceHide\",value:function forceHide(){if(!this.$tip||!hasClass(this.$tip,ClassName.SHOW)){return;}// Disable while open listeners/watchers\nthis.setWhileOpenListeners(false);// Clear any hover enter/leave event\nclearTimeout(this.$hoverTimeout);this.$hoverTimeout=null;this.$hoverState='';// Hide the tip\nthis.hide(null,true);}// Hide tooltip\n},{key:\"hide\",value:function hide(callback,force){var _this3=this;var tip=this.$tip;if(!tip){return;}// Create a cancelable BvEvent\nvar hideEvt=new BvEvent('hide',{// We disable cancelling if force is true\ncancelable:!force,target:this.$element,relatedTarget:tip});this.emitEvent(hideEvt);if(hideEvt.defaultPrevented){// Don't hide if event cancelled\nreturn;}// Transitionend Callback\n/* istanbul ignore next */var complete=function complete(){if(_this3.$hoverState!==HoverState.SHOW&&tip.parentNode){// Remove tip from dom, and force recompile on next show\ntip.parentNode.removeChild(tip);_this3.removeAriaDescribedby();_this3.removePopper();_this3.$tip=null;}if(callback){callback();}// Create a non-cancelable BvEvent\nvar hiddenEvt=new BvEvent('hidden',{cancelable:false,target:_this3.$element,relatedTarget:null});_this3.emitEvent(hiddenEvt);};// Disable while open listeners/watchers\nthis.setWhileOpenListeners(false);// If forced close, disable animation\nif(force){removeClass(tip,ClassName.FADE);}// Hide tip\nremoveClass(tip,ClassName.SHOW);this.$activeTrigger.click=false;this.$activeTrigger.focus=false;this.$activeTrigger.hover=false;// Start the hide transition\nthis.transitionOnce(tip,complete);this.$hoverState='';}},{key:\"emitEvent\",value:function emitEvent(evt){var evtName=evt.type;if(this.$root&&this.$root.$emit){// Emit an event on $root\nthis.$root.$emit(\"bv::\".concat(this.constructor.NAME,\"::\").concat(evtName),evt);}var callbacks=this.$config.callbacks||{};if(typeof callbacks[evtName]==='function'){callbacks[evtName](evt);}}},{key:\"getContainer\",value:function getContainer(){var container=this.$config.container;var body=document.body;// If we are in a modal, we append to the modal instead of body, unless a container is specified\nreturn container===false?closest(MODAL_CLASS,this.$element)||body:select(container,body)||body;}// Will be overridden by popover if needed\n},{key:\"addAriaDescribedby\",value:function addAriaDescribedby(){// Add aria-describedby on trigger element, without removing any other IDs\nvar desc=getAttr(this.$element,'aria-describedby')||'';desc=desc.split(/\\s+/).concat(this.$id).join(' ').trim();setAttr(this.$element,'aria-describedby',desc);}// Will be overridden by popover if needed\n},{key:\"removeAriaDescribedby\",value:function removeAriaDescribedby(){var _this4=this;var desc=getAttr(this.$element,'aria-describedby')||'';desc=desc.split(/\\s+/).filter(function(d){return d!==_this4.$id;}).join(' ').trim();if(desc){setAttr(this.$element,'aria-describedby',desc);}else{removeAttr(this.$element,'aria-describedby');}}},{key:\"removePopper\",value:function removePopper(){if(this.$popper){this.$popper.destroy();}this.$popper=null;}/* istanbul ignore next */},{key:\"transitionOnce\",value:function transitionOnce(tip,complete){var _this5=this;var transEvents=this.getTransitionEndEvents();var called=false;clearTimeout(this.$fadeTimeout);this.$fadeTimeout=null;var fnOnce=function fnOnce(){if(called){return;}called=true;clearTimeout(_this5.$fadeTimeout);_this5.$fadeTimeout=null;transEvents.forEach(function(evtName){eventOff(tip,evtName,fnOnce);});// Call complete callback\ncomplete();};if(hasClass(tip,ClassName.FADE)){transEvents.forEach(function(evtName){eventOn(tip,evtName,fnOnce);});// Fallback to setTimeout\nthis.$fadeTimeout=setTimeout(fnOnce,TRANSITION_DURATION);}else{fnOnce();}}// What transitionend event(s) to use? (returns array of event names)\n},{key:\"getTransitionEndEvents\",value:function getTransitionEndEvents(){for(var name in TransitionEndEvents$1){if(this.$element.style[name]!==undefined){return TransitionEndEvents$1[name];}}// Fallback\nreturn[];}},{key:\"update\",value:function update(){if(this.$popper!==null){this.$popper.scheduleUpdate();}}// NOTE: Overridden by PopOver class\n},{key:\"isWithContent\",value:function isWithContent(tip){tip=tip||this.$tip;if(!tip){return false;}return Boolean((select(Selector$2.TOOLTIP_INNER,tip)||{}).innerHTML);}// NOTE: Overridden by PopOver class\n},{key:\"addAttachmentClass\",value:function addAttachmentClass(attachment){addClass(this.getTipElement(),\"\".concat(CLASS_PREFIX,\"-\").concat(attachment));}},{key:\"getTipElement\",value:function getTipElement(){if(!this.$tip){// Try and compile user supplied template, or fallback to default template\nthis.$tip=this.compileTemplate(this.$config.template)||this.compileTemplate(this.constructor.Default.template);}// Add tab index so tip can be focused, and to allow it to be\n// set as relatedTarget in focusin/out events\nthis.$tip.tabIndex=-1;return this.$tip;}},{key:\"compileTemplate\",value:function compileTemplate(html){if(!html||typeof html!=='string'){return null;}var div=document.createElement('div');div.innerHTML=html.trim();var node=div.firstElementChild?div.removeChild(div.firstElementChild):null;div=null;return node;}// NOTE: Overridden by PopOver class\n},{key:\"setContent\",value:function setContent(tip){this.setElementContent(select(Selector$2.TOOLTIP_INNER,tip),this.getTitle());removeClass(tip,ClassName.FADE);removeClass(tip,ClassName.SHOW);}},{key:\"setElementContent\",value:function setElementContent(container,content){if(!container){// If container element doesn't exist, just return\nreturn;}var allowHtml=this.$config.html;if(_typeof(content)==='object'&&content.nodeType){// content is a DOM node\nif(allowHtml){if(content.parentElement!==container){container.innerHTML='';container.appendChild(content);}}else{container.innerText=content.innerText;}}else{// We have a plain HTML string or Text\ncontainer[allowHtml?'innerHTML':'innerText']=content;}}// NOTE: Overridden by PopOver class\n},{key:\"getTitle\",value:function getTitle(){var title=this.$config.title||'';if(typeof title==='function'){// Call the function to get the title value\ntitle=title(this.$element);}if(_typeof(title)==='object'&&title.nodeType&&!title.innerHTML.trim()){// We have a DOM node, but without inner content, so just return empty string\ntitle='';}if(typeof title==='string'){title=title.trim();}if(!title){// If an explicit title is not given, try element's title attributes\ntitle=getAttr(this.$element,'title')||getAttr(this.$element,'data-original-title')||'';title=title.trim();}return title;}},{key:\"listen\",value:function listen(){var _this6=this;var triggers=this.$config.trigger.trim().split(/\\s+/);var el=this.$element;// Listen for global show/hide events\nthis.setRootListener(true);// Using 'this' as the handler will get automatically directed to this.handleEvent\n// And maintain our binding to 'this'\ntriggers.forEach(function(trigger){if(trigger==='click'){eventOn(el,'click',_this6);}else if(trigger==='focus'){eventOn(el,'focusin',_this6);eventOn(el,'focusout',_this6);}else if(trigger==='blur'){// Used to close $tip when element looses focus\neventOn(el,'focusout',_this6);}else if(trigger==='hover'){eventOn(el,'mouseenter',_this6);eventOn(el,'mouseleave',_this6);}},this);}},{key:\"unListen\",value:function unListen(){var _this7=this;var events=['click','focusin','focusout','mouseenter','mouseleave'];// Using \"this\" as the handler will get automatically directed to this.handleEvent\nevents.forEach(function(evt){eventOff(_this7.$element,evt,_this7);},this);// Stop listening for global show/hide/enable/disable events\nthis.setRootListener(false);}},{key:\"handleEvent\",value:function handleEvent(e){// This special method allows us to use \"this\" as the event handlers\nif(isDisabled(this.$element)){// If disabled, don't do anything. Note: if tip is shown before element gets\n// disabled, then tip not close until no longer disabled or forcefully closed.\nreturn;}if(!this.$isEnabled){// If not enable\nreturn;}var type=e.type;var target=e.target;var relatedTarget=e.relatedTarget;var $element=this.$element;var $tip=this.$tip;if(type==='click'){this.toggle(e);}else if(type==='focusin'||type==='mouseenter'){this.enter(e);}else if(type==='focusout'){// target is the element which is loosing focus\n// And relatedTarget is the element gaining focus\nif($tip&&$element&&$element.contains(target)&&$tip.contains(relatedTarget)){// If focus moves from $element to $tip, don't trigger a leave\nreturn;}if($tip&&$element&&$tip.contains(target)&&$element.contains(relatedTarget)){// If focus moves from $tip to $element, don't trigger a leave\nreturn;}if($tip&&$tip.contains(target)&&$tip.contains(relatedTarget)){// If focus moves within $tip, don't trigger a leave\nreturn;}if($element&&$element.contains(target)&&$element.contains(relatedTarget)){// If focus moves within $element, don't trigger a leave\nreturn;}// Otherwise trigger a leave\nthis.leave(e);}else if(type==='mouseleave'){this.leave(e);}}/* istanbul ignore next */},{key:\"setRouteWatcher\",value:function setRouteWatcher(on){var _this8=this;if(on){this.setRouteWatcher(false);if(this.$root&&Boolean(this.$root.$route)){this.$routeWatcher=this.$root.$watch('$route',function(newVal,oldVal){if(newVal===oldVal){return;}// If route has changed, we force hide the tooltip/popover\n_this8.forceHide();});}}else{if(this.$routeWatcher){// cancel the route watcher by calling the stored reference\nthis.$routeWatcher();this.$routeWatcher=null;}}}/* istanbul ignore next */},{key:\"setModalListener\",value:function setModalListener(on){var modal=closest(MODAL_CLASS,this.$element);if(!modal){// If we are not in a modal, don't worry. be happy\nreturn;}// We can listen for modal hidden events on $root\nif(this.$root){this.$root[on?'$on':'$off'](MODAL_CLOSE_EVENT,this.$forceHide);}}/* istanbul ignore next */},{key:\"setRootListener\",value:function setRootListener(on){// Listen for global 'bv::{hide|show}::{tooltip|popover}' hide request event\nif(this.$root){this.$root[on?'$on':'$off'](\"bv::hide::\".concat(this.constructor.NAME),this.$doHide);this.$root[on?'$on':'$off'](\"bv::show::\".concat(this.constructor.NAME),this.$doShow);this.$root[on?'$on':'$off'](\"bv::disable::\".concat(this.constructor.NAME),this.$doDisable);this.$root[on?'$on':'$off'](\"bv::enable::\".concat(this.constructor.NAME),this.$doEnable);}}},{key:\"doHide\",value:function doHide(id){// Programmatically hide tooltip or popover\nif(!id){// Close all tooltips or popovers\nthis.forceHide();}else if(this.$element&&this.$element.id&&this.$element.id===id){// Close this specific tooltip or popover\nthis.hide();}}},{key:\"doShow\",value:function doShow(id){// Programmatically show tooltip or popover\nif(!id){// Open all tooltips or popovers\nthis.show();}else if(id&&this.$element&&this.$element.id&&this.$element.id===id){// Show this specific tooltip or popover\nthis.show();}}},{key:\"doDisable\",value:function doDisable(id){// Programmatically disable tooltip or popover\nif(!id){// Disable all tooltips or popovers\nthis.disable();}else if(this.$element&&this.$element.id&&this.$element.id===id){// Disable this specific tooltip or popover\nthis.disable();}}},{key:\"doEnable\",value:function doEnable(id){// Programmatically enable tooltip or popover\nif(!id){// Enable all tooltips or popovers\nthis.enable();}else if(this.$element&&this.$element.id&&this.$element.id===id){// Enable this specific tooltip or popover\nthis.enable();}}/* istanbul ignore next */},{key:\"setOnTouchStartListener\",value:function setOnTouchStartListener(on){var _this9=this;// if this is a touch-enabled device we add extra\n// empty mouseover listeners to the body's immediate children;\n// only needed because of broken event delegation on iOS\n// https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\nif('ontouchstart'in document.documentElement){from(document.body.children).forEach(function(el){if(on){eventOn(el,'mouseover',_this9._noop);}else{eventOff(el,'mouseover',_this9._noop);}});}}/* istanbul ignore next */},{key:\"_noop\",value:function _noop(){// Empty noop handler for ontouchstart devices\n}},{key:\"fixTitle\",value:function fixTitle(){var el=this.$element;var titleType=_typeof(getAttr(el,'data-original-title'));if(getAttr(el,'title')||titleType!=='string'){setAttr(el,'data-original-title',getAttr(el,'title')||'');setAttr(el,'title','');}}// Enter handler\n/* istanbul ignore next */},{key:\"enter\",value:function enter(e){var _this10=this;if(e){this.$activeTrigger[e.type==='focusin'?'focus':'hover']=true;}if(hasClass(this.getTipElement(),ClassName.SHOW)||this.$hoverState===HoverState.SHOW){this.$hoverState=HoverState.SHOW;return;}clearTimeout(this.$hoverTimeout);this.$hoverState=HoverState.SHOW;if(!this.$config.delay||!this.$config.delay.show){this.show();return;}this.$hoverTimeout=setTimeout(function(){if(_this10.$hoverState===HoverState.SHOW){_this10.show();}},this.$config.delay.show);}// Leave handler\n/* istanbul ignore next */},{key:\"leave\",value:function leave(e){var _this11=this;if(e){this.$activeTrigger[e.type==='focusout'?'focus':'hover']=false;if(e.type==='focusout'&&/blur/.test(this.$config.trigger)){// Special case for `blur`: we clear out the other triggers\nthis.$activeTrigger.click=false;this.$activeTrigger.hover=false;}}if(this.isWithActiveTrigger()){return;}clearTimeout(this.$hoverTimeout);this.$hoverState=HoverState.OUT;if(!this.$config.delay||!this.$config.delay.hide){this.hide();return;}this.$hoverTimeout=setTimeout(function(){if(_this11.$hoverState===HoverState.OUT){_this11.hide();}},this.$config.delay.hide);}},{key:\"getPopperConfig\",value:function getPopperConfig(placement,tip){var _this12=this;return{placement:this.constructor.getAttachment(placement),modifiers:{offset:{offset:this.getOffset(placement,tip)},flip:{behavior:this.$config.fallbackPlacement},arrow:{element:'.arrow'},preventOverflow:{padding:this.$config.boundaryPadding,boundariesElement:this.$config.boundary}},onCreate:function onCreate(data){// Handle flipping arrow classes\nif(data.originalPlacement!==data.placement){_this12.handlePopperPlacementChange(data);}},onUpdate:function onUpdate(data){// Handle flipping arrow classes\n_this12.handlePopperPlacementChange(data);}};}},{key:\"getOffset\",value:function getOffset(placement,tip){if(!this.$config.offset){var arrow=select(Selector$2.ARROW,tip);var arrowOffset=parseFloat(getCS(arrow).width)+parseFloat(this.$config.arrowPadding);switch(OffsetMap[placement.toUpperCase()]){case+1:return\"+50%p - \".concat(arrowOffset,\"px\");case-1:return\"-50%p + \".concat(arrowOffset,\"px\");default:return 0;}}return this.$config.offset;}},{key:\"getPlacement\",value:function getPlacement(){var placement=this.$config.placement;if(typeof placement==='function'){return placement.call(this,this.$tip,this.$element);}return placement;}},{key:\"isWithActiveTrigger\",value:function isWithActiveTrigger(){for(var trigger in this.$activeTrigger){if(this.$activeTrigger[trigger]){return true;}}return false;}// NOTE: Overridden by PopOver class\n},{key:\"cleanTipClass\",value:function cleanTipClass(){var tip=this.getTipElement();var tabClass=tip.className.match(BS_CLASS_PREFIX_REGEX);if(tabClass!==null&&tabClass.length>0){tabClass.forEach(function(cls){removeClass(tip,cls);});}}},{key:\"handlePopperPlacementChange\",value:function handlePopperPlacementChange(data){this.cleanTipClass();this.addAttachmentClass(this.constructor.getAttachment(data.placement));}},{key:\"fixTransition\",value:function fixTransition(tip){var initConfigAnimation=this.$config.animation||false;if(getAttr(tip,'x-placement')!==null){return;}removeClass(tip,ClassName.FADE);this.$config.animation=false;this.hide();this.show();this.$config.animation=initConfigAnimation;}}],[{key:\"getAttachment\",value:function getAttachment(placement){return AttachmentMap$1[placement.toUpperCase()];}},{key:\"Default\",get:function get(){return Defaults$1;}// NOTE: Overridden by PopOver class\n},{key:\"NAME\",get:function get(){return NAME;}}]);return ToolTip;}();var NAME$1='popover';var CLASS_PREFIX$1='bs-popover';var BS_CLASS_PREFIX_REGEX$1=new RegExp(\"\\\\b\".concat(CLASS_PREFIX$1,\"\\\\S+\"),'g');var Defaults$2=_objectSpread({},ToolTip.Default,{placement:'right',trigger:'click',content:'',template:'<div class=\"popover\" role=\"tooltip\">'+'<div class=\"arrow\"></div>'+'<h3 class=\"popover-header\"></h3>'+'<div class=\"popover-body\"></div></div>'});var ClassName$1={FADE:'fade',SHOW:'show'};var Selector$3={TITLE:'.popover-header',CONTENT:'.popover-body'/* istanbul ignore next: dificult to test in Jest/JSDOM environment */};var PopOver=/*#__PURE__*/function(_ToolTip){_inherits(PopOver,_ToolTip);function PopOver(){_classCallCheck(this,PopOver);return _possibleConstructorReturn(this,_getPrototypeOf(PopOver).apply(this,arguments));}_createClass(PopOver,[{key:\"isWithContent\",// Method overrides\nvalue:function isWithContent(tip)/* istanbul ignore next */{tip=tip||this.$tip;if(!tip){return false;}var hasTitle=Boolean((select(Selector$3.TITLE,tip)||{}).innerHTML);var hasContent=Boolean((select(Selector$3.CONTENT,tip)||{}).innerHTML);return hasTitle||hasContent;}},{key:\"addAttachmentClass\",value:function addAttachmentClass(attachment)/* istanbul ignore next */{addClass(this.getTipElement(),\"\".concat(CLASS_PREFIX$1,\"-\").concat(attachment));}},{key:\"setContent\",value:function setContent(tip)/* istanbul ignore next */{// we use append for html objects to maintain js events/components\nthis.setElementContent(select(Selector$3.TITLE,tip),this.getTitle());this.setElementContent(select(Selector$3.CONTENT,tip),this.getContent());removeClass(tip,ClassName$1.FADE);removeClass(tip,ClassName$1.SHOW);}// This method may look identical to ToolTip version, but it uses a different RegEx defined above\n},{key:\"cleanTipClass\",value:function cleanTipClass()/* istanbul ignore next */{var tip=this.getTipElement();var tabClass=tip.className.match(BS_CLASS_PREFIX_REGEX$1);if(tabClass!==null&&tabClass.length>0){tabClass.forEach(function(cls){removeClass(tip,cls);});}}},{key:\"getTitle\",value:function getTitle()/* istanbul ignore next */{var title=this.$config.title||'';if(typeof title==='function'){title=title(this.$element);}if(_typeof(title)==='object'&&title.nodeType&&!title.innerHTML.trim()){// We have a dom node, but without inner content, so just return an empty string\ntitle='';}if(typeof title==='string'){title=title.trim();}if(!title){// Try and grab element's title attribute\ntitle=getAttr(this.$element,'title')||getAttr(this.$element,'data-original-title')||'';title=title.trim();}return title;}// New methods\n},{key:\"getContent\",value:function getContent()/* istanbul ignore next */{var content=this.$config.content||'';if(typeof content==='function'){content=content(this.$element);}if(_typeof(content)==='object'&&content.nodeType&&!content.innerHTML.trim()){// We have a dom node, but without inner content, so just return an empty string\ncontent='';}if(typeof content==='string'){content=content.trim();}return content;}}],[{key:\"Default\",// Getter overrides\nget:function get()/* istanbul ignore next */{return Defaults$2;}},{key:\"NAME\",get:function get()/* istanbul ignore next */{return NAME$1;}}]);return PopOver;}(ToolTip);// Polyfills for SSR\nvar isSSR=typeof window==='undefined';var HTMLElement=isSSR?Object:window.HTMLElement;var PLACEMENTS={top:'top',topleft:'topleft',topright:'topright',right:'right',righttop:'righttop',rightbottom:'rightbottom',bottom:'bottom',bottomleft:'bottomleft',bottomright:'bottomright',left:'left',lefttop:'lefttop',leftbottom:'leftbottom',auto:'auto'};var OBSERVER_CONFIG$1={subtree:true,childList:true,characterData:true,attributes:true,attributeFilter:['class','style']// @vue/component\n};var toolpopMixin={props:{target:{// String ID of element, or element/component reference\ntype:[String,Object,HTMLElement,Function]// default: undefined\n},delay:{type:[Number,Object,String],default:0},offset:{type:[Number,String],default:0},noFade:{type:Boolean,default:false},container:{// String ID of container, if null body is used (default)\ntype:String,default:null},boundary:{// String: scrollParent, window, or viewport\n// Element: element reference\ntype:[String,HTMLElement],default:'scrollParent'},boundaryPadding:{type:Number,default:5},show:{type:Boolean,default:false},disabled:{type:Boolean,default:false}},computed:{baseConfig:function baseConfig(){var cont=this.container;var delay=_typeof(this.delay)==='object'?this.delay:parseInt(this.delay,10)||0;return{// Title prop\ntitle:(this.title||'').trim()||'',// Contnt prop (if popover)\ncontent:(this.content||'').trim()||'',// Tooltip/Popover placement\nplacement:PLACEMENTS[this.placement]||'auto',// Container curently needs to be an ID with '#' prepended, if null then body is used\ncontainer:cont?/^#/.test(cont)?cont:\"#\".concat(cont):false,// boundariesElement passed to popper\nboundary:this.boundary,// boundariesElement padding passed to popper\nboundaryPadding:this.boundaryPadding,// Show/Hide delay\ndelay:delay||0,// Offset can be css distance. if no units, pixels are assumed\noffset:this.offset||0,// Disable fade Animation?\nanimation:!this.noFade,// Open/Close Trigger(s)\ntrigger:isArray(this.triggers)?this.triggers.join(' '):this.triggers,// Callbacks so we can trigger events on component\ncallbacks:{show:this.onShow,shown:this.onShown,hide:this.onHide,hidden:this.onHidden,enabled:this.onEnabled,disabled:this.onDisabled}};}},watch:{show:function show(_show,old){/* istanbul ignore if */if(_show===old){/* istanbul ignore next */return;}_show?this.onOpen():this.onClose();},disabled:function disabled(_disabled,old){/* istanbul ignore if */if(_disabled===old){/* istanbul ignore next */return;}_disabled?this.onDisable():this.onEnable();}},created:function created(){// Create non-reactive property\nthis._toolpop=null;this._obs_title=null;this._obs_content=null;},mounted:function mounted(){var _this=this;// We do this in a next tick to ensure DOM has rendered first\nthis.$nextTick(function(){// Instantiate ToolTip/PopOver on target\n// The createToolpop method must exist in main component\nif(_this.createToolpop()){if(_this.disabled){// Initially disabled\n_this.onDisable();}// Listen to open signals from others\n_this.$on('open',_this.onOpen);// Listen to close signals from others\n_this.$on('close',_this.onClose);// Listen to disable signals from others\n_this.$on('disable',_this.onDisable);// Listen to disable signals from others\n_this.$on('enable',_this.onEnable);// Observe content Child changes so we can notify popper of possible size change\n_this.setObservers(true);// Set intially open state\nif(_this.show){_this.onOpen();}}});},updated:function updated(){// If content/props changes, etc\n/* istanbul ignore next: can't test in JSDOM */if(this._toolpop){this._toolpop.updateConfig(this.getConfig());}},activated:function activated(){// Called when component is inside a <keep-alive> and component brought offline\n/* istanbul ignore next: can't test in JSDOM */this.setObservers(true);},deactivated:function deactivated(){// Called when component is inside a <keep-alive> and component taken offline\n/* istanbul ignore next: can't test in JSDOM */if(this._toolpop){this.setObservers(false);this._toolpop.hide();}},beforeDestroy:function beforeDestroy()/* istanbul ignore next: not easy to test */{// Shutdown our local event listeners\nthis.$off('open',this.onOpen);this.$off('close',this.onClose);this.$off('disable',this.onDisable);this.$off('enable',this.onEnable);this.setObservers(false);// bring our content back if needed\nthis.bringItBack();if(this._toolpop){this._toolpop.destroy();this._toolpop=null;}},methods:{getConfig:function getConfig(){var cfg=_objectSpread({},this.baseConfig);if(this.$refs.title&&this.$refs.title.innerHTML.trim()){// If slot has content, it overrides 'title' prop\n// We use the DOM node as content to allow components!\ncfg.title=this.$refs.title;cfg.html=true;}if(this.$refs.content&&this.$refs.content.innerHTML.trim()){// If slot has content, it overrides 'content' prop\n// We use the DOM node as content to allow components!\ncfg.content=this.$refs.content;cfg.html=true;}return cfg;},onOpen:function onOpen(){if(this._toolpop){this._toolpop.show();}},onClose:function onClose(callback){if(this._toolpop){this._toolpop.hide(callback);}else if(typeof callback==='function'){callback();}},onDisable:function onDisable(){/* istanbul ignore next: can't test in JSDOM */if(this._toolpop){this._toolpop.disable();}},onEnable:function onEnable(){/* istanbul ignore next: can't test in JSDOM */if(this._toolpop){this._toolpop.enable();}},updatePosition:function updatePosition(){/* istanbul ignore next: can't test in JSDOM */if(this._toolpop){// Instruct popper to reposition popover if necessary\nthis._toolpop.update();}},getTarget:function getTarget(){var target=this.target;if(typeof target==='function'){target=target();}if(typeof target==='string'){// Assume ID of element\nreturn getById(target);}else if(_typeof(target)==='object'&&isElement(target.$el)){// Component reference\nreturn target.$el;}else if(_typeof(target)==='object'&&isElement(target)){// Element reference\nreturn target;}return null;},onShow:function onShow(evt){this.$emit('show',evt);},onShown:function onShown(evt){this.setObservers(true);this.$emit('update:show',true);this.$emit('shown',evt);},onHide:function onHide(evt){this.$emit('hide',evt);},onHidden:function onHidden(evt){this.setObservers(false);// bring our content back if needed to keep Vue happy\n// Tooltip class will move it back to tip when shown again\nthis.bringItBack();this.$emit('update:show',false);this.$emit('hidden',evt);},onEnabled:function onEnabled(evt){if(!evt||evt.type!=='enabled'){// Prevent possible endless loop if user mistakienly fires enabled instead of enable\nreturn;}this.$emit('update:disabled',false);this.$emit('disabled');},onDisabled:function onDisabled(evt){if(!evt||evt.type!=='disabled'){// Prevent possible endless loop if user mistakienly fires disabled instead of disable\nreturn;}this.$emit('update:disabled',true);this.$emit('enabled');},bringItBack:function bringItBack(){// bring our content back if needed to keep Vue happy\nif(this.$el&&this.$refs.title){this.$el.appendChild(this.$refs.title);}if(this.$el&&this.$refs.content){this.$el.appendChild(this.$refs.content);}},setObservers:function setObservers(on)/* istanbul ignore next: can't test in JSDOM */{if(on){if(this.$refs.title){this._obs_title=observeDom(this.$refs.title,this.updatePosition.bind(this),OBSERVER_CONFIG$1);}if(this.$refs.content){this._obs_content=observeDom(this.$refs.content,this.updatePosition.bind(this),OBSERVER_CONFIG$1);}}else{if(this._obs_title){this._obs_title.disconnect();this._obs_title=null;}if(this._obs_content){this._obs_content.disconnect();this._obs_content=null;}}}}};var BPopover={name:'BPopover',mixins:[toolpopMixin],props:{title:{type:String,default:''},content:{type:String,default:''},triggers:{type:[String,Array],default:'click'},placement:{type:String,default:'right'}},data:function data(){return{};},methods:{createToolpop:function createToolpop(){// getTarget is in toolpop mixin\nvar target=this.getTarget();if(target){this._toolpop=new PopOver(target,this.getConfig(),this.$root);}else{this._toolpop=null;warn(\"b-popover: 'target' element not found!\");}return this._toolpop;}},render:function render(h){return h('div',{class:['d-none'],style:{display:'none'},attrs:{'aria-hidden':true}},[h('div',{ref:'title'},this.$slots.title),h('div',{ref:'content'},this.$slots.default)]);}};var inBrowser$2=typeof window!=='undefined'&&typeof document!=='undefined';// Key which we use to store tooltip object on element\nvar BVPO='__BV_PopOver__';// Valid event triggers\nvar validTriggers={focus:true,hover:true,click:true,blur:true// Build a PopOver config based on bindings (if any)\n// Arguments and modifiers take precedence over pased value config object\n/* istanbul ignore next: not easy to test */};function parseBindings(bindings){// We start out with a blank config\nvar config={};// Process bindings.value\nif(typeof bindings.value==='string'){// Value is popover content (html optionally supported)\nconfig.content=bindings.value;}else if(typeof bindings.value==='function'){// Content generator function\nconfig.content=bindings.value;}else if(_typeof(bindings.value)==='object'){// Value is config object, so merge\nconfig=_objectSpread({},config,bindings.value);}// If Argument, assume element ID of container element\nif(bindings.arg){// Element ID specified as arg. We must prepend '#' to become a CSS selector\nconfig.container=\"#\".concat(bindings.arg);}// Process modifiers\nkeys(bindings.modifiers).forEach(function(mod){if(/^html$/.test(mod)){// Title allows HTML\nconfig.html=true;}else if(/^nofade$/.test(mod)){// no animation\nconfig.animation=false;}else if(/^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/.test(mod)){// placement of popover\nconfig.placement=mod;}else if(/^(window|viewport)$/.test(mod)){// bounday of popover\nconfig.boundary=mod;}else if(/^d\\d+$/.test(mod)){// delay value\nvar delay=parseInt(mod.slice(1),10)||0;if(delay){config.delay=delay;}}else if(/^o-?\\d+$/.test(mod)){// offset value (negative allowed)\nvar offset=parseInt(mod.slice(1),10)||0;if(offset){config.offset=offset;}}});// Special handling of event trigger modifiers Trigger is a space separated list\nvar selectedTriggers={};// parse current config object trigger\nvar triggers=typeof config.trigger==='string'?config.trigger.trim().split(/\\s+/):[];triggers.forEach(function(trigger){if(validTriggers[trigger]){selectedTriggers[trigger]=true;}});// Parse Modifiers for triggers\nkeys(validTriggers).forEach(function(trigger){if(bindings.modifiers[trigger]){selectedTriggers[trigger]=true;}});// Sanitize triggers\nconfig.trigger=keys(selectedTriggers).join(' ');if(config.trigger==='blur'){// Blur by itself is useless, so convert it to focus\nconfig.trigger='focus';}if(!config.trigger){// remove trigger config\ndelete config.trigger;}return config;}//\n// Add or Update popover on our element\n//\n/* istanbul ignore next: not easy to test */function applyBVPO(el,bindings,vnode){if(!inBrowser$2){return;}if(!Popper){// Popper is required for tooltips to work\nwarn('v-b-popover: Popper.js is required for popovers to work');return;}if(el[BVPO]){el[BVPO].updateConfig(parseBindings(bindings));}else{el[BVPO]=new PopOver(el,parseBindings(bindings),vnode.context.$root);}}//\n// Remove popover on our element\n//\n/* istanbul ignore next */function removeBVPO(el){if(!inBrowser$2){return;}if(el[BVPO]){el[BVPO].destroy();el[BVPO]=null;delete el[BVPO];}}/*\n   * Export our directive\n   */ /* istanbul ignore next: not easy to test */var bPopover={bind:function bind(el,bindings,vnode){applyBVPO(el,bindings,vnode);},inserted:function inserted(el,bindings,vnode){applyBVPO(el,bindings,vnode);},update:function update(el,bindings,vnode){if(bindings.value!==bindings.oldValue){applyBVPO(el,bindings,vnode);}},componentUpdated:function componentUpdated(el,bindings,vnode){if(bindings.value!==bindings.oldValue){applyBVPO(el,bindings,vnode);}},unbind:function unbind(el){removeBVPO(el);}};var directives$2={bPopover:bPopover};var popoverDirectivePlugin={install:function install(Vue){registerDirectives(Vue,directives$2);}};var components$v={BPopover:BPopover};var index$s={install:function install(Vue){registerComponents(Vue,components$v);Vue.use(popoverDirectivePlugin);}};var BProgressBar={name:'BProgressBar',inject:{bvProgress:{default:function _default()/* istanbul ignore next */{return{};}}},props:{value:{type:Number,default:0},label:{type:String,default:null},labelHtml:{type:String},// $parent (this.bvProgress) prop values may take precedence over the following props\n// Which is why they are defaulted to null\nmax:{type:Number,default:null},precision:{type:Number,default:null},variant:{type:String,default:null},striped:{type:Boolean,default:null},animated:{type:Boolean,default:null},showProgress:{type:Boolean,default:null},showValue:{type:Boolean,default:null}},computed:{progressBarClasses:function progressBarClasses(){return[this.computedVariant?\"bg-\".concat(this.computedVariant):'',this.computedStriped||this.computedAnimated?'progress-bar-striped':'',this.computedAnimated?'progress-bar-animated':''];},progressBarStyles:function progressBarStyles(){return{width:100*(this.value/this.computedMax)+'%'};},computedProgress:function computedProgress(){var p=Math.pow(10,this.computedPrecision);return Math.round(100*p*this.value/this.computedMax)/p;},computedMax:function computedMax(){// Prefer our max over parent setting\nreturn typeof this.max==='number'?this.max:this.bvProgress.max||100;},computedVariant:function computedVariant(){// Prefer our variant over parent setting\nreturn this.variant||this.bvProgress.variant;},computedPrecision:function computedPrecision(){// Prefer our precision over parent setting\nreturn typeof this.precision==='number'?this.precision:this.bvProgress.precision||0;},computedStriped:function computedStriped(){// Prefer our striped over parent setting\nreturn typeof this.striped==='boolean'?this.striped:this.bvProgress.striped||false;},computedAnimated:function computedAnimated(){// Prefer our animated over parent setting\nreturn typeof this.animated==='boolean'?this.animated:this.bvProgress.animated||false;},computedShowProgress:function computedShowProgress(){// Prefer our showProgress over parent setting\nreturn typeof this.showProgress==='boolean'?this.showProgress:this.bvProgress.showProgress||false;},computedShowValue:function computedShowValue(){// Prefer our showValue over parent setting\nreturn typeof this.showValue==='boolean'?this.showValue:this.bvProgress.showValue||false;}},render:function render(h){var childNodes=h(false);if(this.$slots.default){childNodes=this.$slots.default;}else if(this.label||this.labelHtml){childNodes=h('span',{domProps:htmlOrText(this.labelHtml,this.label)});}else if(this.computedShowProgress){childNodes=this.computedProgress.toFixed(this.computedPrecision);}else if(this.computedShowValue){childNodes=this.value.toFixed(this.computedPrecision);}return h('div',{staticClass:'progress-bar',class:this.progressBarClasses,style:this.progressBarStyles,attrs:{role:'progressbar','aria-valuemin':'0','aria-valuemax':this.computedMax.toString(),'aria-valuenow':this.value.toFixed(this.computedPrecision)}},[childNodes]);}};var BProgress={name:'BProgress',components:{BProgressBar:BProgressBar},provide:function provide(){return{bvProgress:this};},props:{// These props can be inherited via the child b-progress-bar(s)\nvariant:{type:String,default:null},striped:{type:Boolean,default:false},animated:{type:Boolean,default:false},height:{type:String,default:null},precision:{type:Number,default:0},showProgress:{type:Boolean,default:false},showValue:{type:Boolean,default:false},max:{type:Number,default:100},// This prop is not inherited by child b-progress-bar(s)\nvalue:{type:Number,default:0}},computed:{progressHeight:function progressHeight(){return{height:this.height||null};}},render:function render(h){var childNodes=this.$slots.default;if(!childNodes){childNodes=h('b-progress-bar',{props:{value:this.value,max:this.max,precision:this.precision,variant:this.variant,animated:this.animated,striped:this.striped,showProgress:this.showProgress,showValue:this.showValue}});}return h('div',{class:['progress'],style:this.progressHeight},[childNodes]);}};var components$w={BProgress:BProgress,BProgressBar:BProgressBar};var index$t={install:function install(Vue){registerComponents(Vue,components$w);}};var BSpinner={name:'BSpinner',functional:true,props:{type:{type:String,default:'border'// SCSS currently supports 'border' or 'grow'\n},label:{type:String,default:null},variant:{type:String,default:null},small:{type:Boolean,default:false},role:{type:String,default:'status'},tag:{type:String,default:'span'}},render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,slots=_ref.slots;var label=h(false);var hasLabel=slots().label||props.label;if(hasLabel){label=h('span',{staticClass:'sr-only'},hasLabel);}return h(props.tag,mergeData(data,{attrs:{role:hasLabel?props.role||'status':null,'aria-hidden':hasLabel?null:'true'},class:(_class={},_defineProperty(_class,\"spinner-\".concat(props.type),Boolean(props.type)),_defineProperty(_class,\"spinner-\".concat(props.type,\"-sm\"),props.small),_defineProperty(_class,\"text-\".concat(props.variant),Boolean(props.variant)),_class)}),[label]);}};var components$x={BSpinner:BSpinner};var index$u={install:function install(Vue){registerComponents(Vue,components$x);}};/*\n   * Consistent and stable sort function across JavaScript platforms\n   *\n   * Inconsistent sorts can cause SSR problems between client and server\n   * such as in <b-table> if sortBy is applied to the data on server side render.\n   * Chrome and V8 native sorts are inconsistent/unstable\n   *\n   * This function uses native sort with fallback to index compare when the a and b\n   * compare returns 0\n   *\n   * Algorithm based on:\n   * https://stackoverflow.com/questions/1427608/fast-stable-sorting-algorithm-implementation-in-javascript/45422645#45422645\n   *\n   * @param {array} array to sort\n   * @param {function} sort compare function\n   * @return {array}\n   */var stableSort=function stableSort(array,compareFn){// Using `.bind(compareFn)` on the wrapped anonymous function improves\n// performance by avoiding the function call setup. We don't use an arrow\n// function here as it binds `this` to the `stableSort` context rather than\n// the `compareFn` context, which wouldn't give us the performance increase.\nreturn array.map(function(a,index){return[index,a];}).sort(function(a,b){return this(a[1],b[1])||a[0]-b[0];}.bind(compareFn)).map(function(e){return e[1];});};/**\n   * Converts a string, including strings in camelCase or snake_case, into Start Case (a variant\n   * of Title Case where all words start with a capital letter), it keeps original single quote\n   * and hyphen in the word.\n   *\n   * Copyright (c) 2017 Compass (MIT)\n   * https://github.com/UrbanCompass/to-start-case\n   * @author Zhuoyuan Zhang <https://github.com/drawyan>\n   * @author Wei Wang <https://github.com/onlywei>\n   *\n   *\n   *   'management_companies' to 'Management Companies'\n   *   'managementCompanies' to 'Management Companies'\n   *   `hell's kitchen` to `Hell's Kitchen`\n   *   `co-op` to `Co-op`\n   *\n   * @param {String} str\n   * @returns {String}\n   */var startCase=function startCase(str){return str.replace(/_/g,' ').replace(/([a-z])([A-Z])/g,function(str,$1,$2){return $1+' '+$2;}).replace(/(\\s|^)(\\w)/g,function(str,$1,$2){return $1+$2.toUpperCase();});};// Constants used by table helpers\n// Object of item keys that should be ignored for headers and stringification and filter events\nvar IGNORED_FIELD_KEYS={_rowVariant:true,_cellVariants:true,_showDetails:true// Filter CSS Selector for click/dblclick/etc events\n// If any of these selectors match the clicked element, we ignore the event\n};var EVENT_FILTER=['a','a *',// include content inside links\n'button','button *',// include content inside buttons\n'input:not(.disabled):not([disabled])','select:not(.disabled):not([disabled])','textarea:not(.disabled):not([disabled])','[role=\"link\"]','[role=\"link\"] *','[role=\"button\"]','[role=\"button\"] *','[tabindex]:not(.disabled):not([disabled])'].join(',');function processField(key,value){var field=null;if(typeof value==='string'){// Label shortcut\nfield={key:key,label:value};}else if(typeof value==='function'){// Formatter shortcut\nfield={key:key,formatter:value};}else if(_typeof(value)==='object'){field=_objectSpread({},value);field.key=field.key||key;}else if(value!==false){// Fallback to just key\n/* istanbul ignore next */field={key:key};}return field;}// We normalize fields into an array of objects\n// [ { key:..., label:..., ...}, {...}, ..., {..}]\nfunction normalizeFields(origFields,items){var fields=[];if(isArray(origFields)){// Normalize array Form\norigFields.filter(function(f){return f;}).forEach(function(f){if(typeof f==='string'){fields.push({key:f,label:startCase(f)});}else if(_typeof(f)==='object'&&f.key&&typeof f.key==='string'){// Full object definition. We use assign so that we don't mutate the original\nfields.push(_objectSpread({},f));}else if(_typeof(f)==='object'&&keys(f).length===1){// Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\nvar key=keys(f)[0];var field=processField(key,f[key]);if(field){fields.push(field);}}});}else if(origFields&&_typeof(origFields)==='object'&&keys(origFields).length>0){// Normalize object Form (deprecated)\nkeys(origFields).forEach(function(key){var field=processField(key,origFields[key]);if(field){fields.push(field);}});}// If no field provided, take a sample from first record (if exits)\nif(fields.length===0&&isArray(items)&&items.length>0){var sample=items[0];keys(sample).forEach(function(k){if(!IGNORED_FIELD_KEYS[k]){fields.push({key:k,label:startCase(k)});}});}// Ensure we have a unique array of fields and that they have String labels\nvar memo={};return fields.filter(function(f){if(!memo[f.key]){memo[f.key]=true;f.label=typeof f.label==='string'?f.label:startCase(f.key);return true;}return false;});}// TODO: add option to specify which fields to include\nfunction sanitizeRow(row){return keys(row).reduce(function(obj,key){// Ignore special fields that start with _\nif(!IGNORED_FIELD_KEYS[key]){obj[key]=row[key];}return obj;},{});}// SSR safe deterministic way (keys are storted before stringification)\n//\n//   ex:\n//     { b: 3, c: { z: 'zzz', d: null, e: 2 }, d: [10, 12, 11], a: 'one' }\n//   becomes\n//     'one 3 2 zzz 10 12 11'\n//\n// Primatives (numbers/strings) are returned as-is\n// Null and undefined values are filtered out\n// Dates are converted to their native string format\n//\nfunction stringifyObjectValues(val){if(typeof val==='undefined'||val===null){/* istanbul ignore next */return'';}if(val instanceof Object&&!(val instanceof Date)){// Arrays are also object, and keys just returns the array indexes\n// Date objects we convert to strings\nreturn keys(val).sort()/* sort to prevent SSR issues on pre-rendered sorted tables */.filter(function(v){return v!==undefined&&v!==null;})/* ignore undefined/null values */.map(function(k){return stringifyObjectValues(val[k]);}).join(' ');}return String(val);}// TODO: add option to strigify formatted/scopedSlot items, and only specific fields\nfunction stringifyRecordValues(row){/* istanbul ignore else */if(row instanceof Object){return stringifyObjectValues(sanitizeRow(row));}else{/* istanbul ignore next */return'';}}/**\n   * Get property defined by dot/array notation in string.\n   *\n   * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901\n   *\n   * @param {Object} obj\n   * @param {string|Array} path\n   * @param {*} defaultValue (optional)\n   * @return {*}\n   */var get=function get(obj,path){var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;// Handle array of path values\npath=isArray(path)?path.join('.'):path;// If no path or no object passed\nif(!path||!isObject(obj)){return defaultValue;}// Handle edge case where user has dot(s) in top-level item field key\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/2762\nif(obj.hasOwnProperty(path)){return obj[path];}// Handle string array notation (numeric indices only)\npath=String(path).replace(/\\[(\\d+)]/g,'.$1');var steps=path.split('.').filter(Boolean);// Handle case where someone passes a string of only dots\nif(steps.length===0){return defaultValue;}// Traverse path in object to find result\nreturn steps.every(function(step){return isObject(obj)&&obj.hasOwnProperty(step)&&(obj=obj[step]);})?obj:defaultValue;};//\n// TODO: add option to sort by multiple columns (tri-state per column, plus order of columns in sort)\n//  where sprtBy could be an array of objects [ {key: 'foo', sortDir: 'asc'}, {key:'bar', sortDir: 'desc'} ...]\n//  or an array of arrays [ ['foo','asc'], ['bar','desc'] ]\nfunction defaultSortCompare(a,b,sortBy){a=get(a,sortBy,'');b=get(b,sortBy,'');if(a instanceof Date&&b instanceof Date||typeof a==='number'&&typeof b==='number'){// Special case for comparing Dates and Numbers\n// Internally dates are compared via their epoch number values\nif(a<b){return-1;}else if(a>b){return 1;}else{return 0;}}else{// Do localized string comparison\nreturn stringifyObjectValues(a).localeCompare(stringifyObjectValues(b),undefined,{numeric:true});}}var captionMixin={props:{caption:{type:String,default:null},captionHtml:{type:String},captionTop:{type:Boolean,default:false}},computed:{captionClasses:function captionClasses(){return{'b-table-caption-top':this.captionTop};},captionId:function captionId(){// Even though this.safeId looks like a method, it is a computed prop\n// that returns a new function if the underlying ID changes\nreturn this.isStacked?this.safeId('_caption_'):null;}},methods:{renderCaption:function renderCaption(){var h=this.$createElement;// Build the caption\nvar $captionSlot=this.normalizeSlot('table-caption',{});var $caption=h(false);if($captionSlot||this.caption||this.captionHtml){var data={key:'caption',class:this.captionClasses,attrs:{id:this.captionId}};if(!$captionSlot){data.domProps=htmlOrText(this.captionHtml,this.caption);}$caption=h('caption',data,[$captionSlot]);}return $caption;}}};var colgroupMixin={methods:{renderColgroup:function renderColgroup(){var h=this.$createElement;var fields=this.computedFields;var $colgroup=h(false);if(this.hasNormalizedSlot('table-colgroup')){$colgroup=h('colgroup',{key:'colgroup'},[this.normalizeSlot('table-colgroup',{columns:fields.length,fields:fields})]);}return $colgroup;}}};// Avoids having the user need to use @click.stop on the form control\nfunction filterEvent(evt){if(!evt||!evt.target){/* istanbul ignore next */return;}var el=evt.target;if(el.tagName==='TD'||el.tagName==='TH'||el.tagName==='TR'||el.disabled){// Shortut all the following tests for efficiency\nreturn false;}if(closest('.dropdown-menu',el)){// Click was in a dropdown menu, so ignore\nreturn true;}var label=el.tagName==='LABEL'?el:closest('label',el);if(label&&label.control&&!label.control.disabled){// If the label's form control is not disabled then we don't propagate evt\nreturn true;}// Else check to see if the event target matches one of the selectors in the event filter\n// i.e. anchors, non disabled inputs, etc. Return true if we should ignore the event.\nreturn matches(el,EVENT_FILTER);}// Helper to determine if a there is an active text selection on the document page.\nfunction textSelectionActive(){var el=arguments.length>0&&arguments[0]!==undefined?arguments[0]:document;var win=window;/* istanbul ignore if: JSDOM doesn't support getSelection */if(win&&win.getSelection&&win.getSelection().toString()!==''&&isElement(el)){/* istanbul ignore next: JSDOM doesn't support getSelection */var sel=win.getSelection();/* istanbul ignore next: JSDOM doesn't support getSelection */return sel.containsNode?sel.containsNode(el,true):false;}else{return false;}}var theadMixin={props:{headVariant:{type:String,default:''},theadClass:{type:[String,Array,Object],default:null},theadTrClass:{type:[String,Array,Object],default:null}},computed:{headClasses:function headClasses(){return[this.headVariant?'thead-'+this.headVariant:'',this.theadClass];}},methods:{fieldClasses:function fieldClasses(field){// header field (th) classes\nreturn[field.variant?'table-'+field.variant:'',field.class?field.class:'',field.thClass?field.thClass:''];},headClicked:function headClicked(e,field,isFoot){var _this=this;if(this.stopIfBusy(e)){// If table is busy (via provider) then don't propagate\nreturn;}else if(filterEvent(e)){// clicked on a non-disabled control so ignore\nreturn;}else if(textSelectionActive(this.$el)){// User is selecting text, so ignore\n/* istanbul ignore next: JSDOM doesn't support getSelection() */return;}e.stopPropagation();e.preventDefault();var sortChanged=false;var toggleLocalSortDesc=function toggleLocalSortDesc(){var sortDirection=field.sortDirection||_this.sortDirection;if(sortDirection==='asc'){_this.localSortDesc=false;}else if(sortDirection==='desc'){_this.localSortDesc=true;}};if(!(isFoot&&this.noFooterSorting)){if(field.sortable){if(field.key===this.localSortBy){// Change sorting direction on current column\nthis.localSortDesc=!this.localSortDesc;}else{// Start sorting this column ascending\nthis.localSortBy=field.key;toggleLocalSortDesc();}sortChanged=true;}else if(this.localSortBy&&!this.noSortReset){this.localSortBy=null;toggleLocalSortDesc();sortChanged=true;}}this.$emit('head-clicked',field.key,field,e,isFoot);if(sortChanged){// Sorting parameters changed\nthis.$emit('sort-changed',this.context);}},renderThead:function renderThead(){var _this2=this;var isFoot=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var h=this.$createElement;if(this.isStacked===true){// In always stacked mode, we don't bother rendering the head/foot\nreturn h(false);}var fields=this.computedFields||[];// Helper function to generate a field TH cell\nvar makeCell=function makeCell(field,colIndex){var ariaLabel='';if(!field.label.trim()&&!field.headerTitle){// In case field's label and title are empty/blank\n// We need to add a hint about what the column is about for non-sighted users\n/* istanbul ignore next */ariaLabel=startCase(field.key);}var sortable=field.sortable&&!(isFoot&&_this2.noFooterSorting);var ariaLabelSorting=sortable?_this2.localSortDesc&&_this2.localSortBy===field.key?_this2.labelSortAsc:_this2.labelSortDesc:null;// Assemble the aria-label\nariaLabel=[ariaLabel,ariaLabelSorting].filter(function(a){return a;}).join(': ')||null;var ariaSort=sortable&&_this2.localSortBy===field.key?_this2.localSortDesc?'descending':'ascending':sortable?'none':null;var data={key:field.key,class:_this2.fieldClasses(field),style:field.thStyle||{},attrs:{tabindex:sortable?'0':null,abbr:field.headerAbbr||null,title:field.headerTitle||null,role:'columnheader',scope:'col','aria-colindex':String(colIndex+1),'aria-label':ariaLabel,'aria-sort':ariaSort},on:{click:function click(evt){_this2.headClicked(evt,field,isFoot);},keydown:function keydown(evt){var keyCode=evt.keyCode;if(keyCode===KEY_CODES.ENTER||keyCode===KEY_CODES.SPACE){_this2.headClicked(evt,field,isFoot);}}}};var fieldScope={label:field.label,column:field.key,field:field};var slot=isFoot&&_this2.hasNormalizedSlot(\"FOOT_\".concat(field.key))?_this2.normalizeSlot(\"FOOT_\".concat(field.key),fieldScope):_this2.normalizeSlot(\"HEAD_\".concat(field.key),fieldScope);if(slot){slot=[slot];}else{data.domProps=htmlOrText(field.labelHtml,field.label);}return h('th',data,[slot]);};// Generate the array of TH cells\nvar $cells=fields.map(makeCell).filter(function(th){return th;});// Genrate the row(s)\nvar $trs=[];if(isFoot){$trs.push(h('tr',{class:this.tfootTrClass},$cells));}else{var scope={columns:fields.length,fields:fields};$trs.push(this.normalizeSlot('thead-top',scope)||h(false));$trs.push(h('tr',{class:this.theadTrClass,attrs:{role:'row'}},$cells));}return h(isFoot?'tfoot':'thead',{key:isFoot?'tfoot':'thead',class:isFoot?this.footClasses:this.headClasses,attrs:{role:'rowgroup'}},$trs);}}};var tfootMixin={props:{footClone:{type:Boolean,default:false},footVariant:{type:String,default:''},tfootClass:{type:[String,Array,Object],default:null},tfootTrClass:{type:[String,Array,Object],default:null}},computed:{footClasses:function footClasses(){var variant=this.footVariant||this.headVariant||null;return[variant?'thead-'+variant:'',this.tfootClass];}},methods:{renderTfoot:function renderTfoot(){var h=this.$createElement;// Passing true to renderThead will make it render a tfoot\nreturn this.footClone?this.renderThead(true):h(false);}}};var tbodyRowMixin={props:{tbodyTrClass:{type:[String,Array,Function],default:null}},methods:{// Methods for computing classes, attributes and styles for table cells\ntdClasses:function tdClasses(field,item){var cellVariant='';if(item._cellVariants&&item._cellVariants[field.key]){cellVariant=\"\".concat(this.dark?'bg':'table',\"-\").concat(item._cellVariants[field.key]);}return[field.variant&&!cellVariant?\"\".concat(this.dark?'bg':'table',\"-\").concat(field.variant):'',cellVariant,field.class?field.class:'',this.getTdValues(item,field.key,field.tdClass,'')];},tdAttrs:function tdAttrs(field,item,colIndex){var attrs={role:'cell','aria-colindex':String(colIndex+1)};if(field.isRowHeader){attrs.scope='row';attrs.role='rowheader';}if(this.isStacked){// Generate the \"header cell\" label content in stacked mode\nattrs['data-label']=field.label;}return _objectSpread({},attrs,this.getTdValues(item,field.key,field.tdAttr,{}));},rowClasses:function rowClasses(item){return[item._rowVariant?\"\".concat(this.dark?'bg':'table',\"-\").concat(item._rowVariant):'',typeof this.tbodyTrClass==='function'?this.tbodyTrClass(item,'row'):this.tbodyTrClass];},getTdValues:function getTdValues(item,key,tdValue,defValue){var parent=this.$parent;if(tdValue){var value=get(item,key,'');if(typeof tdValue==='function'){return tdValue(value,key,item);}else if(typeof tdValue==='string'&&typeof parent[tdValue]==='function'){return parent[tdValue](value,key,item);}return tdValue;}return defValue;},// Method to get the value for a field\ngetFormattedValue:function getFormattedValue(item,field){var key=field.key;var formatter=field.formatter;var parent=this.$parent;var value=get(item,key,null);if(formatter){if(typeof formatter==='function'){value=formatter(value,key,item);}else if(typeof formatter==='string'&&typeof parent[formatter]==='function'){value=parent[formatter](value,key,item);}}return value===null||typeof value==='undefined'?'':value;},// Row event handlers\nrowClicked:function rowClicked(e,item,index){if(this.stopIfBusy(e)){// If table is busy (via provider) then don't propagate\nreturn;}else if(filterEvent(e)){// clicked on a non-disabled control so ignore\nreturn;}else if(textSelectionActive(this.$el)){// User is selecting text, so ignore\n/* istanbul ignore next: JSDOM doesn't support getSelection() */return;}if(e.type==='keydown'){// If the click was generated by space or enter, stop page scroll\ne.stopPropagation();e.preventDefault();}this.$emit('row-clicked',item,index,e);},middleMouseRowClicked:function middleMouseRowClicked(e,item,index){if(this.stopIfBusy(e)){// If table is busy (via provider) then don't propagate\nreturn;}this.$emit('row-middle-clicked',item,index,e);},rowDblClicked:function rowDblClicked(e,item,index){if(this.stopIfBusy(e)){// If table is busy (via provider) then don't propagate\nreturn;}else if(filterEvent(e)){// clicked on a non-disabled control so ignore\nreturn;}this.$emit('row-dblclicked',item,index,e);},rowHovered:function rowHovered(e,item,index){if(this.stopIfBusy(e)){// If table is busy (via provider) then don't propagate\nreturn;}this.$emit('row-hovered',item,index,e);},rowUnhovered:function rowUnhovered(e,item,index){if(this.stopIfBusy(e)){// If table is busy (via provider) then don't propagate\nreturn;}this.$emit('row-unhovered',item,index,e);},rowContextmenu:function rowContextmenu(e,item,index){if(this.stopIfBusy(e)){// If table is busy (via provider) then don't propagate\nreturn;}this.$emit('row-contextmenu',item,index,e);},// Render helpers\nrenderTbodyRowCell:function renderTbodyRowCell(field,colIndex,item,rowIndex){var _this=this;var h=this.$createElement;// Renders a TD or TH for a row's field\nvar $scoped=this.$scopedSlots;var detailsSlot=$scoped['row-details'];var rowSelected=this.selectedRows[rowIndex];var formatted=this.getFormattedValue(item,field);var data={// For the Vue key, we concatinate the column index and field key (as field keys can be duplicated)\nkey:\"row-\".concat(rowIndex,\"-cell-\").concat(colIndex,\"-\").concat(field.key),class:this.tdClasses(field,item),attrs:this.tdAttrs(field,item,colIndex)};var toggleDetailsFn=function toggleDetailsFn(){if(detailsSlot){_this.$set(item,'_showDetails',!item._showDetails);}};var $childNodes;if($scoped[field.key]){// Has scoped field slot\n$childNodes=[$scoped[field.key]({item:item,index:rowIndex,field:field,unformatted:get(item,field.key,''),value:formatted,toggleDetails:toggleDetailsFn,detailsShowing:Boolean(item._showDetails),rowSelected:Boolean(rowSelected)})];if(this.isStacked){// We wrap in a DIV to ensure rendered as a single cell when visually stacked!\n$childNodes=[h('div',{},[$childNodes])];}}else{// No scoped field slot\nif(this.isStacked){// We wrap in a DIV to ensure rendered as a single cell when visually stacked!\n$childNodes=[h('div',toString(formatted))];}else{// Non stacked\n$childNodes=toString(formatted);}}// Render either a td or th cell\nreturn h(field.isRowHeader?'th':'td',data,$childNodes);},renderTbodyRow:function renderTbodyRow(item,rowIndex){var _this2=this;// Renders an item's row (or rows if details supported)\nvar h=this.$createElement;var $scoped=this.$scopedSlots;var fields=this.computedFields;var tableStriped=this.striped;var hasRowClickHandler=this.$listeners['row-clicked']||this.selectable;var $detailsSlot=$scoped['row-details'];var rowShowDetails=Boolean(item._showDetails&&$detailsSlot);var rowSelected=this.isRowSelected(rowIndex);/* from selctable mixin */ // We can return more than one TR if rowDetails enabled\nvar $rows=[];// Details ID needed for aria-describedby when details showing\nvar detailsId=rowShowDetails?this.safeId(\"_details_\".concat(rowIndex,\"_\")):null;var toggleDetailsFn=function toggleDetailsFn(){if($detailsSlot){_this2.$set(item,'_showDetails',!item._showDetails);}};// For each item data field in row\nvar $tds=fields.map(function(field,colIndex){return _this2.renderTbodyRowCell(field,colIndex,item,rowIndex);});// Calculate the row number in the dataset (indexed from 1)\nvar ariaRowIndex=null;if(this.currentPage&&this.perPage&&this.perPage>0){ariaRowIndex=String((this.currentPage-1)*this.perPage+rowIndex+1);}// Create a unique :key to help ensure that sub components are re-rendered rather than\n// re-used, which can cause issues. If a primary key is not provided we use the rendered\n// rows index within the tbody.\n// See: https://github.com/bootstrap-vue/bootstrap-vue/issues/2410\nvar primaryKey=this.primaryKey;var rowKey=primaryKey&&item[primaryKey]!==undefined&&item[primaryKey]!==null?toString(item[primaryKey]):String(rowIndex);// If primary key is provided, use it to generate a unique ID on each tbody > tr\n// In the format of '{tableId}__row_{primaryKeyValue}'\nvar rowId=primaryKey&&item[primaryKey]!==undefined&&item[primaryKey]!==null?this.safeId(\"_row_\".concat(item[primaryKey])):null;// Add the item row\n$rows.push(h('tr',{key:\"__b-table-row-\".concat(rowKey,\"__\"),class:[this.rowClasses(item),this.rowSelectedClasses(rowIndex),{'b-table-has-details':rowShowDetails}],attrs:{id:rowId,tabindex:hasRowClickHandler?'0':null,'data-pk':rowId?String(item[primaryKey]):null,'aria-describedby':detailsId,'aria-owns':detailsId,'aria-rowindex':ariaRowIndex,'aria-selected':this.selectable?rowSelected?'true':'false':null,role:'row'},on:{// TODO: only instatiate handlers if we have registered listeners (except row-clicked)\nauxclick:function auxclick(evt){if(evt.which===2){_this2.middleMouseRowClicked(evt,item,rowIndex);}},click:function click(evt){_this2.rowClicked(evt,item,rowIndex);},keydown:function keydown(evt){// We also allow enter/space to trigger a click (when row is focused)\nvar keyCode=evt.keyCode;if(keyCode===KEY_CODES.ENTER||keyCode===KEY_CODES.SPACE){if(evt.target&&evt.target.tagName==='TR'&&evt.target===document.activeElement){_this2.rowClicked(evt,item,rowIndex);}}},contextmenu:function contextmenu(evt){_this2.rowContextmenu(evt,item,rowIndex);},// Note: these events are not accessibility friendly!\ndblclick:function dblclick(evt){_this2.rowDblClicked(evt,item,rowIndex);},mouseenter:function mouseenter(evt){_this2.rowHovered(evt,item,rowIndex);},mouseleave:function mouseleave(evt){_this2.rowUnhovered(evt,item,rowIndex);}}},$tds));// Row Details slot\nif(rowShowDetails){var tdAttrs={colspan:String(fields.length),role:'cell'};var trAttrs={id:detailsId,role:'row'// Render the details slot\n};var $details=h('td',{attrs:tdAttrs},[$detailsSlot({item:item,index:rowIndex,fields:fields,toggleDetails:toggleDetailsFn})]);// Add a hidden row to keep table row striping consistent when details showing\nif(tableStriped){$rows.push(h('tr',{key:\"__b-table-details-\".concat(rowIndex,\"-stripe__\"),staticClass:'d-none',attrs:{'aria-hidden':'true',role:'presentation'}}));}// Add the actual details row\n$rows.push(h('tr',{key:\"__b-table-details-\".concat(rowIndex,\"__\"),staticClass:'b-table-details',class:[typeof this.tbodyTrClass==='function'?this.tbodyTrClass(item,'row-details'):this.tbodyTrClass],attrs:trAttrs},[$details]));}else if($detailsSlot){// Only add the placeholder if a the table has a row-details slot defined (but not shown)\n$rows.push(h(false));if(tableStriped){// add extra placeholder if table is striped\n$rows.push(h(false));}}// Return the row(s)\nreturn $rows;}}};var emptyMixin={props:{showEmpty:{type:Boolean,default:false},emptyText:{type:String,default:'There are no records to show'},emptyHtml:{type:String},emptyFilteredText:{type:String,default:'There are no records matching your request'},emptyFilteredHtml:{type:String}},methods:{renderEmpty:function renderEmpty(){var h=this.$createElement;var items=this.computedItems;var $empty;if(this.showEmpty&&(!items||items.length===0)&&!(this.computedBusy&&this.hasNormalizedSlot('table-busy'))){$empty=this.normalizeSlot(this.isFiltered?'emptyfiltered':'empty',{emptyFilteredHtml:this.emptyFilteredHtml,emptyFilteredText:this.emptyFilteredText,emptyHtml:this.emptyHtml,emptyText:this.emptyText,fields:this.computedFields,// Not sure why this is included, as it will always be an empty array\nitems:this.computedItems});if(!$empty){$empty=h('div',{class:['text-center','my-2'],domProps:this.isFiltered?htmlOrText(this.emptyFilteredHtml,this.emptyFilteredText):htmlOrText(this.emptyHtml,this.emptyText)});}$empty=h('td',{attrs:{colspan:String(this.computedFields.length),role:this.isStacked?'cell':null}},[h('div',{attrs:{role:'alert','aria-live':'polite'}},[$empty])]);$empty=h('tr',{key:this.isFiltered?'_b-table-empty-filtered-row_':'_b-table-empty-row_',staticClass:'b-table-empty-row',class:[typeof this.tbodyTrClass==='function'?this.tbodyTrClass(null,'row-empty'):this.tbodyTrClass],attrs:this.isStacked?{role:'row'}:{}},[$empty]);}return $empty||h(false);}}};var topRowMixin={methods:{renderTopRow:function renderTopRow(){var h=this.$createElement;// Add static Top Row slot (hidden in visibly stacked mode as we can't control the data-label)\n// If in always stacked mode, we don't bother rendering the row\nif(!this.hasNormalizedSlot('top-row')||this.isStacked===true){return h(false);}var fields=this.computedFields;return h('tr',{key:'top-row',staticClass:'b-table-top-row',class:[typeof this.tbodyTrClass==='function'?this.tbodyTrClass(null,'row-top'):this.tbodyTrClass],attrs:{role:'row'}},[this.normalizeSlot('top-row',{columns:fields.length,fields:fields})]);}}};var bottomRowMixin={methods:{renderBottomRow:function renderBottomRow(){var h=this.$createElement;// Static bottom row slot (hidden in visibly stacked mode as we can't control the data-label)\n// If in always stacked mode, we don't bother rendering the row\nif(!this.hasNormalizedSlot('bottom-row')||this.isStacked===true){return h(false);}var fields=this.computedFields;return h('tr',{key:'__b-table-bottom-row__',staticClass:'b-table-bottom-row',class:[typeof this.tbodyTrClass==='function'?this.tbodyTrClass(null,'row-bottom'):this.tbodyTrClass],attrs:{role:'row'}},this.normalizeSlot('bottom-row',{columns:fields.length,fields:fields}));}}};var tbodyMixin={mixins:[tbodyRowMixin,emptyMixin,topRowMixin,bottomRowMixin],props:{tbodyClass:{type:[String,Array],default:null},tbodyTransitionProps:{type:Object// default: undefined\n},tbodyTransitionHandlers:{type:Object// default: undefined\n}},methods:{renderTbody:function renderTbody(){var _this=this;// Render the tbody element and children\nvar h=this.$createElement;var items=this.computedItems;// Prepare the tbody rows\nvar $rows=[];// Add the item data rows or the busy slot\nvar $busy=this.renderBusy();if($busy){// If table is busy and a busy slot, then return only the busy \"row\" indicator\n$rows.push($busy);}else{// Table isn't bsuy, or we don't have a busy slot\n// Add static Top Row slot (hidden in visibly stacked mode as we can't control the data-label)\n$rows.push(this.renderTopRow());// render the rows\nitems.forEach(function(item,rowIndex){// Render the individual item row (rows if details slot)\n$rows.push(_this.renderTbodyRow(item,rowIndex));});// Empty Items / Empty Filtered Row slot (only shows if items.length < -\n$rows.push(this.renderEmpty());// Static bottom row slot (hidden in visibly stacked mode as we can't control the data-label)\n$rows.push(this.renderBottomRow());}// If tbody transition enabled\nvar isTransGroup=this.tbodyTransitionProps||this.tbodyTransitionHandlers;var tbodyProps={};var tbodyOn={};if(isTransGroup){tbodyOn=this.tbodyTransitionHandlers||{};tbodyProps=_objectSpread({},this.tbodyTransitionProps||{},{tag:'tbody'});}// Assemble rows into the tbody\nvar $tbody=h(isTransGroup?'transition-group':'tbody',{props:tbodyProps,on:tbodyOn,class:[this.tbodyClass],attrs:{role:'rowgroup'}},$rows);// Return the assembled tbody\nreturn $tbody;}}};var busyMixin={props:{busy:{type:Boolean,default:false}},data:function data(){return{localBusy:false};},computed:{computedBusy:function computedBusy(){return this.busy||this.localBusy;}},watch:{localBusy:function localBusy(newVal,oldVal){if(newVal!==oldVal){this.$emit('update:busy',newVal);}}},methods:{// Event handler helper\nstopIfBusy:function stopIfBusy(evt){if(this.computedBusy){// If table is busy (via provider) then don't propagate\nevt.preventDefault();evt.stopPropagation();return true;}return false;},// Renter the busy indecator or return null if not busy\nrenderBusy:function renderBusy(){var h=this.$createElement;// Return a busy indicator row, or null if not busy\nif(this.computedBusy&&this.hasNormalizedSlot('table-busy')){// Show the busy slot\nvar trAttrs={role:this.isStacked?'row':null};var tdAttrs={colspan:String(this.computedFields.length),role:this.isStacked?'cell':null};return h('tr',{key:'table-busy-slot',staticClass:'b-table-busy-slot',class:[typeof this.tbodyTrClass==='function'?this.tbodyTrClass(null,'table-busy'):this.tbodyTrClass],attrs:trAttrs},[h('td',{attrs:tdAttrs},[this.normalizeSlot('table-busy',{})])]);}else{// We return null here so that we can determine if we need to\n// render the table items rows or not.\nreturn null;}}}};var selectableMixin={props:{selectable:{type:Boolean,default:false},selectMode:{type:String,default:'multi'},selectedVariant:{type:String,default:'primary'}},data:function data(){return{selectedRows:[],selectedLastRow:-1};},watch:{computedItems:function computedItems(newVal,oldVal){// Reset for selectable\n// TODO: Should selectedLastClicked be reset here?\n//       As changes to _showDetails would trigger it to reset\nthis.selectedLastRow=-1;var equal=false;if(this.selectable&&this.selectedRows.length>0){// Quick check against array length\nequal=isArray(newVal)&&isArray(oldVal)&&newVal.length===oldVal.length;for(var i=0;equal&&i<newVal.length;i++){// Look for the first non-loosely equal row, after ignoring reserved fields\nequal=looseEqual(sanitizeRow(newVal[i]),sanitizeRow(oldVal[i]));}}if(!equal){this.clearSelected();}},selectable:function selectable(newVal,oldVal){this.clearSelected();this.setSelectionHandlers(newVal);},selectMode:function selectMode(newVal,oldVal){this.clearSelected();},selectedRows:function selectedRows(_selectedRows,oldVal){var _this=this;if(this.selectable&&!looseEqual(_selectedRows,oldVal)){var items=[];// forEach skips over non-existant indicies (on sparse arrays)\n_selectedRows.forEach(function(v,idx){if(v){items.push(_this.computedItems[idx]);}});this.$emit('row-selected',items);}}},beforeMount:function beforeMount(){// Set up handlers\nif(this.selectable){this.setSelectionHandlers(true);}},methods:{isRowSelected:function isRowSelected(idx){return Boolean(this.selectedRows[idx]);},rowSelectedClasses:function rowSelectedClasses(idx){if(this.selectable){var rowSelected=this.isRowSelected(idx);var base=this.dark?'bg':'table';var variant=this.selectedVariant;return _defineProperty({'b-row-selected':rowSelected},\"\".concat(base,\"-\").concat(variant),rowSelected&&variant);}else{return{};}},clearSelected:function clearSelected(){var hasSelection=this.selectedRows.reduce(function(prev,v){return prev||v;},false);if(hasSelection){this.selectedLastClicked=-1;this.selectedRows=[];}},setSelectionHandlers:function setSelectionHandlers(on){var method=on?'$on':'$off';// Handle row-clicked event\nthis[method]('row-clicked',this.selectionHandler);// Clear selection on filter, pagination, and sort changes\nthis[method]('filtered',this.clearSelected);this[method]('context-changed',this.clearSelected);},selectionHandler:function selectionHandler(item,index,evt){/* istanbul ignore if: should never happen */if(!this.selectable){// Don't do anything if table is not in selectable mode\n/* istanbul ignore next: should never happen */this.clearSelected();/* istanbul ignore next: should never happen */return;}var selectedRows=this.selectedRows.slice();var selected=!selectedRows[index];var mode=this.selectMode;// Note 'multi' mode needs no special handling\nif(mode==='single'){selectedRows=[];}else if(mode==='range'){if(this.selectedLastRow>-1&&evt.shiftKey){// range\nfor(var idx=Math.min(this.selectedLastRow,index);idx<=Math.max(this.selectedLastRow,index);idx++){// this.$set(this.selectedRows, idx, true)\nselectedRows[idx]=true;}selected=true;}else{if(!(evt.ctrlKey||evt.metaKey)){// clear range selection if any\nselectedRows=[];selected=true;}this.selectedLastRow=selected?index:-1;}}// this.$set(this.selectedRows, index, selected)\nselectedRows[index]=selected;this.selectedRows=selectedRows;}}};var providerMixin={mixins:[listenOnRootMixin],props:{noProviderPaging:{type:Boolean,default:false},noProviderSorting:{type:Boolean,default:false},noProviderFiltering:{type:Boolean,default:false},apiUrl:{// Passthrough prop. Passed to the context object. Not used by b-table directly\ntype:String,default:''}},computed:{hasProvider:function hasProvider(){return this.items instanceof Function;},providerTriggerContext:function providerTriggerContext(){// Used to trigger the provider function via a watcher. Only the fields that\n// are needed for triggering a provider update are included. Note that the\n// regular this.context is sent to the provider during fetches though, as they\n// may neeed all the prop info.\nvar ctx={apiUrl:this.apiUrl};if(!this.noProviderFiltering){// Either a string, or could be an object or array.\nctx.filter=this.localFilter;}if(!this.noProviderSorting){ctx.sortBy=this.localSortBy;ctx.sortDesc=this.localSortDesc;}if(!this.noProviderPaging){ctx.perPage=this.perPage;ctx.currentPage=this.currentPage;}return ctx;}},watch:{// Provider update triggering\nproviderTriggerContext:function providerTriggerContext(newVal,oldVal){// Trigger the provider to update as the relevant context values have changed.\nif(!looseEqual(newVal,oldVal)){this.$nextTick(this._providerUpdate);}}},mounted:function mounted(){var _this=this;// Call the items provider if necessary\nif(this.hasProvider&&(!this.localItems||this.localItems.length===0)){// Fetch on mount if localItems is empty\nthis._providerUpdate();}// Listen for global messages to tell us to force refresh the table\nthis.listenOnRoot('bv::refresh::table',function(id){if(id===_this.id||id===_this){_this.refresh();}});},methods:{refresh:function refresh(){// Public Method: Force a refresh of the provider function\nthis.$off('refreshed',this.refresh);if(this.computedBusy){// Can't force an update when forced busy by user (busy prop === true)\nif(this.localBusy&&this.hasProvider){// But if provider running (localBusy), re-schedule refresh once `refreshed` emitted\nthis.$on('refreshed',this.refresh);}}else{this.clearSelected();if(this.hasProvider){this.$nextTick(this._providerUpdate);}else{/* istanbul ignore next */this.localItems=isArray(this.items)?this.items.slice():[];}}},// Provider related methods\n_providerSetLocal:function _providerSetLocal(items){this.localItems=isArray(items)?items.slice():[];this.localBusy=false;this.$emit('refreshed');// New root emit\nif(this.id){this.emitOnRoot('bv::table::refreshed',this.id);}},_providerUpdate:function _providerUpdate(){// Refresh the provider function items.\nif(!this.hasProvider){// Do nothing if no provider\nreturn;}// If table is busy, wait until refereshed before calling again\nif(this.computedBusy){// Schedule a new refresh once `refreshed` is emitted\nthis.$nextTick(this.refresh);return;}// Set internal busy state\nthis.localBusy=true;// Call provider function with context and optional callback after DOM is fully updated\nthis.$nextTick(function(){var _this2=this;try{// Call provider function passing it the context and optional callback\nvar data=this.items(this.context,this._providerSetLocal);if(data&&data.then&&typeof data.then==='function'){// Provider returned Promise\ndata.then(function(items){// Provider resolved with items\n_this2._providerSetLocal(items);});}else if(isArray(data)){// Provider returned Array data\nthis._providerSetLocal(data);}else if(this.items.length!==2){// Check number of arguments provider function requested\n// Provider not using callback (didn't request second argument), so we clear\n// busy state as most likely there was an error in the provider function\n/* istanbul ignore next */warn(\"b-table provider function didn't request calback and did not return a promise or data\");/* istanbul ignore next */this.localBusy=false;}}catch(e)/* istanbul ignore next */{// Provider function borked on us, so we spew out a warning\n// and clear the busy state\nwarn(\"b-table provider function error [\".concat(e.name,\"] \").concat(e.message));this.localBusy=false;this.$off('refreshed',this.refresh);}});}}};// @vue/component\nvar BTable={name:'BTable',mixins:[idMixin,normalizeSlotMixin,busyMixin,captionMixin,colgroupMixin,theadMixin,tfootMixin,tbodyMixin,selectableMixin,providerMixin],// Don't place ATTRS on root element automatically, as table could be wrapped in responsive div\ninheritAttrs:false,props:{items:{type:[Array,Function],default:function _default()/* istanbul ignore next */{return[];}},fields:{type:[Object,Array],default:null},primaryKey:{// Primary key for record.\n// If provided the value in each row must be unique!!!\ntype:String,default:null},striped:{type:Boolean,default:false},bordered:{type:Boolean,default:false},borderless:{type:Boolean,default:false},outlined:{type:Boolean,default:false},dark:{type:Boolean,default:false},hover:{type:Boolean,default:false},small:{type:Boolean,default:false},fixed:{type:Boolean,default:false},responsive:{type:[Boolean,String],default:false},stacked:{type:[Boolean,String],default:false},sortBy:{type:String,default:null},sortDesc:{type:Boolean,default:false},sortDirection:{type:String,default:'asc',validator:function validator(direction){return arrayIncludes(['asc','desc','last'],direction);}},sortCompare:{type:Function,default:null},noSortReset:{type:Boolean,default:false},labelSortAsc:{type:String,default:'Click to sort Ascending'},labelSortDesc:{type:String,default:'Click to sort Descending'},perPage:{type:[Number,String],default:0},currentPage:{type:[Number,String],default:1},filter:{type:[String,RegExp,Object,Array,Function],default:null},filterFunction:{type:Function,default:null},noLocalSorting:{type:Boolean,default:false},noFooterSorting:{type:Boolean,default:false},value:{// v-model for retrieving the current displayed rows\ntype:Array,default:function _default(){return[];}}},data:function data(){return{// Mixins will also add to data\nlocalSortBy:this.sortBy||'',localSortDesc:this.sortDesc||false,// Our local copy of the items. Must be an array\nlocalItems:isArray(this.items)?this.items.slice():[],// Flag for displaying which empty slot to show, and for some event triggering.\nisFiltered:false};},computed:{// Layout related computed props\nisStacked:function isStacked(){return this.stacked===''?true:this.stacked;},isResponsive:function isResponsive(){var responsive=this.responsive===''?true:this.responsive;return this.isStacked?false:responsive;},responsiveClass:function responsiveClass(){return this.isResponsive===true?'table-responsive':this.isResponsive?\"table-responsive-\".concat(this.responsive):'';},tableClasses:function tableClasses(){var _ref;return _ref={'table-striped':this.striped,'table-hover':this.hover,'table-dark':this.dark,'table-bordered':this.bordered,'table-borderless':this.borderless,'table-sm':this.small,border:this.outlined,// The following are b-table custom styles\n'b-table-fixed':this.fixed,'b-table-stacked':this.stacked===true||this.stacked===''},_defineProperty(_ref,\"b-table-stacked-\".concat(this.stacked),this.stacked!==true&&this.stacked),_defineProperty(_ref,'b-table-selectable',this.selectable),_ref;},// Items related computed props\nlocalFiltering:function localFiltering(){return this.hasProvider?!!this.noProviderFiltering:true;},localSorting:function localSorting(){return this.hasProvider?!!this.noProviderSorting:!this.noLocalSorting;},localPaging:function localPaging(){return this.hasProvider?!!this.noProviderPaging:true;},context:function context(){// Current state of sorting, filtering and pagination props/values\nreturn{filter:this.localFilter,sortBy:this.localSortBy,sortDesc:this.localSortDesc,perPage:this.perPage,currentPage:this.currentPage,apiUrl:this.apiUrl};},computedFields:function computedFields(){// We normalize fields into an array of objects\n// [ { key:..., label:..., ...}, {...}, ..., {..}]\nreturn normalizeFields(this.fields,this.localItems);},filteredCheck:function filteredCheck(){// For watching changes to filteredItems vs localItems\nreturn{filteredItems:this.filteredItems,localItems:this.localItems,localFilter:this.localFilter};},localFilter:function localFilter(){// Returns a sanitized/normalized version of filter prop\nif(typeof this.filter==='function'){// this.localFilterFn will contain the correct function ref.\n// Deprecate setting prop filter to a function\n/* istanbul ignore next */return'';}else if(typeof this.filterFunction!=='function'&&!(typeof this.filter==='string'||this.filter instanceof RegExp)){// Using internal filter function, which only accepts string or regexp at the moment\nreturn'';}else{// Could be a string, object or array, as needed by external filter function\nreturn this.filter;}},localFilterFn:function localFilterFn(){var filter=this.filter;var filterFn=this.filterFunction;// Sanitized/normalize filter-function prop\nif(typeof filterFn==='function'){return filterFn;}else if(typeof filter==='function'){// Deprecate setting prop filter to a function\n/* istanbul ignore next */return filter;}else{// no filterFunction, so signal to use internal filter function\nreturn null;}},filteredItems:function filteredItems(){// Returns the records in localItems that match the filter criteria.\n// Returns the original localItems array if not sorting\nvar items=this.localItems||[];var criteria=this.localFilter;var filterFn=this.filterFnFactory(this.localFilterFn,criteria)||this.defaultFilterFnFactory(criteria);// We only do local filtering if requested, and if the are records to filter and\n// if a filter criteria was specified\nif(this.localFiltering&&filterFn&&items.length>0){items=items.filter(filterFn);}return items;},sortedItems:function sortedItems(){// Sorts the filtered items and returns a new array of the sorted items\n// or the original items array if not sorted.\nvar items=this.filteredItems||[];var sortBy=this.localSortBy;var sortDesc=this.localSortDesc;var sortCompare=this.sortCompare;var localSorting=this.localSorting;if(sortBy&&localSorting){// stableSort returns a new array, and leaves the original array intact\nreturn stableSort(items,function(a,b){var result=null;if(typeof sortCompare==='function'){// Call user provided sortCompare routine\nresult=sortCompare(a,b,sortBy,sortDesc);}if(result===null||result===undefined||result===false){// Fallback to built-in defaultSortCompare if sortCompare\n// is not defined or returns null/false\nresult=defaultSortCompare(a,b,sortBy);}// Negate result if sorting in descending order\nreturn(result||0)*(sortDesc?-1:1);});}return items;},paginatedItems:function paginatedItems(){var items=this.sortedItems||[];var currentPage=Math.max(parseInt(this.currentPage,10)||1,1);var perPage=Math.max(parseInt(this.perPage,10)||0,0);// Apply local pagination\nif(this.localPaging&&!!perPage){// Grab the current page of data (which may be past filtered items limit)\nitems=items.slice((currentPage-1)*perPage,currentPage*perPage);}// Return the items to display in the table\nreturn items;},computedItems:function computedItems(){return this.paginatedItems||[];}},watch:{// Watch props for changes and update local values\nitems:function items(newItems){if(this.hasProvider||newItems instanceof Function){this.$nextTick(this._providerUpdate);}else if(isArray(newItems)){// Set localItems/filteredItems to a copy of the provided array\nthis.localItems=newItems.slice();}else{/* istanbul ignore next */this.localItems=[];}},sortDesc:function sortDesc(newVal,oldVal){if(newVal===this.localSortDesc){/* istanbul ignore next */return;}this.localSortDesc=newVal||false;},sortBy:function sortBy(newVal,oldVal){if(newVal===this.localSortBy){/* istanbul ignore next */return;}this.localSortBy=newVal||null;},// Update .sync props\nlocalSortDesc:function localSortDesc(newVal,oldVal){// Emit update to sort-desc.sync\nif(newVal!==oldVal){this.$emit('update:sortDesc',newVal);}},localSortBy:function localSortBy(newVal,oldVal){if(newVal!==oldVal){this.$emit('update:sortBy',newVal);}},// Watch for changes on computedItems and update the v-model\ncomputedItems:function computedItems(newVal,oldVal){this.$emit('input',newVal);},// Watch for changes to the filter criteria and filtered items vs localItems).\n// And set visual state and emit events as required\nfilteredCheck:function filteredCheck(_ref2){var filteredItems=_ref2.filteredItems,localItems=_ref2.localItems,localFilter=_ref2.localFilter;// Determine if the dataset is filtered or not\nvar isFiltered;if(!localFilter){// If filter criteria is falsey\nisFiltered=false;}else if(looseEqual(localFilter,[])||looseEqual(localFilter,{})){// If filter criteria is an empty array or object\nisFiltered=false;}else if(localFilter){// if Filter criteria is truthy\nisFiltered=true;}else{isFiltered=false;}if(isFiltered){this.$emit('filtered',filteredItems,filteredItems.length);}this.isFiltered=isFiltered;},isFiltered:function isFiltered(newVal,oldVal){if(newVal===false&&oldVal===true){// We need to emit a filtered event if isFiltered transitions from true to\n// false so that users can update their pagination controls.\nthis.$emit('filtered',this.localItems,this.localItems.length);}},context:function context(newVal,oldVal){// Emit context info for external paging/filtering/sorting handling\nif(!looseEqual(newVal,oldVal)){this.$emit('context-changed',newVal);}}},mounted:function mounted(){// Initially update the v-model of displayed items\nthis.$emit('input',this.computedItems);},methods:{// Filter Function factories\nfilterFnFactory:function filterFnFactory(filterFn,criteria){// Wrapper factory for external filter functions.\n// Wrap the provided filter-function and return a new function.\n// returns null if no filter-function defined or if criteria is falsey.\n// Rather than directly grabbing this.computedLocalFilterFn or this.filterFunction\n// We have it passed, so that the caller computed prop will be reactive to changes\n// in the original filter-function (as this routine is a method)\nif(!filterFn||!criteria||typeof filterFn!=='function'){return null;}// Build the wrapped filter test function, passing the criteria to the provided function\nvar fn=function fn(item){// Generated function returns true if the criteria matches part\n// of the serialized data, otherwise false\nreturn filterFn(item,criteria);};// Return the wrapped function\nreturn fn;},defaultFilterFnFactory:function defaultFilterFnFactory(criteria){// Generates the default filter function, using the given filter criteria\nif(!criteria||!(typeof criteria==='string'||criteria instanceof RegExp)){// Built in filter can only support strings or RegExp criteria (at the moment)\nreturn null;}// Build the regexp needed for filtering\nvar regexp=criteria;if(typeof regexp==='string'){// Escape special RegExp characters in the string and convert contiguous\n// whitespace to \\s+ matches\nvar pattern=criteria.replace(/[-/\\\\^$*+?.()|[\\]{}]/g,'\\\\$&').replace(/[\\s\\uFEFF\\xA0]+/g,'\\\\s+');// Build the RegExp (no need for global flag, as we only need\n// to find the value once in the string)\nregexp=new RegExp(\".*\".concat(pattern,\".*\"),'i');}// Generate the wrapped filter test function to use\nvar fn=function fn(item){// This searches all row values (and sub property values) in the entire (excluding\n// special _ prefixed keys), because we convert the record to a space-separated\n// string containing all the value properties (recursively), even ones that are\n// not visible (not specified in this.fields).\n//\n// TODO: Enable searching on formatted fields and scoped slots\n// TODO: Should we filter only on visible fields (i.e. ones in this.fields) by default?\n// TODO: Allow for searching on specific fields/key, this could be combined with the previous TODO\n// TODO: Give stringifyRecordValues extra options for filtering (i.e. passing the\n//       fields definition and a reference to $scopedSlots)\n//\n// Generated function returns true if the criteria matches part of\n// the serialized data, otherwise false\n// We set lastIndex = 0 on regex in case someone uses the /g global flag\nregexp.lastIndex=0;return regexp.test(stringifyRecordValues(item));};// Return the generated function\nreturn fn;}},render:function render(h){var fields=this.computedFields;var items=this.computedItems;// Build the caption (from caption mixin)\nvar $caption=this.renderCaption();// Build the colgroup\nvar $colgroup=this.renderColgroup();// Build the thead\nvar $thead=this.renderThead();// Build the tfoot\nvar $tfoot=this.renderTfoot();// Build the tbody\nvar $tbody=this.renderTbody();// Assemble table\nvar $table=h('table',{key:'b-table',staticClass:'table b-table',class:this.tableClasses,attrs:_objectSpread({// We set aria-rowcount before merging in $attrs, in case user has supplied their own\n'aria-rowcount':this.filteredItems.length>items.length?String(this.filteredItems.length):null},this.$attrs,{// Now we can override any $attrs here\nid:this.safeId(),role:this.isStacked?'table':null,'aria-multiselectable':this.selectable?this.selectMode==='single'?'false':'true':null,'aria-busy':this.computedBusy?'true':'false','aria-colcount':String(fields.length),'aria-describedby':[// Preserve user supplied aria-describedby, if provided in $attrs\n(this.$attrs||{})['aria-describedby'],this.captionId].filter(function(a){return a;}).join(' ')||null})},[$caption,$colgroup,$thead,$tfoot,$tbody]);// Add responsive wrapper if needed and return table\nreturn this.isResponsive?h('div',{key:'b-table-responsive',class:this.responsiveClass},[$table]):$table;}};var components$y={BTable:BTable};var index$v={install:function install(Vue){registerComponents(Vue,components$y);}};// @vue/component\nvar BTabButtonHelper={name:'BTabButtonHelper',inject:{bvTabs:{default:function _default()/* istanbul ignore next */{return{};}}},props:{// Reference to the child b-tab instance\ntab:{default:null},tabs:{type:Array,default:function _default(){return[];}},id:{type:String,default:null},controls:{type:String,default:null},tabIndex:{type:Number,default:null},posInSet:{type:Number,default:null},setSize:{type:Number,default:null},noKeyNav:{type:Boolean,default:false}},methods:{focus:function focus(){if(this.$refs&&this.$refs.link&&this.$refs.link.focus){this.$refs.link.focus();}},handleEvt:function handleEvt(evt){function stop(){evt.preventDefault();evt.stopPropagation();}if(this.tab.disabled){/* istanbul ignore next */return;}var type=evt.type;var key=evt.keyCode;var shift=evt.shiftKey;if(type==='click'){stop();this.$emit('click',evt);}else if(type==='keydown'&&!this.noKeyNav&&key===KEY_CODES.SPACE){// In keynav mode, SPACE press will also trigger a click/select\nstop();this.$emit('click',evt);}else if(type==='keydown'&&!this.noKeyNav){// For keyboard navigation\nif(key===KEY_CODES.UP||key===KEY_CODES.LEFT||key===KEY_CODES.HOME){stop();if(shift||key===KEY_CODES.HOME){this.$emit('first',evt);}else{this.$emit('prev',evt);}}else if(key===KEY_CODES.DOWN||key===KEY_CODES.RIGHT||key===KEY_CODES.END){stop();if(shift||key===KEY_CODES.END){this.$emit('last',evt);}else{this.$emit('next',evt);}}}}},render:function render(h){var link=h(BLink,{ref:'link',staticClass:'nav-link',class:[{active:this.tab.localActive&&!this.tab.disabled,disabled:this.tab.disabled},this.tab.titleLinkClass],props:{href:this.tab.href,// To be deprecated to always be '#'\ndisabled:this.tab.disabled},attrs:{role:'tab',id:this.id,// Roving tab index when keynav enabled\ntabindex:this.tabIndex,'aria-selected':this.tab.localActive&&!this.tab.disabled?'true':'false','aria-setsize':this.setSize,'aria-posinset':this.posInSet,'aria-controls':this.controls},on:{click:this.handleEvt,keydown:this.handleEvt}},[this.tab.$slots.title||this.tab.title]);return h('li',{staticClass:'nav-item',class:[this.tab.titleItemClass],attrs:{role:'presentation'}},[link]);}};// Filter function to filter out disabled tabs\nfunction notDisabled(tab){return!tab.disabled;}// @vue/component\nvar BTabs={name:'BTabs',mixins:[idMixin],provide:function provide(){return{bvTabs:this};},props:{tag:{type:String,default:'div'},card:{type:Boolean,default:false},small:{type:Boolean,default:false},pills:{type:Boolean,default:false},vertical:{type:Boolean,default:false},bottom:{type:Boolean,default:false},end:{// Synonym for 'bottom'\ntype:Boolean,default:false},noFade:{type:Boolean,default:false},noNavStyle:{type:Boolean,default:false},noKeyNav:{type:Boolean,default:false},lazy:{// This prop is sniffed by the tab child\ntype:Boolean,default:false},contentClass:{type:[String,Array,Object],default:null},navClass:{type:[String,Array,Object],default:null},navWrapperClass:{type:[String,Array,Object],default:null},value:{// v-model\ntype:Number,default:null}},data:function data(){var tabIdx=parseInt(this.value,10);tabIdx=isNaN(tabIdx)?-1:tabIdx;return{// Index of current tab\ncurrentTab:tabIdx,// Array of direct child b-tab instances\ntabs:[]};},computed:{fade:function fade(){// This computed prop is sniffed by the tab child\nreturn!this.noFade;},navStyle:function navStyle(){return this.pills?'pills':'tabs';}},watch:{currentTab:function currentTab(val,old){var index=-1;// Ensure only one tab is active at most\nthis.tabs.forEach(function(tab,idx){if(val===idx&&!tab.disabled){tab.localActive=true;index=idx;}else{tab.localActive=false;}});// Update the v-model\nthis.$emit('input',index);},value:function value(val,old){if(val!==old){val=parseInt(val,10);val=isNaN(val)?-1:val;old=parseInt(old,10)||0;var tabs=this.tabs;if(tabs[val]&&!tabs[val].disabled){this.currentTab=val;}else{// Try next or prev tabs\nif(val<old){this.previousTab();}else{this.nextTab();}}}}},created:function created(){var _this=this;var tabIdx=parseInt(this.value,10);this.currentTab=isNaN(tabIdx)?-1:tabIdx;// Create private non-reactive prop\nthis._bvObserver=null;// For SSR and to make sure only a single tab is shown on mount\n// We wrap this in a `$nextTick()` to ensure the child tabs have been created\nthis.$nextTick(function(){_this.updateTabs();});},mounted:function mounted(){var _this2=this;this.$nextTick(function(){// Call updateTabs jsut in case....\n_this2.updateTabs();// Observe Child changes so we can update list of tabs\n_this2.setObserver(true);});},deactivated:function deactivated()/* istanbul ignore next */{this.setObserver(false);},activated:function activated()/* istanbul ignore next */{var _this3=this;var tabIdx=parseInt(this.value,10);this.currentTab=isNaN(tabIdx)?-1:tabIdx;this.$nextTick(function(){_this3.updateTabs();_this3.setObserver(true);});},beforeDestroy:function beforeDestroy()/* istanbul ignore next */{this.setObserver(false);},methods:{setObserver:function setObserver(on){if(on){// Make sure no existing observer running\nthis.setObserver(false);// Watch for changes to b-tab sub components\nthis._bvObserver=observeDom(this.$refs.tabsContainer,this.updateTabs.bind(this),{childList:true,subtree:false,attributes:true,attributeFilter:['style','class']});}else{if(this._bvObserver&&this._bvObserver.disconnect){this._bvObserver.disconnect();}this._bvObserver=null;}},getTabs:function getTabs(){return(this.$slots.default||[]).map(function(vnode){return vnode.componentInstance;}).filter(function(tab){return tab&&tab._isTab;});},// Update list of b-tab children\nupdateTabs:function updateTabs(){// Probe tabs\nvar tabs=this.getTabs();// Find *last* active non-disabled tab in current tabs\n// We trust tab state over currentTab, in case tabs were added/removed/re-ordered\nvar tabIndex=tabs.indexOf(tabs.slice().reverse().find(function(tab){return tab.localActive&&!tab.disabled;}));// Else try setting to currentTab\nif(tabIndex<0){var currentTab=this.currentTab;if(currentTab>=tabs.length){// Handle last tab being removed, so find the last non-disabled tab\ntabIndex=tabs.indexOf(tabs.slice().reverse().find(notDisabled));}else if(tabs[currentTab]&&!tabs[currentTab].disabled){// Current tab is not disabled\ntabIndex=currentTab;}}// Else find *first* non-disabled tab in current tabs\nif(tabIndex<0){tabIndex=tabs.indexOf(tabs.find(notDisabled));}// Set the current tab state to active\ntabs.forEach(function(tab,idx){// tab.localActive = idx === tabIndex && !tab.disabled\ntab.localActive=false;});if(tabs[tabIndex]){tabs[tabIndex].localActive=true;}// Update the array of tab children\nthis.tabs=tabs;// Set the currentTab index (can be -1 if no non-disabled tabs)\nthis.currentTab=tabIndex;},// Find a button that controls a tab, given the tab reference\n// Returns the button vm instance\ngetButtonForTab:function getButtonForTab(tab){return(this.$refs.buttons||[]).find(function(btn){return btn.tab===tab;});},// Force a button to re-render it's content, given a b-tab instance\n// Called by b-tab on update()\nupdateButton:function updateButton(tab){var button=this.getButtonForTab(tab);if(button&&button.$forceUpdate){button.$forceUpdate();}},// Activate a tab given a b-tab instance\n// Also accessed by b-tab\nactivateTab:function activateTab(tab){var result=false;if(tab){var index=this.tabs.indexOf(tab);if(!tab.disabled&&index>-1){result=true;this.currentTab=index;}}if(!result){// Couldn't set tab, so ensure v-model is set to this.currentTab\n/* istanbul ignore next: should rarely happen */this.$emit('input',this.currentTab);}return result;},// Deactivate a tab given a b-tab instance\n// Accessed by b-tab\ndeactivateTab:function deactivateTab(tab){if(tab){// Find first non-disabled tab that isn't the one being deactivated\n// If no available tabs, then don't deactivate current tab\nreturn this.activateTab(this.tabs.filter(function(t){return t!==tab;}).find(notDisabled));}else{// No tab specified\n/* istanbull ignore next: should never happen */return false;}},// Focus a tab button given it's b-tab instance\nfocusButton:function focusButton(tab){var _this4=this;// Wrap in nextTick to ensure DOM has completed rendering/updating before focusing\nthis.$nextTick(function(){var button=_this4.getButtonForTab(tab);if(button&&button.focus){button.focus();}});},// Emit a click event on a specified b-tab component instance\nemitTabClick:function emitTabClick(tab,evt){if(evt&&evt instanceof Event&&tab&&tab.$emit&&!tab.disabled){tab.$emit('click',evt);}},// Click Handler\nclickTab:function clickTab(tab,evt){this.activateTab(tab);this.emitTabClick(tab,evt);},// Move to first non-disabled tab\nfirstTab:function firstTab(focus){var tab=this.tabs.find(notDisabled);if(this.activateTab(tab)&&focus){this.focusButton(tab);this.emitTabClick(tab,focus);}},// Move to previous non-disabled tab\npreviousTab:function previousTab(focus){var currentIndex=Math.max(this.currentTab,0);var tab=this.tabs.slice(0,currentIndex).reverse().find(notDisabled);if(this.activateTab(tab)&&focus){this.focusButton(tab);this.emitTabClick(tab,focus);}},// Move to next non-disabled tab\nnextTab:function nextTab(focus){var currentIndex=Math.max(this.currentTab,-1);var tab=this.tabs.slice(currentIndex+1).find(notDisabled);if(this.activateTab(tab)&&focus){this.focusButton(tab);this.emitTabClick(tab,focus);}},// Move to last non-disabled tab\nlastTab:function lastTab(focus){var tab=this.tabs.slice().reverse().find(notDisabled);if(this.activateTab(tab)&&focus){this.focusButton(tab);this.emitTabClick(tab,focus);}}},render:function render(h){var _this5=this,_ref;var tabs=this.tabs;// Currently active tab\nvar activeTab=tabs.find(function(tab){return tab.localActive&&!tab.disabled;});// Tab button to allow focusing when no active tab found (keynav only)\nvar fallbackTab=tabs.find(function(tab){return!tab.disabled;});// For each <b-tab> found create the tab buttons\nvar buttons=tabs.map(function(tab,index){var tabIndex=null;// Ensure at least one tab button is focusable when keynav enabled (if possible)\nif(!_this5.noKeyNav){// Buttons are not in tab index unless active, or a fallback tab\ntabIndex=-1;if(activeTab===tab||!activeTab&&fallbackTab===tab){// Place tab button in tab sequence\ntabIndex=null;}}return h(BTabButtonHelper,{key:tab._uid||index,ref:'buttons',// Needed to make this.$refs.buttons an array\nrefInFor:true,props:{tab:tab,tabs:tabs,id:tab.controlledBy||(_this5.tab&&_this5.tab.safeId?_this5.tab.safeId(\"_BV_tab_button_\"):null),controls:_this5.tab&&_this5.tab.safeId?_this5.tab.safeId():null,tabIndex:tabIndex,setSize:tabs.length,posInSet:index+1,noKeyNav:_this5.noKeyNav},on:{click:function click(evt){_this5.clickTab(tab,evt);},first:_this5.firstTab,prev:_this5.previousTab,next:_this5.nextTab,last:_this5.lastTab}});});// Nav 'button' wrapper\nvar navs=h('ul',{ref:'navs',class:['nav',(_ref={},_defineProperty(_ref,\"nav-\".concat(this.navStyle),!this.noNavStyle),_defineProperty(_ref,\"card-header-\".concat(this.navStyle),this.card&&!this.vertical),_defineProperty(_ref,'card-header',this.card&&this.vertical),_defineProperty(_ref,'h-100',this.card&&this.vertical),_defineProperty(_ref,'flex-column',this.vertical),_defineProperty(_ref,'border-bottom-0',this.vertical),_defineProperty(_ref,'rounded-0',this.vertical),_defineProperty(_ref,\"small\",this.small),_ref),this.navClass],attrs:{role:'tablist',id:this.safeId('_BV_tab_controls_')}},[buttons,this.$slots.tabs]);navs=h('div',{key:'bv-tabs-navs',class:[{'card-header':this.card&&!this.vertical&&!(this.end||this.bottom),'card-footer':this.card&&!this.vertical&&(this.end||this.bottom),'col-auto':this.vertical},this.navWrapperClass]},[navs]);var empty=h(false);if(!tabs||tabs.length===0){empty=h('div',{key:'empty-tab',class:['tab-pane','active',{'card-body':this.card}]},this.$slots.empty);}// Main content section\n// TODO: This container should be a helper component\nvar content=h('div',{ref:'tabsContainer',key:'bv-tabs-container',staticClass:'tab-content',class:[{col:this.vertical},this.contentClass],attrs:{id:this.safeId('_BV_tab_container_')}},[this.$slots.default,empty]);// Render final output\nreturn h(this.tag,{staticClass:'tabs',class:{row:this.vertical,'no-gutters':this.vertical&&this.card},attrs:{id:this.safeId()}},[this.end||this.bottom?content:h(false),[navs],this.end||this.bottom?h(false):content]);}};var BTab={name:'BTab',mixins:[idMixin],inject:{bvTabs:{default:function _default(){return{// Don't set a tab index if not rendered inside `<b-tabs>`\nnoKeyNav:true};}}},props:{active:{type:Boolean,default:false},tag:{type:String,default:'div'},buttonId:{type:String,default:''},title:{type:String,default:''},titleItemClass:{// Sniffed by tabs.js and added to nav 'li.nav-item'\ntype:[String,Array,Object],default:null},titleLinkClass:{// Sniffed by tabs.js and added to nav 'a.nav-link'\ntype:[String,Array,Object],default:null},headHtml:{// Is this actually ever used?\ntype:String,default:null},disabled:{type:Boolean,default:false},noBody:{type:Boolean,default:false},href:{// This should be deprecated, as tabs are not navigation (URL) based\n// <b-nav> + <b-card> + <router-view>/<nuxt-child> should be used instead\n// And we dont support router-links here\ntype:String,default:'#'},lazy:{type:Boolean,default:false}},data:function data(){return{localActive:this.active&&!this.disabled,show:false};},computed:{tabClasses:function tabClasses(){return[this.bvTabs.card&&!this.noBody?'card-body':'',this.show?'show':'',this.computedFade?'fade':'',this.disabled?'disabled':'',this.localActive?'active':''];},controlledBy:function controlledBy(){return this.buttonId||this.safeId('__BV_tab_button__');},computedFade:function computedFade(){return this.bvTabs.fade||false;},computedLazy:function computedLazy(){return this.bvTabs.lazy||this.lazy;},_isTab:function _isTab(){// For parent sniffing of child\nreturn true;}},watch:{localActive:function localActive(newVal,oldVal){// Make 'active' prop work with `.sync` modifier\nthis.$emit('update:active',newVal);},active:function active(newVal,oldVal){if(newVal!==oldVal){if(newVal){// If activated post mount\nthis.activate();}else{if(!this.deactivate()){// Tab couldn't be deactivated, so we reset the synced active prop\n// Deactivation will fail if no other tabs to activate.\nthis.$emit('update:active',this.localActive);}}}},disabled:function disabled(newVal,oldVal){if(newVal!==oldVal){if(newVal&&this.localActive&&this.bvTabs.firstTab){this.localActive=false;this.bvTabs.firstTab();}}}},mounted:function mounted(){// Initially show on mount if active and not disabled\nthis.show=this.localActive;},updated:function updated(){// Force the tab button content to update (since slots are not reactive)\n// Only done if we have a title slot, as the title prop is reactive\nif(this.$slots.title&&this.bvTabs.updateButton){this.bvTabs.updateButton(this);}},methods:{// Transition handlers\nbeforeEnter:function beforeEnter(){var _this=this;// change opacity (add 'show' class) 1 frame after display\n// otherwise css transition won't happen\nrequestAF(function(){_this.show=true;});},beforeLeave:function beforeLeave(){// Remove the 'show' class\nthis.show=false;},// Public methods\nactivate:function activate(){if(this.bvTabs.activateTab&&!this.disabled){return this.bvTabs.activateTab(this);}else{// Not inside a b-tabs component or tab is disabled\nreturn false;}},deactivate:function deactivate(){if(this.bvTabs.deactivateTab&&this.localActive){return this.bvTabs.deactivateTab(this);}else{// Not inside a b-tabs component or not active to begin with\nreturn false;}}},render:function render(h){var content=h(this.tag,{ref:'panel',staticClass:'tab-pane',class:this.tabClasses,directives:[// TODO: convert to style object in render\n{name:'show',rawName:'v-show',value:this.localActive,expression:'localActive'}],attrs:{role:'tabpanel',id:this.safeId(),tabindex:this.localActive&&!this.bvTabs.noKeyNav?'0':null,'aria-hidden':this.localActive?'false':'true','aria-expanded':this.localActive?'true':'false','aria-labelledby':this.controlledBy||null}},// Render content lazily if requested\n[this.localActive||!this.computedLazy?this.$slots.default:h(false)]);return h('transition',{props:{mode:'out-in',// Disable use of built-in transition classes\n'enter-class':'','enter-active-class':'','enter-to-class':'','leave-class':'','leave-active-class':'','leave-to-class':''},on:{beforeEnter:this.beforeEnter,beforeLeave:this.beforeLeave}},[content]);}};var components$z={BTabs:BTabs,BTab:BTab};var index$w={install:function install(Vue){registerComponents(Vue,components$z);}};var BTooltip={name:'BTooltip',mixins:[toolpopMixin],props:{title:{type:String,default:''},triggers:{type:[String,Array],default:'hover focus'},placement:{type:String,default:'top'}},data:function data(){return{};},methods:{createToolpop:function createToolpop(){// getTarget is in toolpop mixin\nvar target=this.getTarget();if(target){this._toolpop=new ToolTip(target,this.getConfig(),this.$root);}else{this._toolpop=null;warn(\"b-tooltip: 'target' element not found!\");}return this._toolpop;}},render:function render(h){return h('div',{class:['d-none'],style:{display:'none'},attrs:{'aria-hidden':true}},[h('div',{ref:'title'},this.$slots.default)]);}};var inBrowser$3=typeof window!=='undefined'&&typeof document!=='undefined';// Key which we use to store tooltip object on element\nvar BVTT='__BV_ToolTip__';// Valid event triggers\nvar validTriggers$1={focus:true,hover:true,click:true,blur:true// Build a ToolTip config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n/* istanbul ignore next: not easy to test */};function parseBindings$1(bindings){// We start out with a blank config\nvar config={};// Process bindings.value\nif(typeof bindings.value==='string'){// Value is tooltip content (html optionally supported)\nconfig.title=bindings.value;}else if(typeof bindings.value==='function'){// Title generator function\nconfig.title=bindings.value;}else if(_typeof(bindings.value)==='object'){// Value is config object, so merge\nconfig=_objectSpread({},config,bindings.value);}// If Argument, assume element ID of container element\nif(bindings.arg){// Element ID specified as arg. We must prepend '#' to become a CSS selector\nconfig.container=\"#\".concat(bindings.arg);}// Process modifiers\nkeys(bindings.modifiers).forEach(function(mod){if(/^html$/.test(mod)){// Title allows HTML\nconfig.html=true;}else if(/^nofade$/.test(mod)){// no animation\nconfig.animation=false;}else if(/^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/.test(mod)){// placement of tooltip\nconfig.placement=mod;}else if(/^(window|viewport)$/.test(mod)){// bounday of tooltip\nconfig.boundary=mod;}else if(/^d\\d+$/.test(mod)){// delay value\nvar delay=parseInt(mod.slice(1),10)||0;if(delay){config.delay=delay;}}else if(/^o-?\\d+$/.test(mod)){// offset value. Negative allowed\nvar offset=parseInt(mod.slice(1),10)||0;if(offset){config.offset=offset;}}});// Special handling of event trigger modifiers Trigger is a space separated list\nvar selectedTriggers={};// parse current config object trigger\nvar triggers=typeof config.trigger==='string'?config.trigger.trim().split(/\\s+/):[];triggers.forEach(function(trigger){if(validTriggers$1[trigger]){selectedTriggers[trigger]=true;}});// Parse Modifiers for triggers\nkeys(validTriggers$1).forEach(function(trigger){if(bindings.modifiers[trigger]){selectedTriggers[trigger]=true;}});// Sanitize triggers\nconfig.trigger=keys(selectedTriggers).join(' ');if(config.trigger==='blur'){// Blur by itself is useless, so convert it to 'focus'\nconfig.trigger='focus';}if(!config.trigger){// remove trigger config\ndelete config.trigger;}return config;}//\n// Add or Update tooltip on our element\n//\n/* istanbul ignore next: not easy to test */function applyBVTT(el,bindings,vnode){if(!inBrowser$3){return;}if(!Popper){// Popper is required for tooltips to work\nwarn('v-b-tooltip: Popper.js is required for tooltips to work');return;}if(el[BVTT]){el[BVTT].updateConfig(parseBindings$1(bindings));}else{el[BVTT]=new ToolTip(el,parseBindings$1(bindings),vnode.context.$root);}}//\n// Remove tooltip on our element\n//\n/* istanbul ignore next: not easy to test */function removeBVTT(el){if(!inBrowser$3){return;}if(el[BVTT]){el[BVTT].destroy();el[BVTT]=null;delete el[BVTT];}}/*\n   * Export our directive\n   */ /* istanbul ignore next: not easy to test */var bTooltip={bind:function bind(el,bindings,vnode){applyBVTT(el,bindings,vnode);},inserted:function inserted(el,bindings,vnode){applyBVTT(el,bindings,vnode);},update:function update(el,bindings,vnode){if(bindings.value!==bindings.oldValue){applyBVTT(el,bindings,vnode);}},componentUpdated:function componentUpdated(el,bindings,vnode){if(bindings.value!==bindings.oldValue){applyBVTT(el,bindings,vnode);}},unbind:function unbind(el){removeBVTT(el);}};var directives$3={bTooltip:bTooltip};var tooltipDirectivePlugin={install:function install(Vue){registerDirectives(Vue,directives$3);}};var components$A={BTooltip:BTooltip};var index$x={install:function install(Vue){registerComponents(Vue,components$A);Vue.use(tooltipDirectivePlugin);}};var componentPlugins=/*#__PURE__*/Object.freeze({Alert:index,Badge:index$1,Breadcrumb:index$2,Button:index$3,ButtonToolbar:index$5,ButtonGroup:index$4,Card:index$7,Carousel:index$8,Collapse:collapsePlugin,Dropdown:dropdownPlugin,Embed:index$a,Form:index$b,FormGroup:index$c,FormInput:index$f,FormTextarea:index$g,FormFile:index$h,FormCheckbox:index$d,FormRadio:index$e,FormSelect:index$i,Image:index$j,InputGroup:index$6,Jumbotron:index$k,Layout:index$9,Link:index$l,ListGroup:index$m,Media:index$n,Modal:index$o,Nav:navPlugin,Navbar:index$p,Pagination:index$q,PaginationNav:index$r,Popover:index$s,Progress:index$t,Spinner:index$u,Table:index$v,Tabs:index$w,Tooltip:index$x});/*\n   * Constants / Defaults\n   */var NAME$2='v-b-scrollspy';var ACTIVATE_EVENT='bv::scrollspy::activate';var Default={element:'body',offset:10,method:'auto',throttle:75};var DefaultType={element:'(string|element|component)',offset:'number',method:'string',throttle:'number'};var ClassName$2={DROPDOWN_ITEM:'dropdown-item',ACTIVE:'active'};var Selector$4={ACTIVE:'.active',NAV_LIST_GROUP:'.nav, .list-group',NAV_LINKS:'.nav-link',NAV_ITEMS:'.nav-item',LIST_ITEMS:'.list-group-item',DROPDOWN:'.dropdown, .dropup',DROPDOWN_ITEMS:'.dropdown-item',DROPDOWN_TOGGLE:'.dropdown-toggle'};var OffsetMethod={OFFSET:'offset',POSITION:'position'// HREFs must start with # but can be === '#', or start with '#/' or '#!' (which can be router links)\n};var HREF_REGEX=/^#[^/!]+/;// Transition Events\nvar TransitionEndEvents$2=['webkitTransitionEnd','transitionend','otransitionend','oTransitionEnd'];// Options for events\nvar EventOptions$3={passive:true,capture:false/*\n     * Utility Methods\n     */ // Better var type detection\n};function toType(obj)/* istanbul ignore next: not easy to test */{return{}.toString.call(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();}// Check config properties for expected types\nfunction typeCheckConfig(componentName,config,configTypes)/* istanbul ignore next: not easy to test */{for(var property in configTypes){if(Object.prototype.hasOwnProperty.call(configTypes,property)){var expectedTypes=configTypes[property];var value=config[property];var valueType=value&&isElement(value)?'element':toType(value);// handle Vue instances\nvalueType=value&&value._isVue?'component':valueType;if(!new RegExp(expectedTypes).test(valueType)){warn(\"\".concat(componentName,\": Option \\\"\").concat(property,\"\\\" provided type \\\"\").concat(valueType,\"\\\" but expected type \\\"\").concat(expectedTypes,\"\\\"\"));}}}}/*\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */ /* istanbul ignore next: not easy to test */var ScrollSpy/* istanbul ignore next: not easy to test */=/*#__PURE__*/function(){function ScrollSpy(element,config,$root){_classCallCheck(this,ScrollSpy);// The element we activate links in\nthis.$el=element;this.$scroller=null;this.$selector=[Selector$4.NAV_LINKS,Selector$4.LIST_ITEMS,Selector$4.DROPDOWN_ITEMS].join(',');this.$offsets=[];this.$targets=[];this.$activeTarget=null;this.$scrollHeight=0;this.$resizeTimeout=null;this.$obs_scroller=null;this.$obs_targets=null;this.$root=$root||null;this.$config=null;this.updateConfig(config);}_createClass(ScrollSpy,[{key:\"updateConfig\",value:function updateConfig(config,$root){if(this.$scroller){// Just in case out scroll element has changed\nthis.unlisten();this.$scroller=null;}var cfg=_objectSpread({},this.constructor.Default,config);if($root){this.$root=$root;}typeCheckConfig(this.constructor.Name,cfg,this.constructor.DefaultType);this.$config=cfg;if(this.$root){var self=this;this.$root.$nextTick(function(){self.listen();});}else{this.listen();}}},{key:\"dispose\",value:function dispose(){this.unlisten();clearTimeout(this.$resizeTimeout);this.$resizeTimeout=null;this.$el=null;this.$config=null;this.$scroller=null;this.$selector=null;this.$offsets=null;this.$targets=null;this.$activeTarget=null;this.$scrollHeight=null;}},{key:\"listen\",value:function listen(){var _this=this;var scroller=this.getScroller();if(scroller&&scroller.tagName!=='BODY'){eventOn(scroller,'scroll',this,EventOptions$3);}eventOn(window,'scroll',this,EventOptions$3);eventOn(window,'resize',this,EventOptions$3);eventOn(window,'orientationchange',this,EventOptions$3);TransitionEndEvents$2.forEach(function(evtName){eventOn(window,evtName,_this,EventOptions$3);});this.setObservers(true);// Scedule a refresh\nthis.handleEvent('refresh');}},{key:\"unlisten\",value:function unlisten(){var _this2=this;var scroller=this.getScroller();this.setObservers(false);if(scroller&&scroller.tagName!=='BODY'){eventOff(scroller,'scroll',this,EventOptions$3);}eventOff(window,'scroll',this,EventOptions$3);eventOff(window,'resize',this,EventOptions$3);eventOff(window,'orientationchange',this,EventOptions$3);TransitionEndEvents$2.forEach(function(evtName){eventOff(window,evtName,_this2,EventOptions$3);});}},{key:\"setObservers\",value:function setObservers(on){var _this3=this;// We observe both the scroller for content changes, and the target links\nif(this.$obs_scroller){this.$obs_scroller.disconnect();this.$obs_scroller=null;}if(this.$obs_targets){this.$obs_targets.disconnect();this.$obs_targets=null;}if(on){this.$obs_targets=observeDom(this.$el,function(){_this3.handleEvent('mutation');},{subtree:true,childList:true,attributes:true,attributeFilter:['href']});this.$obs_scroller=observeDom(this.getScroller(),function(){_this3.handleEvent('mutation');},{subtree:true,childList:true,characterData:true,attributes:true,attributeFilter:['id','style','class']});}}// general event handler\n},{key:\"handleEvent\",value:function handleEvent(evt){var type=typeof evt==='string'?evt:evt.type;var self=this;function resizeThrottle(){if(!self.$resizeTimeout){self.$resizeTimeout=setTimeout(function(){self.refresh();self.process();self.$resizeTimeout=null;},self.$config.throttle);}}if(type==='scroll'){if(!this.$obs_scroller){// Just in case we are added to the DOM before the scroll target is\n// We re-instantiate our listeners, just in case\nthis.listen();}this.process();}else if(/(resize|orientationchange|mutation|refresh)/.test(type)){// Postpone these events by throttle time\nresizeThrottle();}}// Refresh the list of target links on the element we are applied to\n},{key:\"refresh\",value:function refresh(){var _this4=this;var scroller=this.getScroller();if(!scroller){return;}var autoMethod=scroller!==scroller.window?OffsetMethod.POSITION:OffsetMethod.OFFSET;var method=this.$config.method==='auto'?autoMethod:this.$config.method;var methodFn=method===OffsetMethod.POSITION?position:offset;var offsetBase=method===OffsetMethod.POSITION?this.getScrollTop():0;this.$offsets=[];this.$targets=[];this.$scrollHeight=this.getScrollHeight();// Find all the unique link href's\nselectAll(this.$selector,this.$el).map(function(link){return getAttr(link,'href');}).filter(function(href){return HREF_REGEX.test(href||'');}).map(function(href){var el=select(href,scroller);if(isVisible(el)){return{offset:parseInt(methodFn(el).top,10)+offsetBase,target:href};}return null;}).filter(function(item){return item;}).sort(function(a,b){return a.offset-b.offset;}).reduce(function(memo,item){// record only unique targets/offfsets\nif(!memo[item.target]){_this4.$offsets.push(item.offset);_this4.$targets.push(item.target);memo[item.target]=true;}return memo;},{});return this;}// Handle activating/clearing\n},{key:\"process\",value:function process(){var scrollTop=this.getScrollTop()+this.$config.offset;var scrollHeight=this.getScrollHeight();var maxScroll=this.$config.offset+scrollHeight-this.getOffsetHeight();if(this.$scrollHeight!==scrollHeight){this.refresh();}if(scrollTop>=maxScroll){var target=this.$targets[this.$targets.length-1];if(this.$activeTarget!==target){this.activate(target);}return;}if(this.$activeTarget&&scrollTop<this.$offsets[0]&&this.$offsets[0]>0){this.$activeTarget=null;this.clear();return;}for(var i=this.$offsets.length;i--;){var isActiveTarget=this.$activeTarget!==this.$targets[i]&&scrollTop>=this.$offsets[i]&&(typeof this.$offsets[i+1]==='undefined'||scrollTop<this.$offsets[i+1]);if(isActiveTarget){this.activate(this.$targets[i]);}}}},{key:\"getScroller\",value:function getScroller(){if(this.$scroller){return this.$scroller;}var scroller=this.$config.element;if(!scroller){return null;}else if(isElement(scroller.$el)){scroller=scroller.$el;}else if(typeof scroller==='string'){scroller=select(scroller);}if(!scroller){return null;}this.$scroller=scroller.tagName==='BODY'?window:scroller;return this.$scroller;}},{key:\"getScrollTop\",value:function getScrollTop(){var scroller=this.getScroller();return scroller===window?scroller.pageYOffset:scroller.scrollTop;}},{key:\"getScrollHeight\",value:function getScrollHeight(){return this.getScroller().scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight);}},{key:\"getOffsetHeight\",value:function getOffsetHeight(){var scroller=this.getScroller();return scroller===window?window.innerHeight:getBCR(scroller).height;}},{key:\"activate\",value:function activate(target){var _this5=this;this.$activeTarget=target;this.clear();// Grab the list of target links (<a href=\"{$target}\">)\nvar links=selectAll(this.$selector.split(',').map(function(selector){return\"\".concat(selector,\"[href=\\\"\").concat(target,\"\\\"]\");}).join(','),this.$el);links.forEach(function(link){if(hasClass(link,ClassName$2.DROPDOWN_ITEM)){// This is a dropdown item, so find the .dropdown-toggle and set it's state\nvar dropdown=closest(Selector$4.DROPDOWN,link);if(dropdown){_this5.setActiveState(select(Selector$4.DROPDOWN_TOGGLE,dropdown),true);}// Also set this link's state\n_this5.setActiveState(link,true);}else{// Set triggered link as active\n_this5.setActiveState(link,true);if(matches(link.parentElement,Selector$4.NAV_ITEMS)){// Handle nav-link inside nav-item, and set nav-item active\n_this5.setActiveState(link.parentElement,true);}// Set triggered links parents as active\n// With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\nvar el=link;while(el){el=closest(Selector$4.NAV_LIST_GROUP,el);var sibling=el?el.previousElementSibling:null;if(matches(sibling,\"\".concat(Selector$4.NAV_LINKS,\", \").concat(Selector$4.LIST_ITEMS))){_this5.setActiveState(sibling,true);}// Handle special case where nav-link is inside a nav-item\nif(matches(sibling,Selector$4.NAV_ITEMS)){_this5.setActiveState(select(Selector$4.NAV_LINKS,sibling),true);// Add active state to nav-item as well\n_this5.setActiveState(sibling,true);}}}});// Signal event to via $root, passing ID of activaed target and reference to array of links\nif(links&&links.length>0&&this.$root){this.$root.$emit(ACTIVATE_EVENT,target,links);}}},{key:\"clear\",value:function clear(){var _this6=this;selectAll(\"\".concat(this.$selector,\", \").concat(Selector$4.NAV_ITEMS),this.$el).filter(function(el){return hasClass(el,ClassName$2.ACTIVE);}).forEach(function(el){return _this6.setActiveState(el,false);});}},{key:\"setActiveState\",value:function setActiveState(el,active){if(!el){return;}if(active){addClass(el,ClassName$2.ACTIVE);}else{removeClass(el,ClassName$2.ACTIVE);}}}],[{key:\"Name\",get:function get(){return NAME$2;}},{key:\"Default\",get:function get(){return Default;}},{key:\"DefaultType\",get:function get(){return DefaultType;}}]);return ScrollSpy;}();var BVSS='__BV_ScrollSpy__';// Generate config from bindings\nfunction makeConfig(binding)/* istanbul ignore next: not easy to test */{var config={};// If Argument, assume element ID\nif(binding.arg){// Element ID specified as arg. We must pre-pend #\nconfig.element='#'+binding.arg;}// Process modifiers\nkeys(binding.modifiers).forEach(function(mod){if(/^\\d+$/.test(mod)){// Offest value\nconfig.offset=parseInt(mod,10);}else if(/^(auto|position|offset)$/.test(mod)){// Offset method\nconfig.method=mod;}});// Process value\nif(typeof binding.value==='string'){// Value is a CSS ID or selector\nconfig.element=binding.value;}else if(typeof binding.value==='number'){// Value is offset\nconfig.offset=Math.round(binding.value);}else if(_typeof(binding.value)==='object'){// Value is config object\n// Filter the object based on our supported config options\nkeys(binding.value).filter(function(k){return Boolean(ScrollSpy.DefaultType[k]);}).forEach(function(k){config[k]=binding.value[k];});}return config;}function addBVSS(el,binding,vnode)/* istanbul ignore next: not easy to test */{if(isServer){return;}var cfg=makeConfig(binding);if(!el[BVSS]){el[BVSS]=new ScrollSpy(el,cfg,vnode.context.$root);}else{el[BVSS].updateConfig(cfg,vnode.context.$root);}return el[BVSS];}function removeBVSS(el)/* istanbul ignore next: not easy to test */{if(el[BVSS]){el[BVSS].dispose();el[BVSS]=null;}}/*\n   * Export our directive\n   */var bScrollspy={bind:function bind(el,binding,vnode)/* istanbul ignore next: not easy to test */{addBVSS(el,binding,vnode);},inserted:function inserted(el,binding,vnode)/* istanbul ignore next: not easy to test */{addBVSS(el,binding,vnode);},update:function update(el,binding,vnode)/* istanbul ignore next: not easy to test */{addBVSS(el,binding,vnode);},componentUpdated:function componentUpdated(el,binding,vnode)/* istanbul ignore next: not easy to test */{addBVSS(el,binding,vnode);},unbind:function unbind(el)/* istanbul ignore next: not easy to test */{if(isServer){return;}// Remove scroll event listener on scrollElId\nremoveBVSS(el);}};var directives$4={bScrollspy:bScrollspy};var index$y={install:function install(Vue){registerDirectives(Vue,directives$4);}};var directivePlugins=/*#__PURE__*/Object.freeze({Toggle:toggleDirectivePlugin,Modal:modalDirectivePlugin,Scrollspy:index$y,Tooltip:tooltipDirectivePlugin,Popover:popoverDirectivePlugin});var VuePlugin={install:function install(Vue){// Register component plugins\nfor(var plugin in componentPlugins){Vue.use(componentPlugins[plugin]);}// Register directive plugins\nfor(var _plugin in directivePlugins){Vue.use(directivePlugins[_plugin]);}}};vueUse(VuePlugin);return VuePlugin;});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/bootstrap-vue/dist/bootstrap-vue.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  \"use strict\";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== \"function\") {\n      callback = new Function(\"\" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n    // So if we're currently running a task, we'll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // \"too much recursion\" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function registerImmediate(handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can't be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage(\"\", \"*\");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n    var onGlobalMessage = function onGlobalMessage(event) {\n      if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n      global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n\n    registerImmediate = function registerImmediate(handle) {\n      global.postMessage(messagePrefix + handle, \"*\");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function registerImmediate(handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function registerImmediate(handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var script = doc.createElement(\"script\");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function registerImmediate(handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === \"[object process]\") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n    // For IE 6–8\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\"); // On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./js/components/Scheduler.vue?vue&type=template&id=0f4b6a6c&scoped=true&":
/*!**************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./js/components/Scheduler.vue?vue&type=template&id=0f4b6a6c&scoped=true& ***!
  \**************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\")\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./js/components/Scheduler.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js?");

/***/ }),

/***/ "./node_modules/vue-router/dist/vue-router.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/vue-router/dist/vue-router.esm.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n  * vue-router v3.0.2\n  * (c) 2018 Evan You\n  * @license MIT\n  */\n\n/*  */\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(\"[vue-router] \" + message);\n  }\n}\n\nfunction warn(condition, message) {\n  if ( true && !condition) {\n    typeof console !== 'undefined' && console.warn(\"[vue-router] \" + message);\n  }\n}\n\nfunction isError(err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1;\n}\n\nfunction extend(a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n\n  return a;\n}\n\nvar View = {\n  name: 'RouterView',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render(_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data; // used by devtools to display a router-view badge\n\n    data.routerView = true; // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {}); // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n\n    var depth = 0;\n    var inactive = false;\n\n    while (parent && parent._routerRoot !== parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n\n      if (parent._inactive) {\n        inactive = true;\n      }\n\n      parent = parent.$parent;\n    }\n\n    data.routerViewDepth = depth; // render previous view if the tree is inactive and kept-alive\n\n    if (inactive) {\n      return h(cache[name], data, children);\n    }\n\n    var matched = route.matched[depth]; // render empty node if no matched route\n\n    if (!matched) {\n      cache[name] = null;\n      return h();\n    }\n\n    var component = cache[name] = matched.components[name]; // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n\n      if (val && current !== vm || !val && current === vm) {\n        matched.instances[name] = val;\n      }\n    } // also register instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;\n\n    (data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    }; // resolve props\n\n\n    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    if (propsToPass) {\n      // clone to prevent mutation\n      propsToPass = data.props = extend({}, propsToPass); // pass non-declared props as attrs\n\n      var attrs = data.attrs = data.attrs || {};\n\n      for (var key in propsToPass) {\n        if (!component.props || !(key in component.props)) {\n          attrs[key] = propsToPass[key];\n          delete propsToPass[key];\n        }\n      }\n    }\n\n    return h(component, data, children);\n  }\n};\n\nfunction resolveProps(route, config) {\n  switch (_typeof(config)) {\n    case 'undefined':\n      return;\n\n    case 'object':\n      return config;\n\n    case 'function':\n      return config(route);\n\n    case 'boolean':\n      return config ? route.params : undefined;\n\n    default:\n      if (true) {\n        warn(false, \"props in \\\"\" + route.path + \"\\\" is a \" + _typeof(config) + \", \" + \"expecting an object, function or boolean.\");\n      }\n\n  }\n}\n/*  */\n\n\nvar encodeReserveRE = /[!'()*]/g;\n\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n};\n\nvar commaRE = /%2C/g; // fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\n\nvar encode = function encode(str) {\n  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');\n};\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery(query, extraQuery, _parseQuery) {\n  if (extraQuery === void 0) extraQuery = {};\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n     true && warn(false, e.message);\n    parsedQuery = {};\n  }\n\n  for (var key in extraQuery) {\n    parsedQuery[key] = extraQuery[key];\n  }\n\n  return parsedQuery;\n}\n\nfunction parseQuery(query) {\n  var res = {};\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n  return res;\n}\n\nfunction stringifyQuery(obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return '';\n    }\n\n    if (val === null) {\n      return encode(key);\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return;\n        }\n\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&');\n    }\n\n    return encode(key) + '=' + encode(val);\n  }).filter(function (x) {\n    return x.length > 0;\n  }).join('&') : null;\n  return res ? \"?\" + res : '';\n}\n/*  */\n\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute(record, location, redirectedFrom, router) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n  var query = location.query || {};\n\n  try {\n    query = clone(query);\n  } catch (e) {}\n\n  var route = {\n    name: location.name || record && record.name,\n    meta: record && record.meta || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n\n  return Object.freeze(route);\n}\n\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  } else if (value && _typeof(value) === 'object') {\n    var res = {};\n\n    for (var key in value) {\n      res[key] = clone(value[key]);\n    }\n\n    return res;\n  } else {\n    return value;\n  }\n} // the starting route that represents the initial state\n\n\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch(record) {\n  var res = [];\n\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n\n  return res;\n}\n\nfunction getFullPath(ref, _stringifyQuery) {\n  var path = ref.path;\n  var query = ref.query;\n  if (query === void 0) query = {};\n  var hash = ref.hash;\n  if (hash === void 0) hash = '';\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash;\n}\n\nfunction isSameRoute(a, b) {\n  if (b === START) {\n    return a === b;\n  } else if (!b) {\n    return false;\n  } else if (a.path && b.path) {\n    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);\n  } else if (a.name && b.name) {\n    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);\n  } else {\n    return false;\n  }\n}\n\nfunction isObjectEqual(a, b) {\n  if (a === void 0) a = {};\n  if (b === void 0) b = {}; // handle null value #1566\n\n  if (!a || !b) {\n    return a === b;\n  }\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key]; // check nested equality\n\n    if (_typeof(aVal) === 'object' && _typeof(bVal) === 'object') {\n      return isObjectEqual(aVal, bVal);\n    }\n\n    return String(aVal) === String(bVal);\n  });\n}\n\nfunction isIncludedRoute(current, target) {\n  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);\n}\n\nfunction queryIncludes(current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*  */\n// work around weird flow bug\n\n\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\nvar Link = {\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass; // Support global empty active class\n\n    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;\n    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;\n    var compareTarget = location.path ? createRoute(null, location, null, router) : route;\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);\n\n    var handler = function handler(e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = {\n      click: guardEvent\n    };\n\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) {\n        on[e] = handler;\n      });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = {\n        href: href\n      };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default);\n  }\n};\n\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {\n    return;\n  } // don't redirect when preventDefault called\n\n\n  if (e.defaultPrevented) {\n    return;\n  } // don't redirect on right click\n\n\n  if (e.button !== undefined && e.button !== 0) {\n    return;\n  } // don't redirect if `target=\"_blank\"`\n\n\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n\n    if (/\\b_blank\\b/i.test(target)) {\n      return;\n    }\n  } // this may be a Weex event which doesn't have this method\n\n\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n\n  return true;\n}\n\nfunction findAnchor(children) {\n  if (children) {\n    var child;\n\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (child.tag === 'a') {\n        return child;\n      }\n\n      if (child.children && (child = findAnchor(child.children))) {\n        return child;\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install(Vue) {\n  if (install.installed && _Vue === Vue) {\n    return;\n  }\n\n  install.installed = true;\n  _Vue = Vue;\n\n  var isDef = function isDef(v) {\n    return v !== undefined;\n  };\n\n  var registerInstance = function registerInstance(vm, callVal) {\n    var i = vm.$options._parentVnode;\n\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate() {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n\n        this._router.init(this);\n\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = this.$parent && this.$parent._routerRoot || this;\n      }\n\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed() {\n      registerInstance(this);\n    }\n  });\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get() {\n      return this._routerRoot._router;\n    }\n  });\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get() {\n      return this._routerRoot._route;\n    }\n  });\n  Vue.component('RouterView', View);\n  Vue.component('RouterLink', Link);\n  var strats = Vue.config.optionMergeStrategies; // use the same hook merging strategy for route hooks\n\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n/*  */\n\n\nvar inBrowser = typeof window !== 'undefined';\n/*  */\n\nfunction resolvePath(relative, base, append) {\n  var firstChar = relative.charAt(0);\n\n  if (firstChar === '/') {\n    return relative;\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative;\n  }\n\n  var stack = base.split('/'); // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  } // resolve relative path\n\n\n  var segments = relative.replace(/^\\//, '').split('/');\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  } // ensure leading slash\n\n\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/');\n}\n\nfunction parsePath(path) {\n  var hash = '';\n  var query = '';\n  var hashIndex = path.indexOf('#');\n\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n\nfunction cleanPath(path) {\n  return path.replace(/\\/\\//g, '/');\n}\n\nvar isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n/**\n * Expose `pathToRegexp`.\n */\n\n\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\n\nvar PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)', // Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\n\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length; // Ignore already escaped sequences.\n\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7]; // Push the current path onto the tokens.\n\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  } // Match any characters still remaining.\n\n\n  if (index < str.length) {\n    path += str.substr(index);\n  } // If the path exists, push it onto the end.\n\n\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\n\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options));\n}\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\n\nfunction tokensToFunction(tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length); // Compile all the patterns before compilation.\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (_typeof(tokens[i]) === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\n\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\n\n\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\n\n\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\n\n\nfunction flags(options) {\n  return options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n  return attachKeys(regexp, keys);\n}\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\n\n\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = ''; // Iterate over the tokens and create our regexp string.\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\n\n\nfunction pathToRegexp(path, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path,\n    /** @type {!Array} */\n    keys);\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(\n    /** @type {!Array} */\n    path,\n    /** @type {!Array} */\n    keys, options);\n  }\n\n  return stringToRegexp(\n  /** @type {string} */\n  path,\n  /** @type {!Array} */\n  keys, options);\n}\n\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n/*  */\n// $flow-disable-line\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams(path, params, routeMsg) {\n  try {\n    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n    return filler(params || {}, {\n      pretty: true\n    });\n  } catch (e) {\n    if (true) {\n      warn(false, \"missing param for \" + routeMsg + \": \" + e.message);\n    }\n\n    return '';\n  }\n}\n/*  */\n\n\nfunction createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || []; // $flow-disable-line\n\n  var pathMap = oldPathMap || Object.create(null); // $flow-disable-line\n\n  var nameMap = oldNameMap || Object.create(null);\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  }); // ensure wildcard routes are always at the end\n\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  };\n}\n\nfunction addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {\n  var path = route.path;\n  var name = route.name;\n\n  if (true) {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(typeof route.component !== 'string', \"route config \\\"component\\\" for path: \" + String(path || name) + \" cannot be a \" + \"string id. Use an actual component instead.\");\n  }\n\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || {\n      default: route.component\n    },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null ? {} : route.components ? route.props : {\n      default: route.props\n    }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (true) {\n      if (route.name && !route.redirect && route.children.some(function (child) {\n        return /^\\/?$/.test(child.path);\n      })) {\n        warn(false, \"Named Route '\" + route.name + \"' has a default child route. \" + \"When navigating to this named route (:to=\\\"{name: '\" + route.name + \"'\\\"), \" + \"the default child route will not be rendered. Remove the name from \" + \"this route and use the name of the default child route for named \" + \"links instead.\");\n      }\n    }\n\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs ? cleanPath(matchAs + \"/\" + child.path) : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if ( true && !matchAs) {\n      warn(false, \"Duplicate named routes definition: \" + \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + record.path + \"\\\" }\");\n    }\n  }\n}\n\nfunction compileRouteRegex(path, pathToRegexpOptions) {\n  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n\n  if (true) {\n    var keys = Object.create(null);\n    regex.keys.forEach(function (key) {\n      warn(!keys[key.name], \"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\");\n      keys[key.name] = true;\n    });\n  }\n\n  return regex;\n}\n\nfunction normalizePath(path, parent, strict) {\n  if (!strict) {\n    path = path.replace(/\\/$/, '');\n  }\n\n  if (path[0] === '/') {\n    return path;\n  }\n\n  if (parent == null) {\n    return path;\n  }\n\n  return cleanPath(parent.path + \"/\" + path);\n}\n/*  */\n\n\nfunction normalizeLocation(raw, current, append, router) {\n  var next = typeof raw === 'string' ? {\n    path: raw\n  } : raw; // named target\n\n  if (next.name || next._normalized) {\n    return next;\n  } // relative params\n\n\n  if (!next.path && next.params && current) {\n    next = extend({}, next);\n    next._normalized = true;\n    var params = extend(extend({}, current.params), next.params);\n\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, \"path \" + current.path);\n    } else if (true) {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n\n    return next;\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = current && current.path || '/';\n  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;\n  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);\n  var hash = next.hash || parsedPath.hash;\n\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n/*  */\n\n\nfunction createMatcher(routes, router) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes(routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match(raw, currentRoute, redirectedFrom) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n\n      if (true) {\n        warn(record, \"Route with name '\" + name + \"' does not exist\");\n      }\n\n      if (!record) {\n        return _createRoute(null, location);\n      }\n\n      var paramNames = record.regex.keys.filter(function (key) {\n        return !key.optional;\n      }).map(function (key) {\n        return key.name;\n      });\n\n      if (_typeof(location.params) !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && _typeof(currentRoute.params) === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, \"named route \\\"\" + name + \"\\\"\");\n        return _createRoute(record, location, redirectedFrom);\n      }\n    } else if (location.path) {\n      location.params = {};\n\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom);\n        }\n      }\n    } // no match\n\n\n    return _createRoute(null, location);\n  }\n\n  function redirect(record, location) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = {\n        path: redirect\n      };\n    }\n\n    if (!redirect || _typeof(redirect) !== 'object') {\n      if (true) {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n\n      return _createRoute(null, location);\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n\n      if (true) {\n        assert(targetRecord, \"redirect failed: named route \\\"\" + name + \"\\\" not found.\");\n      }\n\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location);\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record); // 2. resolve params\n\n      var resolvedPath = fillParams(rawPath, params, \"redirect route with path \\\"\" + rawPath + \"\\\"\"); // 3. rematch with existing query and hash\n\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location);\n    } else {\n      if (true) {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n\n      return _createRoute(null, location);\n    }\n  }\n\n  function alias(record, location, matchAs) {\n    var aliasedPath = fillParams(matchAs, location.params, \"aliased route with path \\\"\" + matchAs + \"\\\"\");\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location);\n    }\n\n    return _createRoute(null, location);\n  }\n\n  function _createRoute(record, location, redirectedFrom) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location);\n    }\n\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs);\n    }\n\n    return createRoute(record, location, redirectedFrom, router);\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  };\n}\n\nfunction matchRoute(regex, path, params) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false;\n  } else if (!params) {\n    return true;\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n\n    if (key) {\n      // Fix #1994: using * with props: true generates a param named 0\n      params[key.name || 'pathMatch'] = val;\n    }\n  }\n\n  return true;\n}\n\nfunction resolveRecordPath(path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true);\n}\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll() {\n  // Fix for #1585 for Firefox\n  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678\n  window.history.replaceState({\n    key: getStateKey()\n  }, '', window.location.href.replace(window.location.origin, ''));\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll(router, to, from, isPop) {\n  if (!router.app) {\n    return;\n  }\n\n  var behavior = router.options.scrollBehavior;\n\n  if (!behavior) {\n    return;\n  }\n\n  if (true) {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  } // wait until re-render finishes before scrolling\n\n\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior.call(router, to, from, isPop ? position : null);\n\n    if (!shouldScroll) {\n      return;\n    }\n\n    if (typeof shouldScroll.then === 'function') {\n      shouldScroll.then(function (shouldScroll) {\n        scrollToPosition(shouldScroll, position);\n      }).catch(function (err) {\n        if (true) {\n          assert(false, err.toString());\n        }\n      });\n    } else {\n      scrollToPosition(shouldScroll, position);\n    }\n  });\n}\n\nfunction saveScrollPosition() {\n  var key = getStateKey();\n\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition() {\n  var key = getStateKey();\n\n  if (key) {\n    return positionStore[key];\n  }\n}\n\nfunction getElementPosition(el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  };\n}\n\nfunction isValidPosition(obj) {\n  return isNumber(obj.x) || isNumber(obj.y);\n}\n\nfunction normalizePosition(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  };\n}\n\nfunction normalizeOffset(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  };\n}\n\nfunction isNumber(v) {\n  return typeof v === 'number';\n}\n\nfunction scrollToPosition(shouldScroll, position) {\n  var isObject = _typeof(shouldScroll) === 'object';\n\n  if (isObject && typeof shouldScroll.selector === 'string') {\n    var el = document.querySelector(shouldScroll.selector);\n\n    if (el) {\n      var offset = shouldScroll.offset && _typeof(shouldScroll.offset) === 'object' ? shouldScroll.offset : {};\n      offset = normalizeOffset(offset);\n      position = getElementPosition(el, offset);\n    } else if (isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n  } else if (isObject && isValidPosition(shouldScroll)) {\n    position = normalizePosition(shouldScroll);\n  }\n\n  if (position) {\n    window.scrollTo(position.x, position.y);\n  }\n}\n/*  */\n\n\nvar supportsPushState = inBrowser && function () {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n\n  return window.history && 'pushState' in window.history;\n}(); // use User Timing api (if present) for more accurate key precision\n\n\nvar Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;\n\nvar _key = genKey();\n\nfunction genKey() {\n  return Time.now().toFixed(3);\n}\n\nfunction getStateKey() {\n  return _key;\n}\n\nfunction setStateKey(key) {\n  _key = key;\n}\n\nfunction pushState(url, replace) {\n  saveScrollPosition(); // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n\n  var history = window.history;\n\n  try {\n    if (replace) {\n      history.replaceState({\n        key: _key\n      }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({\n        key: _key\n      }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState(url) {\n  pushState(url, true);\n}\n/*  */\n\n\nfunction runQueue(queue, fn, cb) {\n  var step = function step(index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n\n  step(0);\n}\n/*  */\n\n\nfunction resolveAsyncComponents(matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n        var resolve = once(function (resolvedDef) {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default;\n          } // save resolved on async factory in case it's used elsewhere\n\n\n          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n\n          if (pending <= 0) {\n            next();\n          }\n        });\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n           true && warn(false, msg);\n\n          if (!error) {\n            error = isError(reason) ? reason : new Error(msg);\n            next(error);\n          }\n        });\n        var res;\n\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) {\n      next();\n    }\n  };\n}\n\nfunction flatMapComponents(matched, fn) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return fn(m.components[key], m.instances[key], m, key);\n    });\n  }));\n}\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nvar hasSymbol = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';\n\nfunction isESModule(obj) {\n  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';\n} // in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\n\n\nfunction once(fn) {\n  var called = false;\n  return function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    if (called) {\n      return;\n    }\n\n    called = true;\n    return fn.apply(this, args);\n  };\n}\n/*  */\n\n\nvar History = function History(router, base) {\n  this.router = router;\n  this.base = normalizeBase(base); // start with a route object that stands for \"nowhere\"\n\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen(cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady(cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError(errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {\n  var this$1 = this;\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL(); // fire ready cbs once\n\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) {\n        cb(err);\n      });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {\n  var this$1 = this;\n  var current = this.current;\n\n  var abort = function abort(err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) {\n          cb(err);\n        });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n\n    onAbort && onAbort(err);\n  };\n\n  if (isSameRoute(route, current) && // in the case the route map has been dynamically appended to\n  route.matched.length === current.matched.length) {\n    this.ensureURL();\n    return abort();\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n  var updated = ref.updated;\n  var deactivated = ref.deactivated;\n  var activated = ref.activated;\n  var queue = [].concat( // in-component leave guards\n  extractLeaveGuards(deactivated), // global before hooks\n  this.router.beforeHooks, // in-component update hooks\n  extractUpdateHooks(updated), // in-config enter guards\n  activated.map(function (m) {\n    return m.beforeEnter;\n  }), // async components\n  resolveAsyncComponents(activated));\n  this.pending = route;\n\n  var iterator = function iterator(hook, next) {\n    if (this$1.pending !== route) {\n      return abort();\n    }\n\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (typeof to === 'string' || _typeof(to) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n\n          if (_typeof(to) === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n\n    var isValid = function isValid() {\n      return this$1.current === route;\n    }; // wait until async components are resolved before\n    // extracting in-component enter guards\n\n\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort();\n      }\n\n      this$1.pending = null;\n      onComplete(route);\n\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) {\n            cb();\n          });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute(route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase(base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin\n\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  } // make sure there's the starting slash\n\n\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  } // remove trailing slash\n\n\n  return base.replace(/\\/$/, '');\n}\n\nfunction resolveQueue(current, next) {\n  var i;\n  var max = Math.max(current.length, next.length);\n\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break;\n    }\n  }\n\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  };\n}\n\nfunction extractGuards(records, name, bind, reverse) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n\n    if (guard) {\n      return Array.isArray(guard) ? guard.map(function (guard) {\n        return bind(guard, instance, match, key);\n      }) : bind(guard, instance, match, key);\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards);\n}\n\nfunction extractGuard(def, key) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n\n  return def.options[key];\n}\n\nfunction extractLeaveGuards(deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);\n}\n\nfunction extractUpdateHooks(updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);\n}\n\nfunction bindGuard(guard, instance) {\n  if (instance) {\n    return function boundRouteGuard() {\n      return guard.apply(instance, arguments);\n    };\n  }\n}\n\nfunction extractEnterGuards(activated, cbs, isValid) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid);\n  });\n}\n\nfunction bindEnterGuard(guard, match, key, cbs, isValid) {\n  return function routeEnterGuard(to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    });\n  };\n}\n\nfunction poll(cb, // somehow flow cannot infer this is a function\ninstances, key, isValid) {\n  if (instances[key] && !instances[key]._isBeingDestroyed // do not reuse being destroyed instance\n  ) {\n      cb(instances[key]);\n    } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n/*  */\n\n\nvar HTML5History = function (History$$1) {\n  function HTML5History(router, base) {\n    var this$1 = this;\n    History$$1.call(this, router, base);\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      setupScroll();\n    }\n\n    var initLocation = getLocation(this.base);\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current; // Avoiding first `popstate` event dispatched in some browsers but first\n      // history route not updated since async guard at the same time.\n\n      var location = getLocation(this$1.base);\n\n      if (this$1.current === START && location === initLocation) {\n        return;\n      }\n\n      this$1.transitionTo(location, function (route) {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if (History$$1) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL(push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getLocation(this.base);\n  };\n\n  return HTML5History;\n}(History);\n\nfunction getLocation(base) {\n  var path = decodeURI(window.location.pathname);\n\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n\n  return (path || '/') + window.location.search + window.location.hash;\n}\n/*  */\n\n\nvar HashHistory = function (History$$1) {\n  function HashHistory(router, base, fallback) {\n    History$$1.call(this, router, base); // check history fallback deeplinking\n\n    if (fallback && checkFallback(this.base)) {\n      return;\n    }\n\n    ensureSlash();\n  }\n\n  if (History$$1) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  HashHistory.prototype.constructor = HashHistory; // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n\n  HashHistory.prototype.setupListeners = function setupListeners() {\n    var this$1 = this;\n    var router = this.router;\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {\n      var current = this$1.current;\n\n      if (!ensureSlash()) {\n        return;\n      }\n\n      this$1.transitionTo(getHash(), function (route) {\n        if (supportsScroll) {\n          handleScroll(this$1.router, route, current, true);\n        }\n\n        if (!supportsPushState) {\n          replaceHash(route.fullPath);\n        }\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL(push) {\n    var current = this.current.fullPath;\n\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getHash();\n  };\n\n  return HashHistory;\n}(History);\n\nfunction checkFallback(base) {\n  var location = getLocation(base);\n\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + '/#' + location));\n    return true;\n  }\n}\n\nfunction ensureSlash() {\n  var path = getHash();\n\n  if (path.charAt(0) === '/') {\n    return true;\n  }\n\n  replaceHash('/' + path);\n  return false;\n}\n\nfunction getHash() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : decodeURI(href.slice(index + 1));\n}\n\nfunction getUrl(path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  return base + \"#\" + path;\n}\n\nfunction pushHash(path) {\n  if (supportsPushState) {\n    pushState(getUrl(path));\n  } else {\n    window.location.hash = path;\n  }\n}\n\nfunction replaceHash(path) {\n  if (supportsPushState) {\n    replaceState(getUrl(path));\n  } else {\n    window.location.replace(getUrl(path));\n  }\n}\n/*  */\n\n\nvar AbstractHistory = function (History$$1) {\n  function AbstractHistory(router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if (History$$1) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go(n) {\n    var this$1 = this;\n    var targetIndex = this.index + n;\n\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return;\n    }\n\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/';\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL() {// noop\n  };\n\n  return AbstractHistory;\n}(History);\n/*  */\n\n\nvar VueRouter = function VueRouter(options) {\n  if (options === void 0) options = {};\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n\n  if (this.fallback) {\n    mode = 'hash';\n  }\n\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break;\n\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break;\n\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break;\n\n    default:\n      if (true) {\n        assert(false, \"invalid mode: \" + mode);\n      }\n\n  }\n};\n\nvar prototypeAccessors = {\n  currentRoute: {\n    configurable: true\n  }\n};\n\nVueRouter.prototype.match = function match(raw, current, redirectedFrom) {\n  return this.matcher.match(raw, current, redirectedFrom);\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current;\n};\n\nVueRouter.prototype.init = function init(app\n/* Vue component instance */\n) {\n  var this$1 = this;\n   true && assert(install.installed, \"not installed. Make sure to call `Vue.use(VueRouter)` \" + \"before creating root instance.\");\n  this.apps.push(app); // main app already initialized.\n\n  if (this.app) {\n    return;\n  }\n\n  this.app = app;\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function setupHashListener() {\n      history.setupListeners();\n    };\n\n    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach(fn) {\n  return registerHook(this.beforeHooks, fn);\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve(fn) {\n  return registerHook(this.resolveHooks, fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach(fn) {\n  return registerHook(this.afterHooks, fn);\n};\n\nVueRouter.prototype.onReady = function onReady(cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError(errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push(location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace(location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go(n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back() {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward() {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {\n  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;\n\n  if (!route) {\n    return [];\n  }\n\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key];\n    });\n  }));\n};\n\nVueRouter.prototype.resolve = function resolve(to, current, append) {\n  var location = normalizeLocation(to, current || this.history.current, append, this);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  };\n};\n\nVueRouter.prototype.addRoutes = function addRoutes(routes) {\n  this.matcher.addRoutes(routes);\n\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties(VueRouter.prototype, prototypeAccessors);\n\nfunction registerHook(list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n\n    if (i > -1) {\n      list.splice(i, 1);\n    }\n  };\n}\n\nfunction createHref(base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path;\n}\n\nVueRouter.install = install;\nVueRouter.version = '3.0.2';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VueRouter);\n\n//# sourceURL=webpack:///./node_modules/vue-router/dist/vue-router.esm.js?");

/***/ }),

/***/ "./node_modules/vue/dist/vue.min.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.min.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n!function (e, t) {\n  \"object\" == ( false ? undefined : _typeof(exports)) && \"undefined\" != typeof module ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(this, function () {\n  \"use strict\";\n\n  var e = Object.freeze({});\n\n  function t(e) {\n    return null == e;\n  }\n\n  function n(e) {\n    return null != e;\n  }\n\n  function r(e) {\n    return !0 === e;\n  }\n\n  function i(e) {\n    return \"string\" == typeof e || \"number\" == typeof e || \"symbol\" == _typeof(e) || \"boolean\" == typeof e;\n  }\n\n  function o(e) {\n    return null !== e && \"object\" == _typeof(e);\n  }\n\n  var a = Object.prototype.toString;\n\n  function s(e) {\n    return \"[object Object]\" === a.call(e);\n  }\n\n  function c(e) {\n    var t = parseFloat(String(e));\n    return t >= 0 && Math.floor(t) === t && isFinite(e);\n  }\n\n  function u(e) {\n    return n(e) && \"function\" == typeof e.then && \"function\" == typeof e.catch;\n  }\n\n  function l(e) {\n    return null == e ? \"\" : Array.isArray(e) || s(e) && e.toString === a ? JSON.stringify(e, null, 2) : String(e);\n  }\n\n  function f(e) {\n    var t = parseFloat(e);\n    return isNaN(t) ? e : t;\n  }\n\n  function p(e, t) {\n    for (var n = Object.create(null), r = e.split(\",\"), i = 0; i < r.length; i++) {\n      n[r[i]] = !0;\n    }\n\n    return t ? function (e) {\n      return n[e.toLowerCase()];\n    } : function (e) {\n      return n[e];\n    };\n  }\n\n  var d = p(\"slot,component\", !0),\n      v = p(\"key,ref,slot,slot-scope,is\");\n\n  function h(e, t) {\n    if (e.length) {\n      var n = e.indexOf(t);\n      if (n > -1) return e.splice(n, 1);\n    }\n  }\n\n  var m = Object.prototype.hasOwnProperty;\n\n  function y(e, t) {\n    return m.call(e, t);\n  }\n\n  function g(e) {\n    var t = Object.create(null);\n    return function (n) {\n      return t[n] || (t[n] = e(n));\n    };\n  }\n\n  var _ = /-(\\w)/g,\n      b = g(function (e) {\n    return e.replace(_, function (e, t) {\n      return t ? t.toUpperCase() : \"\";\n    });\n  }),\n      $ = g(function (e) {\n    return e.charAt(0).toUpperCase() + e.slice(1);\n  }),\n      w = /\\B([A-Z])/g,\n      C = g(function (e) {\n    return e.replace(w, \"-$1\").toLowerCase();\n  });\n  var x = Function.prototype.bind ? function (e, t) {\n    return e.bind(t);\n  } : function (e, t) {\n    function n(n) {\n      var r = arguments.length;\n      return r ? r > 1 ? e.apply(t, arguments) : e.call(t, n) : e.call(t);\n    }\n\n    return n._length = e.length, n;\n  };\n\n  function k(e, t) {\n    t = t || 0;\n\n    for (var n = e.length - t, r = new Array(n); n--;) {\n      r[n] = e[n + t];\n    }\n\n    return r;\n  }\n\n  function A(e, t) {\n    for (var n in t) {\n      e[n] = t[n];\n    }\n\n    return e;\n  }\n\n  function O(e) {\n    for (var t = {}, n = 0; n < e.length; n++) {\n      e[n] && A(t, e[n]);\n    }\n\n    return t;\n  }\n\n  function S(e, t, n) {}\n\n  var T = function T(e, t, n) {\n    return !1;\n  },\n      E = function E(e) {\n    return e;\n  };\n\n  function N(e, t) {\n    if (e === t) return !0;\n    var n = o(e),\n        r = o(t);\n    if (!n || !r) return !n && !r && String(e) === String(t);\n\n    try {\n      var i = Array.isArray(e),\n          a = Array.isArray(t);\n      if (i && a) return e.length === t.length && e.every(function (e, n) {\n        return N(e, t[n]);\n      });\n      if (e instanceof Date && t instanceof Date) return e.getTime() === t.getTime();\n      if (i || a) return !1;\n      var s = Object.keys(e),\n          c = Object.keys(t);\n      return s.length === c.length && s.every(function (n) {\n        return N(e[n], t[n]);\n      });\n    } catch (e) {\n      return !1;\n    }\n  }\n\n  function j(e, t) {\n    for (var n = 0; n < e.length; n++) {\n      if (N(e[n], t)) return n;\n    }\n\n    return -1;\n  }\n\n  function D(e) {\n    var t = !1;\n    return function () {\n      t || (t = !0, e.apply(this, arguments));\n    };\n  }\n\n  var L = \"data-server-rendered\",\n      M = [\"component\", \"directive\", \"filter\"],\n      I = [\"beforeCreate\", \"created\", \"beforeMount\", \"mounted\", \"beforeUpdate\", \"updated\", \"beforeDestroy\", \"destroyed\", \"activated\", \"deactivated\", \"errorCaptured\", \"serverPrefetch\"],\n      F = {\n    optionMergeStrategies: Object.create(null),\n    silent: !1,\n    productionTip: !1,\n    devtools: !1,\n    performance: !1,\n    errorHandler: null,\n    warnHandler: null,\n    ignoredElements: [],\n    keyCodes: Object.create(null),\n    isReservedTag: T,\n    isReservedAttr: T,\n    isUnknownElement: T,\n    getTagNamespace: S,\n    parsePlatformTagName: E,\n    mustUseProp: T,\n    async: !0,\n    _lifecycleHooks: I\n  },\n      P = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n  function R(e, t, n, r) {\n    Object.defineProperty(e, t, {\n      value: n,\n      enumerable: !!r,\n      writable: !0,\n      configurable: !0\n    });\n  }\n\n  var H = new RegExp(\"[^\" + P.source + \".$_\\\\d]\");\n  var B,\n      U = \"__proto__\" in {},\n      z = \"undefined\" != typeof window,\n      V = \"undefined\" != typeof WXEnvironment && !!WXEnvironment.platform,\n      K = V && WXEnvironment.platform.toLowerCase(),\n      J = z && window.navigator.userAgent.toLowerCase(),\n      q = J && /msie|trident/.test(J),\n      W = J && J.indexOf(\"msie 9.0\") > 0,\n      Z = J && J.indexOf(\"edge/\") > 0,\n      G = (J && J.indexOf(\"android\"), J && /iphone|ipad|ipod|ios/.test(J) || \"ios\" === K),\n      X = (J && /chrome\\/\\d+/.test(J), J && /phantomjs/.test(J), J && J.match(/firefox\\/(\\d+)/)),\n      Y = {}.watch,\n      Q = !1;\n  if (z) try {\n    var ee = {};\n    Object.defineProperty(ee, \"passive\", {\n      get: function get() {\n        Q = !0;\n      }\n    }), window.addEventListener(\"test-passive\", null, ee);\n  } catch (e) {}\n\n  var te = function te() {\n    return void 0 === B && (B = !z && !V && \"undefined\" != typeof global && global.process && \"server\" === global.process.env.VUE_ENV), B;\n  },\n      ne = z && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  function re(e) {\n    return \"function\" == typeof e && /native code/.test(e.toString());\n  }\n\n  var ie,\n      oe = \"undefined\" != typeof Symbol && re(Symbol) && \"undefined\" != typeof Reflect && re(Reflect.ownKeys);\n  ie = \"undefined\" != typeof Set && re(Set) ? Set : function () {\n    function e() {\n      this.set = Object.create(null);\n    }\n\n    return e.prototype.has = function (e) {\n      return !0 === this.set[e];\n    }, e.prototype.add = function (e) {\n      this.set[e] = !0;\n    }, e.prototype.clear = function () {\n      this.set = Object.create(null);\n    }, e;\n  }();\n\n  var ae = S,\n      se = 0,\n      ce = function ce() {\n    this.id = se++, this.subs = [];\n  };\n\n  ce.prototype.addSub = function (e) {\n    this.subs.push(e);\n  }, ce.prototype.removeSub = function (e) {\n    h(this.subs, e);\n  }, ce.prototype.depend = function () {\n    ce.target && ce.target.addDep(this);\n  }, ce.prototype.notify = function () {\n    for (var e = this.subs.slice(), t = 0, n = e.length; t < n; t++) {\n      e[t].update();\n    }\n  }, ce.target = null;\n  var ue = [];\n\n  function le(e) {\n    ue.push(e), ce.target = e;\n  }\n\n  function fe() {\n    ue.pop(), ce.target = ue[ue.length - 1];\n  }\n\n  var pe = function pe(e, t, n, r, i, o, a, s) {\n    this.tag = e, this.data = t, this.children = n, this.text = r, this.elm = i, this.ns = void 0, this.context = o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = t && t.key, this.componentOptions = a, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;\n  },\n      de = {\n    child: {\n      configurable: !0\n    }\n  };\n\n  de.child.get = function () {\n    return this.componentInstance;\n  }, Object.defineProperties(pe.prototype, de);\n\n  var ve = function ve(e) {\n    void 0 === e && (e = \"\");\n    var t = new pe();\n    return t.text = e, t.isComment = !0, t;\n  };\n\n  function he(e) {\n    return new pe(void 0, void 0, void 0, String(e));\n  }\n\n  function me(e) {\n    var t = new pe(e.tag, e.data, e.children && e.children.slice(), e.text, e.elm, e.context, e.componentOptions, e.asyncFactory);\n    return t.ns = e.ns, t.isStatic = e.isStatic, t.key = e.key, t.isComment = e.isComment, t.fnContext = e.fnContext, t.fnOptions = e.fnOptions, t.fnScopeId = e.fnScopeId, t.asyncMeta = e.asyncMeta, t.isCloned = !0, t;\n  }\n\n  var ye = Array.prototype,\n      ge = Object.create(ye);\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\", \"sort\", \"reverse\"].forEach(function (e) {\n    var t = ye[e];\n    R(ge, e, function () {\n      for (var n = [], r = arguments.length; r--;) {\n        n[r] = arguments[r];\n      }\n\n      var i,\n          o = t.apply(this, n),\n          a = this.__ob__;\n\n      switch (e) {\n        case \"push\":\n        case \"unshift\":\n          i = n;\n          break;\n\n        case \"splice\":\n          i = n.slice(2);\n      }\n\n      return i && a.observeArray(i), a.dep.notify(), o;\n    });\n  });\n\n  var _e = Object.getOwnPropertyNames(ge),\n      be = !0;\n\n  function $e(e) {\n    be = e;\n  }\n\n  var we = function we(e) {\n    var t;\n    this.value = e, this.dep = new ce(), this.vmCount = 0, R(e, \"__ob__\", this), Array.isArray(e) ? (U ? (t = ge, e.__proto__ = t) : function (e, t, n) {\n      for (var r = 0, i = n.length; r < i; r++) {\n        var o = n[r];\n        R(e, o, t[o]);\n      }\n    }(e, ge, _e), this.observeArray(e)) : this.walk(e);\n  };\n\n  function Ce(e, t) {\n    var n;\n    if (o(e) && !(e instanceof pe)) return y(e, \"__ob__\") && e.__ob__ instanceof we ? n = e.__ob__ : be && !te() && (Array.isArray(e) || s(e)) && Object.isExtensible(e) && !e._isVue && (n = new we(e)), t && n && n.vmCount++, n;\n  }\n\n  function xe(e, t, n, r, i) {\n    var o = new ce(),\n        a = Object.getOwnPropertyDescriptor(e, t);\n\n    if (!a || !1 !== a.configurable) {\n      var s = a && a.get,\n          c = a && a.set;\n      s && !c || 2 !== arguments.length || (n = e[t]);\n      var u = !i && Ce(n);\n      Object.defineProperty(e, t, {\n        enumerable: !0,\n        configurable: !0,\n        get: function get() {\n          var t = s ? s.call(e) : n;\n          return ce.target && (o.depend(), u && (u.dep.depend(), Array.isArray(t) && function e(t) {\n            for (var n = void 0, r = 0, i = t.length; r < i; r++) {\n              (n = t[r]) && n.__ob__ && n.__ob__.dep.depend(), Array.isArray(n) && e(n);\n            }\n          }(t))), t;\n        },\n        set: function set(t) {\n          var r = s ? s.call(e) : n;\n          t === r || t != t && r != r || s && !c || (c ? c.call(e, t) : n = t, u = !i && Ce(t), o.notify());\n        }\n      });\n    }\n  }\n\n  function ke(e, t, n) {\n    if (Array.isArray(e) && c(t)) return e.length = Math.max(e.length, t), e.splice(t, 1, n), n;\n    if (t in e && !(t in Object.prototype)) return e[t] = n, n;\n    var r = e.__ob__;\n    return e._isVue || r && r.vmCount ? n : r ? (xe(r.value, t, n), r.dep.notify(), n) : (e[t] = n, n);\n  }\n\n  function Ae(e, t) {\n    if (Array.isArray(e) && c(t)) e.splice(t, 1);else {\n      var n = e.__ob__;\n      e._isVue || n && n.vmCount || y(e, t) && (delete e[t], n && n.dep.notify());\n    }\n  }\n\n  we.prototype.walk = function (e) {\n    for (var t = Object.keys(e), n = 0; n < t.length; n++) {\n      xe(e, t[n]);\n    }\n  }, we.prototype.observeArray = function (e) {\n    for (var t = 0, n = e.length; t < n; t++) {\n      Ce(e[t]);\n    }\n  };\n  var Oe = F.optionMergeStrategies;\n\n  function Se(e, t) {\n    if (!t) return e;\n\n    for (var n, r, i, o = oe ? Reflect.ownKeys(t) : Object.keys(t), a = 0; a < o.length; a++) {\n      \"__ob__\" !== (n = o[a]) && (r = e[n], i = t[n], y(e, n) ? r !== i && s(r) && s(i) && Se(r, i) : ke(e, n, i));\n    }\n\n    return e;\n  }\n\n  function Te(e, t, n) {\n    return n ? function () {\n      var r = \"function\" == typeof t ? t.call(n, n) : t,\n          i = \"function\" == typeof e ? e.call(n, n) : e;\n      return r ? Se(r, i) : i;\n    } : t ? e ? function () {\n      return Se(\"function\" == typeof t ? t.call(this, this) : t, \"function\" == typeof e ? e.call(this, this) : e);\n    } : t : e;\n  }\n\n  function Ee(e, t) {\n    var n = t ? e ? e.concat(t) : Array.isArray(t) ? t : [t] : e;\n    return n ? function (e) {\n      for (var t = [], n = 0; n < e.length; n++) {\n        -1 === t.indexOf(e[n]) && t.push(e[n]);\n      }\n\n      return t;\n    }(n) : n;\n  }\n\n  function Ne(e, t, n, r) {\n    var i = Object.create(e || null);\n    return t ? A(i, t) : i;\n  }\n\n  Oe.data = function (e, t, n) {\n    return n ? Te(e, t, n) : t && \"function\" != typeof t ? e : Te(e, t);\n  }, I.forEach(function (e) {\n    Oe[e] = Ee;\n  }), M.forEach(function (e) {\n    Oe[e + \"s\"] = Ne;\n  }), Oe.watch = function (e, t, n, r) {\n    if (e === Y && (e = void 0), t === Y && (t = void 0), !t) return Object.create(e || null);\n    if (!e) return t;\n    var i = {};\n\n    for (var o in A(i, e), t) {\n      var a = i[o],\n          s = t[o];\n      a && !Array.isArray(a) && (a = [a]), i[o] = a ? a.concat(s) : Array.isArray(s) ? s : [s];\n    }\n\n    return i;\n  }, Oe.props = Oe.methods = Oe.inject = Oe.computed = function (e, t, n, r) {\n    if (!e) return t;\n    var i = Object.create(null);\n    return A(i, e), t && A(i, t), i;\n  }, Oe.provide = Te;\n\n  var je = function je(e, t) {\n    return void 0 === t ? e : t;\n  };\n\n  function De(e, t, n) {\n    if (\"function\" == typeof t && (t = t.options), function (e, t) {\n      var n = e.props;\n\n      if (n) {\n        var r,\n            i,\n            o = {};\n        if (Array.isArray(n)) for (r = n.length; r--;) {\n          \"string\" == typeof (i = n[r]) && (o[b(i)] = {\n            type: null\n          });\n        } else if (s(n)) for (var a in n) {\n          i = n[a], o[b(a)] = s(i) ? i : {\n            type: i\n          };\n        }\n        e.props = o;\n      }\n    }(t), function (e, t) {\n      var n = e.inject;\n\n      if (n) {\n        var r = e.inject = {};\n        if (Array.isArray(n)) for (var i = 0; i < n.length; i++) {\n          r[n[i]] = {\n            from: n[i]\n          };\n        } else if (s(n)) for (var o in n) {\n          var a = n[o];\n          r[o] = s(a) ? A({\n            from: o\n          }, a) : {\n            from: a\n          };\n        }\n      }\n    }(t), function (e) {\n      var t = e.directives;\n      if (t) for (var n in t) {\n        var r = t[n];\n        \"function\" == typeof r && (t[n] = {\n          bind: r,\n          update: r\n        });\n      }\n    }(t), !t._base && (t.extends && (e = De(e, t.extends, n)), t.mixins)) for (var r = 0, i = t.mixins.length; r < i; r++) {\n      e = De(e, t.mixins[r], n);\n    }\n    var o,\n        a = {};\n\n    for (o in e) {\n      c(o);\n    }\n\n    for (o in t) {\n      y(e, o) || c(o);\n    }\n\n    function c(r) {\n      var i = Oe[r] || je;\n      a[r] = i(e[r], t[r], n, r);\n    }\n\n    return a;\n  }\n\n  function Le(e, t, n, r) {\n    if (\"string\" == typeof n) {\n      var i = e[t];\n      if (y(i, n)) return i[n];\n      var o = b(n);\n      if (y(i, o)) return i[o];\n      var a = $(o);\n      return y(i, a) ? i[a] : i[n] || i[o] || i[a];\n    }\n  }\n\n  function Me(e, t, n, r) {\n    var i = t[e],\n        o = !y(n, e),\n        a = n[e],\n        s = Pe(Boolean, i.type);\n    if (s > -1) if (o && !y(i, \"default\")) a = !1;else if (\"\" === a || a === C(e)) {\n      var c = Pe(String, i.type);\n      (c < 0 || s < c) && (a = !0);\n    }\n\n    if (void 0 === a) {\n      a = function (e, t, n) {\n        if (!y(t, \"default\")) return;\n        var r = t.default;\n        if (e && e.$options.propsData && void 0 === e.$options.propsData[n] && void 0 !== e._props[n]) return e._props[n];\n        return \"function\" == typeof r && \"Function\" !== Ie(t.type) ? r.call(e) : r;\n      }(r, i, e);\n\n      var u = be;\n      $e(!0), Ce(a), $e(u);\n    }\n\n    return a;\n  }\n\n  function Ie(e) {\n    var t = e && e.toString().match(/^\\s*function (\\w+)/);\n    return t ? t[1] : \"\";\n  }\n\n  function Fe(e, t) {\n    return Ie(e) === Ie(t);\n  }\n\n  function Pe(e, t) {\n    if (!Array.isArray(t)) return Fe(t, e) ? 0 : -1;\n\n    for (var n = 0, r = t.length; n < r; n++) {\n      if (Fe(t[n], e)) return n;\n    }\n\n    return -1;\n  }\n\n  function Re(e, t, n) {\n    le();\n\n    try {\n      if (t) for (var r = t; r = r.$parent;) {\n        var i = r.$options.errorCaptured;\n        if (i) for (var o = 0; o < i.length; o++) {\n          try {\n            if (!1 === i[o].call(r, e, t, n)) return;\n          } catch (e) {\n            Be(e, r, \"errorCaptured hook\");\n          }\n        }\n      }\n      Be(e, t, n);\n    } finally {\n      fe();\n    }\n  }\n\n  function He(e, t, n, r, i) {\n    var o;\n\n    try {\n      (o = n ? e.apply(t, n) : e.call(t)) && !o._isVue && u(o) && !o._handled && (o.catch(function (e) {\n        return Re(e, r, i + \" (Promise/async)\");\n      }), o._handled = !0);\n    } catch (e) {\n      Re(e, r, i);\n    }\n\n    return o;\n  }\n\n  function Be(e, t, n) {\n    if (F.errorHandler) try {\n      return F.errorHandler.call(null, e, t, n);\n    } catch (t) {\n      t !== e && Ue(t, null, \"config.errorHandler\");\n    }\n    Ue(e, t, n);\n  }\n\n  function Ue(e, t, n) {\n    if (!z && !V || \"undefined\" == typeof console) throw e;\n    console.error(e);\n  }\n\n  var ze,\n      Ve = !1,\n      Ke = [],\n      Je = !1;\n\n  function qe() {\n    Je = !1;\n    var e = Ke.slice(0);\n    Ke.length = 0;\n\n    for (var t = 0; t < e.length; t++) {\n      e[t]();\n    }\n  }\n\n  if (\"undefined\" != typeof Promise && re(Promise)) {\n    var We = Promise.resolve();\n    ze = function ze() {\n      We.then(qe), G && setTimeout(S);\n    }, Ve = !0;\n  } else if (q || \"undefined\" == typeof MutationObserver || !re(MutationObserver) && \"[object MutationObserverConstructor]\" !== MutationObserver.toString()) ze = \"undefined\" != typeof setImmediate && re(setImmediate) ? function () {\n    setImmediate(qe);\n  } : function () {\n    setTimeout(qe, 0);\n  };else {\n    var Ze = 1,\n        Ge = new MutationObserver(qe),\n        Xe = document.createTextNode(String(Ze));\n    Ge.observe(Xe, {\n      characterData: !0\n    }), ze = function ze() {\n      Ze = (Ze + 1) % 2, Xe.data = String(Ze);\n    }, Ve = !0;\n  }\n\n  function Ye(e, t) {\n    var n;\n    if (Ke.push(function () {\n      if (e) try {\n        e.call(t);\n      } catch (e) {\n        Re(e, t, \"nextTick\");\n      } else n && n(t);\n    }), Je || (Je = !0, ze()), !e && \"undefined\" != typeof Promise) return new Promise(function (e) {\n      n = e;\n    });\n  }\n\n  var Qe = new ie();\n\n  function et(e) {\n    !function e(t, n) {\n      var r, i;\n      var a = Array.isArray(t);\n      if (!a && !o(t) || Object.isFrozen(t) || t instanceof pe) return;\n\n      if (t.__ob__) {\n        var s = t.__ob__.dep.id;\n        if (n.has(s)) return;\n        n.add(s);\n      }\n\n      if (a) for (r = t.length; r--;) {\n        e(t[r], n);\n      } else for (i = Object.keys(t), r = i.length; r--;) {\n        e(t[i[r]], n);\n      }\n    }(e, Qe), Qe.clear();\n  }\n\n  var tt = g(function (e) {\n    var t = \"&\" === e.charAt(0),\n        n = \"~\" === (e = t ? e.slice(1) : e).charAt(0),\n        r = \"!\" === (e = n ? e.slice(1) : e).charAt(0);\n    return {\n      name: e = r ? e.slice(1) : e,\n      once: n,\n      capture: r,\n      passive: t\n    };\n  });\n\n  function nt(e, t) {\n    function n() {\n      var e = arguments,\n          r = n.fns;\n      if (!Array.isArray(r)) return He(r, null, arguments, t, \"v-on handler\");\n\n      for (var i = r.slice(), o = 0; o < i.length; o++) {\n        He(i[o], null, e, t, \"v-on handler\");\n      }\n    }\n\n    return n.fns = e, n;\n  }\n\n  function rt(e, n, i, o, a, s) {\n    var c, u, l, f;\n\n    for (c in e) {\n      u = e[c], l = n[c], f = tt(c), t(u) || (t(l) ? (t(u.fns) && (u = e[c] = nt(u, s)), r(f.once) && (u = e[c] = a(f.name, u, f.capture)), i(f.name, u, f.capture, f.passive, f.params)) : u !== l && (l.fns = u, e[c] = l));\n    }\n\n    for (c in n) {\n      t(e[c]) && o((f = tt(c)).name, n[c], f.capture);\n    }\n  }\n\n  function it(e, i, o) {\n    var a;\n    e instanceof pe && (e = e.data.hook || (e.data.hook = {}));\n    var s = e[i];\n\n    function c() {\n      o.apply(this, arguments), h(a.fns, c);\n    }\n\n    t(s) ? a = nt([c]) : n(s.fns) && r(s.merged) ? (a = s).fns.push(c) : a = nt([s, c]), a.merged = !0, e[i] = a;\n  }\n\n  function ot(e, t, r, i, o) {\n    if (n(t)) {\n      if (y(t, r)) return e[r] = t[r], o || delete t[r], !0;\n      if (y(t, i)) return e[r] = t[i], o || delete t[i], !0;\n    }\n\n    return !1;\n  }\n\n  function at(e) {\n    return i(e) ? [he(e)] : Array.isArray(e) ? function e(o, a) {\n      var s = [];\n      var c, u, l, f;\n\n      for (c = 0; c < o.length; c++) {\n        t(u = o[c]) || \"boolean\" == typeof u || (l = s.length - 1, f = s[l], Array.isArray(u) ? u.length > 0 && (st((u = e(u, (a || \"\") + \"_\" + c))[0]) && st(f) && (s[l] = he(f.text + u[0].text), u.shift()), s.push.apply(s, u)) : i(u) ? st(f) ? s[l] = he(f.text + u) : \"\" !== u && s.push(he(u)) : st(u) && st(f) ? s[l] = he(f.text + u.text) : (r(o._isVList) && n(u.tag) && t(u.key) && n(a) && (u.key = \"__vlist\" + a + \"_\" + c + \"__\"), s.push(u)));\n      }\n\n      return s;\n    }(e) : void 0;\n  }\n\n  function st(e) {\n    return n(e) && n(e.text) && !1 === e.isComment;\n  }\n\n  function ct(e, t) {\n    if (e) {\n      for (var n = Object.create(null), r = oe ? Reflect.ownKeys(e) : Object.keys(e), i = 0; i < r.length; i++) {\n        var o = r[i];\n\n        if (\"__ob__\" !== o) {\n          for (var a = e[o].from, s = t; s;) {\n            if (s._provided && y(s._provided, a)) {\n              n[o] = s._provided[a];\n              break;\n            }\n\n            s = s.$parent;\n          }\n\n          if (!s && \"default\" in e[o]) {\n            var c = e[o].default;\n            n[o] = \"function\" == typeof c ? c.call(t) : c;\n          }\n        }\n      }\n\n      return n;\n    }\n  }\n\n  function ut(e, t) {\n    if (!e || !e.length) return {};\n\n    for (var n = {}, r = 0, i = e.length; r < i; r++) {\n      var o = e[r],\n          a = o.data;\n      if (a && a.attrs && a.attrs.slot && delete a.attrs.slot, o.context !== t && o.fnContext !== t || !a || null == a.slot) (n.default || (n.default = [])).push(o);else {\n        var s = a.slot,\n            c = n[s] || (n[s] = []);\n        \"template\" === o.tag ? c.push.apply(c, o.children || []) : c.push(o);\n      }\n    }\n\n    for (var u in n) {\n      n[u].every(lt) && delete n[u];\n    }\n\n    return n;\n  }\n\n  function lt(e) {\n    return e.isComment && !e.asyncFactory || \" \" === e.text;\n  }\n\n  function ft(t, n, r) {\n    var i,\n        o = Object.keys(n).length > 0,\n        a = t ? !!t.$stable : !o,\n        s = t && t.$key;\n\n    if (t) {\n      if (t._normalized) return t._normalized;\n      if (a && r && r !== e && s === r.$key && !o && !r.$hasNormal) return r;\n\n      for (var c in i = {}, t) {\n        t[c] && \"$\" !== c[0] && (i[c] = pt(n, c, t[c]));\n      }\n    } else i = {};\n\n    for (var u in n) {\n      u in i || (i[u] = dt(n, u));\n    }\n\n    return t && Object.isExtensible(t) && (t._normalized = i), R(i, \"$stable\", a), R(i, \"$key\", s), R(i, \"$hasNormal\", o), i;\n  }\n\n  function pt(e, t, n) {\n    var r = function r() {\n      var e = arguments.length ? n.apply(null, arguments) : n({});\n      return (e = e && \"object\" == _typeof(e) && !Array.isArray(e) ? [e] : at(e)) && (0 === e.length || 1 === e.length && e[0].isComment) ? void 0 : e;\n    };\n\n    return n.proxy && Object.defineProperty(e, t, {\n      get: r,\n      enumerable: !0,\n      configurable: !0\n    }), r;\n  }\n\n  function dt(e, t) {\n    return function () {\n      return e[t];\n    };\n  }\n\n  function vt(e, t) {\n    var r, i, a, s, c;\n    if (Array.isArray(e) || \"string\" == typeof e) for (r = new Array(e.length), i = 0, a = e.length; i < a; i++) {\n      r[i] = t(e[i], i);\n    } else if (\"number\" == typeof e) for (r = new Array(e), i = 0; i < e; i++) {\n      r[i] = t(i + 1, i);\n    } else if (o(e)) if (oe && e[Symbol.iterator]) {\n      r = [];\n\n      for (var u = e[Symbol.iterator](), l = u.next(); !l.done;) {\n        r.push(t(l.value, r.length)), l = u.next();\n      }\n    } else for (s = Object.keys(e), r = new Array(s.length), i = 0, a = s.length; i < a; i++) {\n      c = s[i], r[i] = t(e[c], c, i);\n    }\n    return n(r) || (r = []), r._isVList = !0, r;\n  }\n\n  function ht(e, t, n, r) {\n    var i,\n        o = this.$scopedSlots[e];\n    o ? (n = n || {}, r && (n = A(A({}, r), n)), i = o(n) || t) : i = this.$slots[e] || t;\n    var a = n && n.slot;\n    return a ? this.$createElement(\"template\", {\n      slot: a\n    }, i) : i;\n  }\n\n  function mt(e) {\n    return Le(this.$options, \"filters\", e) || E;\n  }\n\n  function yt(e, t) {\n    return Array.isArray(e) ? -1 === e.indexOf(t) : e !== t;\n  }\n\n  function gt(e, t, n, r, i) {\n    var o = F.keyCodes[t] || n;\n    return i && r && !F.keyCodes[t] ? yt(i, r) : o ? yt(o, e) : r ? C(r) !== t : void 0;\n  }\n\n  function _t(e, t, n, r, i) {\n    if (n) if (o(n)) {\n      var a;\n      Array.isArray(n) && (n = O(n));\n\n      var s = function s(o) {\n        if (\"class\" === o || \"style\" === o || v(o)) a = e;else {\n          var s = e.attrs && e.attrs.type;\n          a = r || F.mustUseProp(t, s, o) ? e.domProps || (e.domProps = {}) : e.attrs || (e.attrs = {});\n        }\n        var c = b(o),\n            u = C(o);\n        c in a || u in a || (a[o] = n[o], i && ((e.on || (e.on = {}))[\"update:\" + o] = function (e) {\n          n[o] = e;\n        }));\n      };\n\n      for (var c in n) {\n        s(c);\n      }\n    } else ;\n    return e;\n  }\n\n  function bt(e, t) {\n    var n = this._staticTrees || (this._staticTrees = []),\n        r = n[e];\n    return r && !t ? r : (wt(r = n[e] = this.$options.staticRenderFns[e].call(this._renderProxy, null, this), \"__static__\" + e, !1), r);\n  }\n\n  function $t(e, t, n) {\n    return wt(e, \"__once__\" + t + (n ? \"_\" + n : \"\"), !0), e;\n  }\n\n  function wt(e, t, n) {\n    if (Array.isArray(e)) for (var r = 0; r < e.length; r++) {\n      e[r] && \"string\" != typeof e[r] && Ct(e[r], t + \"_\" + r, n);\n    } else Ct(e, t, n);\n  }\n\n  function Ct(e, t, n) {\n    e.isStatic = !0, e.key = t, e.isOnce = n;\n  }\n\n  function xt(e, t) {\n    if (t) if (s(t)) {\n      var n = e.on = e.on ? A({}, e.on) : {};\n\n      for (var r in t) {\n        var i = n[r],\n            o = t[r];\n        n[r] = i ? [].concat(i, o) : o;\n      }\n    } else ;\n    return e;\n  }\n\n  function kt(e, t, n, r) {\n    t = t || {\n      $stable: !n\n    };\n\n    for (var i = 0; i < e.length; i++) {\n      var o = e[i];\n      Array.isArray(o) ? kt(o, t, n) : o && (o.proxy && (o.fn.proxy = !0), t[o.key] = o.fn);\n    }\n\n    return r && (t.$key = r), t;\n  }\n\n  function At(e, t) {\n    for (var n = 0; n < t.length; n += 2) {\n      var r = t[n];\n      \"string\" == typeof r && r && (e[t[n]] = t[n + 1]);\n    }\n\n    return e;\n  }\n\n  function Ot(e, t) {\n    return \"string\" == typeof e ? t + e : e;\n  }\n\n  function St(e) {\n    e._o = $t, e._n = f, e._s = l, e._l = vt, e._t = ht, e._q = N, e._i = j, e._m = bt, e._f = mt, e._k = gt, e._b = _t, e._v = he, e._e = ve, e._u = kt, e._g = xt, e._d = At, e._p = Ot;\n  }\n\n  function Tt(t, n, i, o, a) {\n    var s,\n        c = this,\n        u = a.options;\n    y(o, \"_uid\") ? (s = Object.create(o))._original = o : (s = o, o = o._original);\n    var l = r(u._compiled),\n        f = !l;\n    this.data = t, this.props = n, this.children = i, this.parent = o, this.listeners = t.on || e, this.injections = ct(u.inject, o), this.slots = function () {\n      return c.$slots || ft(t.scopedSlots, c.$slots = ut(i, o)), c.$slots;\n    }, Object.defineProperty(this, \"scopedSlots\", {\n      enumerable: !0,\n      get: function get() {\n        return ft(t.scopedSlots, this.slots());\n      }\n    }), l && (this.$options = u, this.$slots = this.slots(), this.$scopedSlots = ft(t.scopedSlots, this.$slots)), u._scopeId ? this._c = function (e, t, n, r) {\n      var i = Pt(s, e, t, n, r, f);\n      return i && !Array.isArray(i) && (i.fnScopeId = u._scopeId, i.fnContext = o), i;\n    } : this._c = function (e, t, n, r) {\n      return Pt(s, e, t, n, r, f);\n    };\n  }\n\n  function Et(e, t, n, r, i) {\n    var o = me(e);\n    return o.fnContext = n, o.fnOptions = r, t.slot && ((o.data || (o.data = {})).slot = t.slot), o;\n  }\n\n  function Nt(e, t) {\n    for (var n in t) {\n      e[b(n)] = t[n];\n    }\n  }\n\n  St(Tt.prototype);\n  var jt = {\n    init: function init(e, t) {\n      if (e.componentInstance && !e.componentInstance._isDestroyed && e.data.keepAlive) {\n        var r = e;\n        jt.prepatch(r, r);\n      } else {\n        (e.componentInstance = function (e, t) {\n          var r = {\n            _isComponent: !0,\n            _parentVnode: e,\n            parent: t\n          },\n              i = e.data.inlineTemplate;\n          n(i) && (r.render = i.render, r.staticRenderFns = i.staticRenderFns);\n          return new e.componentOptions.Ctor(r);\n        }(e, Wt)).$mount(t ? e.elm : void 0, t);\n      }\n    },\n    prepatch: function prepatch(t, n) {\n      var r = n.componentOptions;\n      !function (t, n, r, i, o) {\n        var a = i.data.scopedSlots,\n            s = t.$scopedSlots,\n            c = !!(a && !a.$stable || s !== e && !s.$stable || a && t.$scopedSlots.$key !== a.$key),\n            u = !!(o || t.$options._renderChildren || c);\n        t.$options._parentVnode = i, t.$vnode = i, t._vnode && (t._vnode.parent = i);\n\n        if (t.$options._renderChildren = o, t.$attrs = i.data.attrs || e, t.$listeners = r || e, n && t.$options.props) {\n          $e(!1);\n\n          for (var l = t._props, f = t.$options._propKeys || [], p = 0; p < f.length; p++) {\n            var d = f[p],\n                v = t.$options.props;\n            l[d] = Me(d, v, n, t);\n          }\n\n          $e(!0), t.$options.propsData = n;\n        }\n\n        r = r || e;\n        var h = t.$options._parentListeners;\n        t.$options._parentListeners = r, qt(t, r, h), u && (t.$slots = ut(o, i.context), t.$forceUpdate());\n      }(n.componentInstance = t.componentInstance, r.propsData, r.listeners, n, r.children);\n    },\n    insert: function insert(e) {\n      var t,\n          n = e.context,\n          r = e.componentInstance;\n      r._isMounted || (r._isMounted = !0, Yt(r, \"mounted\")), e.data.keepAlive && (n._isMounted ? ((t = r)._inactive = !1, en.push(t)) : Xt(r, !0));\n    },\n    destroy: function destroy(e) {\n      var t = e.componentInstance;\n      t._isDestroyed || (e.data.keepAlive ? function e(t, n) {\n        if (n && (t._directInactive = !0, Gt(t))) return;\n\n        if (!t._inactive) {\n          t._inactive = !0;\n\n          for (var r = 0; r < t.$children.length; r++) {\n            e(t.$children[r]);\n          }\n\n          Yt(t, \"deactivated\");\n        }\n      }(t, !0) : t.$destroy());\n    }\n  },\n      Dt = Object.keys(jt);\n\n  function Lt(i, a, s, c, l) {\n    if (!t(i)) {\n      var f = s.$options._base;\n\n      if (o(i) && (i = f.extend(i)), \"function\" == typeof i) {\n        var p;\n        if (t(i.cid) && void 0 === (i = function (e, i) {\n          if (r(e.error) && n(e.errorComp)) return e.errorComp;\n          if (n(e.resolved)) return e.resolved;\n          var a = Ht;\n          a && n(e.owners) && -1 === e.owners.indexOf(a) && e.owners.push(a);\n          if (r(e.loading) && n(e.loadingComp)) return e.loadingComp;\n\n          if (a && !n(e.owners)) {\n            var s = e.owners = [a],\n                c = !0,\n                l = null,\n                f = null;\n            a.$on(\"hook:destroyed\", function () {\n              return h(s, a);\n            });\n\n            var p = function p(e) {\n              for (var t = 0, n = s.length; t < n; t++) {\n                s[t].$forceUpdate();\n              }\n\n              e && (s.length = 0, null !== l && (clearTimeout(l), l = null), null !== f && (clearTimeout(f), f = null));\n            },\n                d = D(function (t) {\n              e.resolved = Bt(t, i), c ? s.length = 0 : p(!0);\n            }),\n                v = D(function (t) {\n              n(e.errorComp) && (e.error = !0, p(!0));\n            }),\n                m = e(d, v);\n\n            return o(m) && (u(m) ? t(e.resolved) && m.then(d, v) : u(m.component) && (m.component.then(d, v), n(m.error) && (e.errorComp = Bt(m.error, i)), n(m.loading) && (e.loadingComp = Bt(m.loading, i), 0 === m.delay ? e.loading = !0 : l = setTimeout(function () {\n              l = null, t(e.resolved) && t(e.error) && (e.loading = !0, p(!1));\n            }, m.delay || 200)), n(m.timeout) && (f = setTimeout(function () {\n              f = null, t(e.resolved) && v(null);\n            }, m.timeout)))), c = !1, e.loading ? e.loadingComp : e.resolved;\n          }\n        }(p = i, f))) return function (e, t, n, r, i) {\n          var o = ve();\n          return o.asyncFactory = e, o.asyncMeta = {\n            data: t,\n            context: n,\n            children: r,\n            tag: i\n          }, o;\n        }(p, a, s, c, l);\n        a = a || {}, $n(i), n(a.model) && function (e, t) {\n          var r = e.model && e.model.prop || \"value\",\n              i = e.model && e.model.event || \"input\";\n          (t.attrs || (t.attrs = {}))[r] = t.model.value;\n          var o = t.on || (t.on = {}),\n              a = o[i],\n              s = t.model.callback;\n          n(a) ? (Array.isArray(a) ? -1 === a.indexOf(s) : a !== s) && (o[i] = [s].concat(a)) : o[i] = s;\n        }(i.options, a);\n\n        var d = function (e, r, i) {\n          var o = r.options.props;\n\n          if (!t(o)) {\n            var a = {},\n                s = e.attrs,\n                c = e.props;\n            if (n(s) || n(c)) for (var u in o) {\n              var l = C(u);\n              ot(a, c, u, l, !0) || ot(a, s, u, l, !1);\n            }\n            return a;\n          }\n        }(a, i);\n\n        if (r(i.options.functional)) return function (t, r, i, o, a) {\n          var s = t.options,\n              c = {},\n              u = s.props;\n          if (n(u)) for (var l in u) {\n            c[l] = Me(l, u, r || e);\n          } else n(i.attrs) && Nt(c, i.attrs), n(i.props) && Nt(c, i.props);\n          var f = new Tt(i, c, a, o, t),\n              p = s.render.call(null, f._c, f);\n          if (p instanceof pe) return Et(p, i, f.parent, s);\n\n          if (Array.isArray(p)) {\n            for (var d = at(p) || [], v = new Array(d.length), h = 0; h < d.length; h++) {\n              v[h] = Et(d[h], i, f.parent, s);\n            }\n\n            return v;\n          }\n        }(i, d, a, s, c);\n        var v = a.on;\n\n        if (a.on = a.nativeOn, r(i.options.abstract)) {\n          var m = a.slot;\n          a = {}, m && (a.slot = m);\n        }\n\n        !function (e) {\n          for (var t = e.hook || (e.hook = {}), n = 0; n < Dt.length; n++) {\n            var r = Dt[n],\n                i = t[r],\n                o = jt[r];\n            i === o || i && i._merged || (t[r] = i ? Mt(o, i) : o);\n          }\n        }(a);\n        var y = i.options.name || l;\n        return new pe(\"vue-component-\" + i.cid + (y ? \"-\" + y : \"\"), a, void 0, void 0, void 0, s, {\n          Ctor: i,\n          propsData: d,\n          listeners: v,\n          tag: l,\n          children: c\n        }, p);\n      }\n    }\n  }\n\n  function Mt(e, t) {\n    var n = function n(_n2, r) {\n      e(_n2, r), t(_n2, r);\n    };\n\n    return n._merged = !0, n;\n  }\n\n  var It = 1,\n      Ft = 2;\n\n  function Pt(e, a, s, c, u, l) {\n    return (Array.isArray(s) || i(s)) && (u = c, c = s, s = void 0), r(l) && (u = Ft), function (e, i, a, s, c) {\n      if (n(a) && n(a.__ob__)) return ve();\n      n(a) && n(a.is) && (i = a.is);\n      if (!i) return ve();\n      Array.isArray(s) && \"function\" == typeof s[0] && ((a = a || {}).scopedSlots = {\n        default: s[0]\n      }, s.length = 0);\n      c === Ft ? s = at(s) : c === It && (s = function (e) {\n        for (var t = 0; t < e.length; t++) {\n          if (Array.isArray(e[t])) return Array.prototype.concat.apply([], e);\n        }\n\n        return e;\n      }(s));\n      var u, l;\n\n      if (\"string\" == typeof i) {\n        var f;\n        l = e.$vnode && e.$vnode.ns || F.getTagNamespace(i), u = F.isReservedTag(i) ? new pe(F.parsePlatformTagName(i), a, s, void 0, void 0, e) : a && a.pre || !n(f = Le(e.$options, \"components\", i)) ? new pe(i, a, s, void 0, void 0, e) : Lt(f, a, e, s, i);\n      } else u = Lt(i, a, e, s);\n\n      return Array.isArray(u) ? u : n(u) ? (n(l) && function e(i, o, a) {\n        i.ns = o;\n        \"foreignObject\" === i.tag && (o = void 0, a = !0);\n        if (n(i.children)) for (var s = 0, c = i.children.length; s < c; s++) {\n          var u = i.children[s];\n          n(u.tag) && (t(u.ns) || r(a) && \"svg\" !== u.tag) && e(u, o, a);\n        }\n      }(u, l), n(a) && function (e) {\n        o(e.style) && et(e.style);\n        o(e.class) && et(e.class);\n      }(a), u) : ve();\n    }(e, a, s, c, u);\n  }\n\n  var Rt,\n      Ht = null;\n\n  function Bt(e, t) {\n    return (e.__esModule || oe && \"Module\" === e[Symbol.toStringTag]) && (e = e.default), o(e) ? t.extend(e) : e;\n  }\n\n  function Ut(e) {\n    return e.isComment && e.asyncFactory;\n  }\n\n  function zt(e) {\n    if (Array.isArray(e)) for (var t = 0; t < e.length; t++) {\n      var r = e[t];\n      if (n(r) && (n(r.componentOptions) || Ut(r))) return r;\n    }\n  }\n\n  function Vt(e, t) {\n    Rt.$on(e, t);\n  }\n\n  function Kt(e, t) {\n    Rt.$off(e, t);\n  }\n\n  function Jt(e, t) {\n    var n = Rt;\n    return function r() {\n      null !== t.apply(null, arguments) && n.$off(e, r);\n    };\n  }\n\n  function qt(e, t, n) {\n    Rt = e, rt(t, n || {}, Vt, Kt, Jt, e), Rt = void 0;\n  }\n\n  var Wt = null;\n\n  function Zt(e) {\n    var t = Wt;\n    return Wt = e, function () {\n      Wt = t;\n    };\n  }\n\n  function Gt(e) {\n    for (; e && (e = e.$parent);) {\n      if (e._inactive) return !0;\n    }\n\n    return !1;\n  }\n\n  function Xt(e, t) {\n    if (t) {\n      if (e._directInactive = !1, Gt(e)) return;\n    } else if (e._directInactive) return;\n\n    if (e._inactive || null === e._inactive) {\n      e._inactive = !1;\n\n      for (var n = 0; n < e.$children.length; n++) {\n        Xt(e.$children[n]);\n      }\n\n      Yt(e, \"activated\");\n    }\n  }\n\n  function Yt(e, t) {\n    le();\n    var n = e.$options[t],\n        r = t + \" hook\";\n    if (n) for (var i = 0, o = n.length; i < o; i++) {\n      He(n[i], e, null, e, r);\n    }\n    e._hasHookEvent && e.$emit(\"hook:\" + t), fe();\n  }\n\n  var Qt = [],\n      en = [],\n      tn = {},\n      nn = !1,\n      rn = !1,\n      on = 0;\n  var an = 0,\n      sn = Date.now;\n\n  if (z && !q) {\n    var cn = window.performance;\n    cn && \"function\" == typeof cn.now && sn() > document.createEvent(\"Event\").timeStamp && (sn = function sn() {\n      return cn.now();\n    });\n  }\n\n  function un() {\n    var e, t;\n\n    for (an = sn(), rn = !0, Qt.sort(function (e, t) {\n      return e.id - t.id;\n    }), on = 0; on < Qt.length; on++) {\n      (e = Qt[on]).before && e.before(), t = e.id, tn[t] = null, e.run();\n    }\n\n    var n = en.slice(),\n        r = Qt.slice();\n    on = Qt.length = en.length = 0, tn = {}, nn = rn = !1, function (e) {\n      for (var t = 0; t < e.length; t++) {\n        e[t]._inactive = !0, Xt(e[t], !0);\n      }\n    }(n), function (e) {\n      var t = e.length;\n\n      for (; t--;) {\n        var n = e[t],\n            r = n.vm;\n        r._watcher === n && r._isMounted && !r._isDestroyed && Yt(r, \"updated\");\n      }\n    }(r), ne && F.devtools && ne.emit(\"flush\");\n  }\n\n  var ln = 0,\n      fn = function fn(e, t, n, r, i) {\n    this.vm = e, i && (e._watcher = this), e._watchers.push(this), r ? (this.deep = !!r.deep, this.user = !!r.user, this.lazy = !!r.lazy, this.sync = !!r.sync, this.before = r.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++ln, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new ie(), this.newDepIds = new ie(), this.expression = \"\", \"function\" == typeof t ? this.getter = t : (this.getter = function (e) {\n      if (!H.test(e)) {\n        var t = e.split(\".\");\n        return function (e) {\n          for (var n = 0; n < t.length; n++) {\n            if (!e) return;\n            e = e[t[n]];\n          }\n\n          return e;\n        };\n      }\n    }(t), this.getter || (this.getter = S)), this.value = this.lazy ? void 0 : this.get();\n  };\n\n  fn.prototype.get = function () {\n    var e;\n    le(this);\n    var t = this.vm;\n\n    try {\n      e = this.getter.call(t, t);\n    } catch (e) {\n      if (!this.user) throw e;\n      Re(e, t, 'getter for watcher \"' + this.expression + '\"');\n    } finally {\n      this.deep && et(e), fe(), this.cleanupDeps();\n    }\n\n    return e;\n  }, fn.prototype.addDep = function (e) {\n    var t = e.id;\n    this.newDepIds.has(t) || (this.newDepIds.add(t), this.newDeps.push(e), this.depIds.has(t) || e.addSub(this));\n  }, fn.prototype.cleanupDeps = function () {\n    for (var e = this.deps.length; e--;) {\n      var t = this.deps[e];\n      this.newDepIds.has(t.id) || t.removeSub(this);\n    }\n\n    var n = this.depIds;\n    this.depIds = this.newDepIds, this.newDepIds = n, this.newDepIds.clear(), n = this.deps, this.deps = this.newDeps, this.newDeps = n, this.newDeps.length = 0;\n  }, fn.prototype.update = function () {\n    this.lazy ? this.dirty = !0 : this.sync ? this.run() : function (e) {\n      var t = e.id;\n\n      if (null == tn[t]) {\n        if (tn[t] = !0, rn) {\n          for (var n = Qt.length - 1; n > on && Qt[n].id > e.id;) {\n            n--;\n          }\n\n          Qt.splice(n + 1, 0, e);\n        } else Qt.push(e);\n\n        nn || (nn = !0, Ye(un));\n      }\n    }(this);\n  }, fn.prototype.run = function () {\n    if (this.active) {\n      var e = this.get();\n\n      if (e !== this.value || o(e) || this.deep) {\n        var t = this.value;\n        if (this.value = e, this.user) try {\n          this.cb.call(this.vm, e, t);\n        } catch (e) {\n          Re(e, this.vm, 'callback for watcher \"' + this.expression + '\"');\n        } else this.cb.call(this.vm, e, t);\n      }\n    }\n  }, fn.prototype.evaluate = function () {\n    this.value = this.get(), this.dirty = !1;\n  }, fn.prototype.depend = function () {\n    for (var e = this.deps.length; e--;) {\n      this.deps[e].depend();\n    }\n  }, fn.prototype.teardown = function () {\n    if (this.active) {\n      this.vm._isBeingDestroyed || h(this.vm._watchers, this);\n\n      for (var e = this.deps.length; e--;) {\n        this.deps[e].removeSub(this);\n      }\n\n      this.active = !1;\n    }\n  };\n  var pn = {\n    enumerable: !0,\n    configurable: !0,\n    get: S,\n    set: S\n  };\n\n  function dn(e, t, n) {\n    pn.get = function () {\n      return this[t][n];\n    }, pn.set = function (e) {\n      this[t][n] = e;\n    }, Object.defineProperty(e, n, pn);\n  }\n\n  function vn(e) {\n    e._watchers = [];\n    var t = e.$options;\n    t.props && function (e, t) {\n      var n = e.$options.propsData || {},\n          r = e._props = {},\n          i = e.$options._propKeys = [];\n      e.$parent && $e(!1);\n\n      var o = function o(_o2) {\n        i.push(_o2);\n        var a = Me(_o2, t, n, e);\n        xe(r, _o2, a), _o2 in e || dn(e, \"_props\", _o2);\n      };\n\n      for (var a in t) {\n        o(a);\n      }\n\n      $e(!0);\n    }(e, t.props), t.methods && function (e, t) {\n      e.$options.props;\n\n      for (var n in t) {\n        e[n] = \"function\" != typeof t[n] ? S : x(t[n], e);\n      }\n    }(e, t.methods), t.data ? function (e) {\n      var t = e.$options.data;\n      s(t = e._data = \"function\" == typeof t ? function (e, t) {\n        le();\n\n        try {\n          return e.call(t, t);\n        } catch (e) {\n          return Re(e, t, \"data()\"), {};\n        } finally {\n          fe();\n        }\n      }(t, e) : t || {}) || (t = {});\n      var n = Object.keys(t),\n          r = e.$options.props,\n          i = (e.$options.methods, n.length);\n\n      for (; i--;) {\n        var o = n[i];\n        r && y(r, o) || (a = void 0, 36 !== (a = (o + \"\").charCodeAt(0)) && 95 !== a && dn(e, \"_data\", o));\n      }\n\n      var a;\n      Ce(t, !0);\n    }(e) : Ce(e._data = {}, !0), t.computed && function (e, t) {\n      var n = e._computedWatchers = Object.create(null),\n          r = te();\n\n      for (var i in t) {\n        var o = t[i],\n            a = \"function\" == typeof o ? o : o.get;\n        r || (n[i] = new fn(e, a || S, S, hn)), i in e || mn(e, i, o);\n      }\n    }(e, t.computed), t.watch && t.watch !== Y && function (e, t) {\n      for (var n in t) {\n        var r = t[n];\n        if (Array.isArray(r)) for (var i = 0; i < r.length; i++) {\n          _n(e, n, r[i]);\n        } else _n(e, n, r);\n      }\n    }(e, t.watch);\n  }\n\n  var hn = {\n    lazy: !0\n  };\n\n  function mn(e, t, n) {\n    var r = !te();\n    \"function\" == typeof n ? (pn.get = r ? yn(t) : gn(n), pn.set = S) : (pn.get = n.get ? r && !1 !== n.cache ? yn(t) : gn(n.get) : S, pn.set = n.set || S), Object.defineProperty(e, t, pn);\n  }\n\n  function yn(e) {\n    return function () {\n      var t = this._computedWatchers && this._computedWatchers[e];\n      if (t) return t.dirty && t.evaluate(), ce.target && t.depend(), t.value;\n    };\n  }\n\n  function gn(e) {\n    return function () {\n      return e.call(this, this);\n    };\n  }\n\n  function _n(e, t, n, r) {\n    return s(n) && (r = n, n = n.handler), \"string\" == typeof n && (n = e[n]), e.$watch(t, n, r);\n  }\n\n  var bn = 0;\n\n  function $n(e) {\n    var t = e.options;\n\n    if (e.super) {\n      var n = $n(e.super);\n\n      if (n !== e.superOptions) {\n        e.superOptions = n;\n\n        var r = function (e) {\n          var t,\n              n = e.options,\n              r = e.sealedOptions;\n\n          for (var i in n) {\n            n[i] !== r[i] && (t || (t = {}), t[i] = n[i]);\n          }\n\n          return t;\n        }(e);\n\n        r && A(e.extendOptions, r), (t = e.options = De(n, e.extendOptions)).name && (t.components[t.name] = e);\n      }\n    }\n\n    return t;\n  }\n\n  function wn(e) {\n    this._init(e);\n  }\n\n  function Cn(e) {\n    e.cid = 0;\n    var t = 1;\n\n    e.extend = function (e) {\n      e = e || {};\n      var n = this,\n          r = n.cid,\n          i = e._Ctor || (e._Ctor = {});\n      if (i[r]) return i[r];\n\n      var o = e.name || n.options.name,\n          a = function a(e) {\n        this._init(e);\n      };\n\n      return (a.prototype = Object.create(n.prototype)).constructor = a, a.cid = t++, a.options = De(n.options, e), a.super = n, a.options.props && function (e) {\n        var t = e.options.props;\n\n        for (var n in t) {\n          dn(e.prototype, \"_props\", n);\n        }\n      }(a), a.options.computed && function (e) {\n        var t = e.options.computed;\n\n        for (var n in t) {\n          mn(e.prototype, n, t[n]);\n        }\n      }(a), a.extend = n.extend, a.mixin = n.mixin, a.use = n.use, M.forEach(function (e) {\n        a[e] = n[e];\n      }), o && (a.options.components[o] = a), a.superOptions = n.options, a.extendOptions = e, a.sealedOptions = A({}, a.options), i[r] = a, a;\n    };\n  }\n\n  function xn(e) {\n    return e && (e.Ctor.options.name || e.tag);\n  }\n\n  function kn(e, t) {\n    return Array.isArray(e) ? e.indexOf(t) > -1 : \"string\" == typeof e ? e.split(\",\").indexOf(t) > -1 : (n = e, \"[object RegExp]\" === a.call(n) && e.test(t));\n    var n;\n  }\n\n  function An(e, t) {\n    var n = e.cache,\n        r = e.keys,\n        i = e._vnode;\n\n    for (var o in n) {\n      var a = n[o];\n\n      if (a) {\n        var s = xn(a.componentOptions);\n        s && !t(s) && On(n, o, r, i);\n      }\n    }\n  }\n\n  function On(e, t, n, r) {\n    var i = e[t];\n    !i || r && i.tag === r.tag || i.componentInstance.$destroy(), e[t] = null, h(n, t);\n  }\n\n  !function (t) {\n    t.prototype._init = function (t) {\n      var n = this;\n      n._uid = bn++, n._isVue = !0, t && t._isComponent ? function (e, t) {\n        var n = e.$options = Object.create(e.constructor.options),\n            r = t._parentVnode;\n        n.parent = t.parent, n._parentVnode = r;\n        var i = r.componentOptions;\n        n.propsData = i.propsData, n._parentListeners = i.listeners, n._renderChildren = i.children, n._componentTag = i.tag, t.render && (n.render = t.render, n.staticRenderFns = t.staticRenderFns);\n      }(n, t) : n.$options = De($n(n.constructor), t || {}, n), n._renderProxy = n, n._self = n, function (e) {\n        var t = e.$options,\n            n = t.parent;\n\n        if (n && !t.abstract) {\n          for (; n.$options.abstract && n.$parent;) {\n            n = n.$parent;\n          }\n\n          n.$children.push(e);\n        }\n\n        e.$parent = n, e.$root = n ? n.$root : e, e.$children = [], e.$refs = {}, e._watcher = null, e._inactive = null, e._directInactive = !1, e._isMounted = !1, e._isDestroyed = !1, e._isBeingDestroyed = !1;\n      }(n), function (e) {\n        e._events = Object.create(null), e._hasHookEvent = !1;\n        var t = e.$options._parentListeners;\n        t && qt(e, t);\n      }(n), function (t) {\n        t._vnode = null, t._staticTrees = null;\n        var n = t.$options,\n            r = t.$vnode = n._parentVnode,\n            i = r && r.context;\n        t.$slots = ut(n._renderChildren, i), t.$scopedSlots = e, t._c = function (e, n, r, i) {\n          return Pt(t, e, n, r, i, !1);\n        }, t.$createElement = function (e, n, r, i) {\n          return Pt(t, e, n, r, i, !0);\n        };\n        var o = r && r.data;\n        xe(t, \"$attrs\", o && o.attrs || e, null, !0), xe(t, \"$listeners\", n._parentListeners || e, null, !0);\n      }(n), Yt(n, \"beforeCreate\"), function (e) {\n        var t = ct(e.$options.inject, e);\n        t && ($e(!1), Object.keys(t).forEach(function (n) {\n          xe(e, n, t[n]);\n        }), $e(!0));\n      }(n), vn(n), function (e) {\n        var t = e.$options.provide;\n        t && (e._provided = \"function\" == typeof t ? t.call(e) : t);\n      }(n), Yt(n, \"created\"), n.$options.el && n.$mount(n.$options.el);\n    };\n  }(wn), function (e) {\n    var t = {\n      get: function get() {\n        return this._data;\n      }\n    },\n        n = {\n      get: function get() {\n        return this._props;\n      }\n    };\n    Object.defineProperty(e.prototype, \"$data\", t), Object.defineProperty(e.prototype, \"$props\", n), e.prototype.$set = ke, e.prototype.$delete = Ae, e.prototype.$watch = function (e, t, n) {\n      if (s(t)) return _n(this, e, t, n);\n      (n = n || {}).user = !0;\n      var r = new fn(this, e, t, n);\n      if (n.immediate) try {\n        t.call(this, r.value);\n      } catch (e) {\n        Re(e, this, 'callback for immediate watcher \"' + r.expression + '\"');\n      }\n      return function () {\n        r.teardown();\n      };\n    };\n  }(wn), function (e) {\n    var t = /^hook:/;\n    e.prototype.$on = function (e, n) {\n      var r = this;\n      if (Array.isArray(e)) for (var i = 0, o = e.length; i < o; i++) {\n        r.$on(e[i], n);\n      } else (r._events[e] || (r._events[e] = [])).push(n), t.test(e) && (r._hasHookEvent = !0);\n      return r;\n    }, e.prototype.$once = function (e, t) {\n      var n = this;\n\n      function r() {\n        n.$off(e, r), t.apply(n, arguments);\n      }\n\n      return r.fn = t, n.$on(e, r), n;\n    }, e.prototype.$off = function (e, t) {\n      var n = this;\n      if (!arguments.length) return n._events = Object.create(null), n;\n\n      if (Array.isArray(e)) {\n        for (var r = 0, i = e.length; r < i; r++) {\n          n.$off(e[r], t);\n        }\n\n        return n;\n      }\n\n      var o,\n          a = n._events[e];\n      if (!a) return n;\n      if (!t) return n._events[e] = null, n;\n\n      for (var s = a.length; s--;) {\n        if ((o = a[s]) === t || o.fn === t) {\n          a.splice(s, 1);\n          break;\n        }\n      }\n\n      return n;\n    }, e.prototype.$emit = function (e) {\n      var t = this._events[e];\n\n      if (t) {\n        t = t.length > 1 ? k(t) : t;\n\n        for (var n = k(arguments, 1), r = 'event handler for \"' + e + '\"', i = 0, o = t.length; i < o; i++) {\n          He(t[i], this, n, this, r);\n        }\n      }\n\n      return this;\n    };\n  }(wn), function (e) {\n    e.prototype._update = function (e, t) {\n      var n = this,\n          r = n.$el,\n          i = n._vnode,\n          o = Zt(n);\n      n._vnode = e, n.$el = i ? n.__patch__(i, e) : n.__patch__(n.$el, e, t, !1), o(), r && (r.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el);\n    }, e.prototype.$forceUpdate = function () {\n      this._watcher && this._watcher.update();\n    }, e.prototype.$destroy = function () {\n      var e = this;\n\n      if (!e._isBeingDestroyed) {\n        Yt(e, \"beforeDestroy\"), e._isBeingDestroyed = !0;\n        var t = e.$parent;\n        !t || t._isBeingDestroyed || e.$options.abstract || h(t.$children, e), e._watcher && e._watcher.teardown();\n\n        for (var n = e._watchers.length; n--;) {\n          e._watchers[n].teardown();\n        }\n\n        e._data.__ob__ && e._data.__ob__.vmCount--, e._isDestroyed = !0, e.__patch__(e._vnode, null), Yt(e, \"destroyed\"), e.$off(), e.$el && (e.$el.__vue__ = null), e.$vnode && (e.$vnode.parent = null);\n      }\n    };\n  }(wn), function (e) {\n    St(e.prototype), e.prototype.$nextTick = function (e) {\n      return Ye(e, this);\n    }, e.prototype._render = function () {\n      var e,\n          t = this,\n          n = t.$options,\n          r = n.render,\n          i = n._parentVnode;\n      i && (t.$scopedSlots = ft(i.data.scopedSlots, t.$slots, t.$scopedSlots)), t.$vnode = i;\n\n      try {\n        Ht = t, e = r.call(t._renderProxy, t.$createElement);\n      } catch (n) {\n        Re(n, t, \"render\"), e = t._vnode;\n      } finally {\n        Ht = null;\n      }\n\n      return Array.isArray(e) && 1 === e.length && (e = e[0]), e instanceof pe || (e = ve()), e.parent = i, e;\n    };\n  }(wn);\n  var Sn = [String, RegExp, Array],\n      Tn = {\n    KeepAlive: {\n      name: \"keep-alive\",\n      abstract: !0,\n      props: {\n        include: Sn,\n        exclude: Sn,\n        max: [String, Number]\n      },\n      created: function created() {\n        this.cache = Object.create(null), this.keys = [];\n      },\n      destroyed: function destroyed() {\n        for (var e in this.cache) {\n          On(this.cache, e, this.keys);\n        }\n      },\n      mounted: function mounted() {\n        var e = this;\n        this.$watch(\"include\", function (t) {\n          An(e, function (e) {\n            return kn(t, e);\n          });\n        }), this.$watch(\"exclude\", function (t) {\n          An(e, function (e) {\n            return !kn(t, e);\n          });\n        });\n      },\n      render: function render() {\n        var e = this.$slots.default,\n            t = zt(e),\n            n = t && t.componentOptions;\n\n        if (n) {\n          var r = xn(n),\n              i = this.include,\n              o = this.exclude;\n          if (i && (!r || !kn(i, r)) || o && r && kn(o, r)) return t;\n          var a = this.cache,\n              s = this.keys,\n              c = null == t.key ? n.Ctor.cid + (n.tag ? \"::\" + n.tag : \"\") : t.key;\n          a[c] ? (t.componentInstance = a[c].componentInstance, h(s, c), s.push(c)) : (a[c] = t, s.push(c), this.max && s.length > parseInt(this.max) && On(a, s[0], s, this._vnode)), t.data.keepAlive = !0;\n        }\n\n        return t || e && e[0];\n      }\n    }\n  };\n  !function (e) {\n    var t = {\n      get: function get() {\n        return F;\n      }\n    };\n    Object.defineProperty(e, \"config\", t), e.util = {\n      warn: ae,\n      extend: A,\n      mergeOptions: De,\n      defineReactive: xe\n    }, e.set = ke, e.delete = Ae, e.nextTick = Ye, e.observable = function (e) {\n      return Ce(e), e;\n    }, e.options = Object.create(null), M.forEach(function (t) {\n      e.options[t + \"s\"] = Object.create(null);\n    }), e.options._base = e, A(e.options.components, Tn), function (e) {\n      e.use = function (e) {\n        var t = this._installedPlugins || (this._installedPlugins = []);\n        if (t.indexOf(e) > -1) return this;\n        var n = k(arguments, 1);\n        return n.unshift(this), \"function\" == typeof e.install ? e.install.apply(e, n) : \"function\" == typeof e && e.apply(null, n), t.push(e), this;\n      };\n    }(e), function (e) {\n      e.mixin = function (e) {\n        return this.options = De(this.options, e), this;\n      };\n    }(e), Cn(e), function (e) {\n      M.forEach(function (t) {\n        e[t] = function (e, n) {\n          return n ? (\"component\" === t && s(n) && (n.name = n.name || e, n = this.options._base.extend(n)), \"directive\" === t && \"function\" == typeof n && (n = {\n            bind: n,\n            update: n\n          }), this.options[t + \"s\"][e] = n, n) : this.options[t + \"s\"][e];\n        };\n      });\n    }(e);\n  }(wn), Object.defineProperty(wn.prototype, \"$isServer\", {\n    get: te\n  }), Object.defineProperty(wn.prototype, \"$ssrContext\", {\n    get: function get() {\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  }), Object.defineProperty(wn, \"FunctionalRenderContext\", {\n    value: Tt\n  }), wn.version = \"2.6.10\";\n\n  var En = p(\"style,class\"),\n      Nn = p(\"input,textarea,option,select,progress\"),\n      jn = function jn(e, t, n) {\n    return \"value\" === n && Nn(e) && \"button\" !== t || \"selected\" === n && \"option\" === e || \"checked\" === n && \"input\" === e || \"muted\" === n && \"video\" === e;\n  },\n      Dn = p(\"contenteditable,draggable,spellcheck\"),\n      Ln = p(\"events,caret,typing,plaintext-only\"),\n      Mn = function Mn(e, t) {\n    return Hn(t) || \"false\" === t ? \"false\" : \"contenteditable\" === e && Ln(t) ? t : \"true\";\n  },\n      In = p(\"allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible\"),\n      Fn = \"http://www.w3.org/1999/xlink\",\n      Pn = function Pn(e) {\n    return \":\" === e.charAt(5) && \"xlink\" === e.slice(0, 5);\n  },\n      Rn = function Rn(e) {\n    return Pn(e) ? e.slice(6, e.length) : \"\";\n  },\n      Hn = function Hn(e) {\n    return null == e || !1 === e;\n  };\n\n  function Bn(e) {\n    for (var t = e.data, r = e, i = e; n(i.componentInstance);) {\n      (i = i.componentInstance._vnode) && i.data && (t = Un(i.data, t));\n    }\n\n    for (; n(r = r.parent);) {\n      r && r.data && (t = Un(t, r.data));\n    }\n\n    return function (e, t) {\n      if (n(e) || n(t)) return zn(e, Vn(t));\n      return \"\";\n    }(t.staticClass, t.class);\n  }\n\n  function Un(e, t) {\n    return {\n      staticClass: zn(e.staticClass, t.staticClass),\n      class: n(e.class) ? [e.class, t.class] : t.class\n    };\n  }\n\n  function zn(e, t) {\n    return e ? t ? e + \" \" + t : e : t || \"\";\n  }\n\n  function Vn(e) {\n    return Array.isArray(e) ? function (e) {\n      for (var t, r = \"\", i = 0, o = e.length; i < o; i++) {\n        n(t = Vn(e[i])) && \"\" !== t && (r && (r += \" \"), r += t);\n      }\n\n      return r;\n    }(e) : o(e) ? function (e) {\n      var t = \"\";\n\n      for (var n in e) {\n        e[n] && (t && (t += \" \"), t += n);\n      }\n\n      return t;\n    }(e) : \"string\" == typeof e ? e : \"\";\n  }\n\n  var Kn = {\n    svg: \"http://www.w3.org/2000/svg\",\n    math: \"http://www.w3.org/1998/Math/MathML\"\n  },\n      Jn = p(\"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot\"),\n      qn = p(\"svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view\", !0),\n      Wn = function Wn(e) {\n    return Jn(e) || qn(e);\n  };\n\n  function Zn(e) {\n    return qn(e) ? \"svg\" : \"math\" === e ? \"math\" : void 0;\n  }\n\n  var Gn = Object.create(null);\n  var Xn = p(\"text,number,password,search,email,tel,url\");\n\n  function Yn(e) {\n    if (\"string\" == typeof e) {\n      var t = document.querySelector(e);\n      return t || document.createElement(\"div\");\n    }\n\n    return e;\n  }\n\n  var Qn = Object.freeze({\n    createElement: function createElement(e, t) {\n      var n = document.createElement(e);\n      return \"select\" !== e ? n : (t.data && t.data.attrs && void 0 !== t.data.attrs.multiple && n.setAttribute(\"multiple\", \"multiple\"), n);\n    },\n    createElementNS: function createElementNS(e, t) {\n      return document.createElementNS(Kn[e], t);\n    },\n    createTextNode: function createTextNode(e) {\n      return document.createTextNode(e);\n    },\n    createComment: function createComment(e) {\n      return document.createComment(e);\n    },\n    insertBefore: function insertBefore(e, t, n) {\n      e.insertBefore(t, n);\n    },\n    removeChild: function removeChild(e, t) {\n      e.removeChild(t);\n    },\n    appendChild: function appendChild(e, t) {\n      e.appendChild(t);\n    },\n    parentNode: function parentNode(e) {\n      return e.parentNode;\n    },\n    nextSibling: function nextSibling(e) {\n      return e.nextSibling;\n    },\n    tagName: function tagName(e) {\n      return e.tagName;\n    },\n    setTextContent: function setTextContent(e, t) {\n      e.textContent = t;\n    },\n    setStyleScope: function setStyleScope(e, t) {\n      e.setAttribute(t, \"\");\n    }\n  }),\n      er = {\n    create: function create(e, t) {\n      tr(t);\n    },\n    update: function update(e, t) {\n      e.data.ref !== t.data.ref && (tr(e, !0), tr(t));\n    },\n    destroy: function destroy(e) {\n      tr(e, !0);\n    }\n  };\n\n  function tr(e, t) {\n    var r = e.data.ref;\n\n    if (n(r)) {\n      var i = e.context,\n          o = e.componentInstance || e.elm,\n          a = i.$refs;\n      t ? Array.isArray(a[r]) ? h(a[r], o) : a[r] === o && (a[r] = void 0) : e.data.refInFor ? Array.isArray(a[r]) ? a[r].indexOf(o) < 0 && a[r].push(o) : a[r] = [o] : a[r] = o;\n    }\n  }\n\n  var nr = new pe(\"\", {}, []),\n      rr = [\"create\", \"activate\", \"update\", \"remove\", \"destroy\"];\n\n  function ir(e, i) {\n    return e.key === i.key && (e.tag === i.tag && e.isComment === i.isComment && n(e.data) === n(i.data) && function (e, t) {\n      if (\"input\" !== e.tag) return !0;\n      var r,\n          i = n(r = e.data) && n(r = r.attrs) && r.type,\n          o = n(r = t.data) && n(r = r.attrs) && r.type;\n      return i === o || Xn(i) && Xn(o);\n    }(e, i) || r(e.isAsyncPlaceholder) && e.asyncFactory === i.asyncFactory && t(i.asyncFactory.error));\n  }\n\n  function or(e, t, r) {\n    var i,\n        o,\n        a = {};\n\n    for (i = t; i <= r; ++i) {\n      n(o = e[i].key) && (a[o] = i);\n    }\n\n    return a;\n  }\n\n  var ar = {\n    create: sr,\n    update: sr,\n    destroy: function destroy(e) {\n      sr(e, nr);\n    }\n  };\n\n  function sr(e, t) {\n    (e.data.directives || t.data.directives) && function (e, t) {\n      var n,\n          r,\n          i,\n          o = e === nr,\n          a = t === nr,\n          s = ur(e.data.directives, e.context),\n          c = ur(t.data.directives, t.context),\n          u = [],\n          l = [];\n\n      for (n in c) {\n        r = s[n], i = c[n], r ? (i.oldValue = r.value, i.oldArg = r.arg, fr(i, \"update\", t, e), i.def && i.def.componentUpdated && l.push(i)) : (fr(i, \"bind\", t, e), i.def && i.def.inserted && u.push(i));\n      }\n\n      if (u.length) {\n        var f = function f() {\n          for (var n = 0; n < u.length; n++) {\n            fr(u[n], \"inserted\", t, e);\n          }\n        };\n\n        o ? it(t, \"insert\", f) : f();\n      }\n\n      l.length && it(t, \"postpatch\", function () {\n        for (var n = 0; n < l.length; n++) {\n          fr(l[n], \"componentUpdated\", t, e);\n        }\n      });\n      if (!o) for (n in s) {\n        c[n] || fr(s[n], \"unbind\", e, e, a);\n      }\n    }(e, t);\n  }\n\n  var cr = Object.create(null);\n\n  function ur(e, t) {\n    var n,\n        r,\n        i = Object.create(null);\n    if (!e) return i;\n\n    for (n = 0; n < e.length; n++) {\n      (r = e[n]).modifiers || (r.modifiers = cr), i[lr(r)] = r, r.def = Le(t.$options, \"directives\", r.name);\n    }\n\n    return i;\n  }\n\n  function lr(e) {\n    return e.rawName || e.name + \".\" + Object.keys(e.modifiers || {}).join(\".\");\n  }\n\n  function fr(e, t, n, r, i) {\n    var o = e.def && e.def[t];\n    if (o) try {\n      o(n.elm, e, n, r, i);\n    } catch (r) {\n      Re(r, n.context, \"directive \" + e.name + \" \" + t + \" hook\");\n    }\n  }\n\n  var pr = [er, ar];\n\n  function dr(e, r) {\n    var i = r.componentOptions;\n\n    if (!(n(i) && !1 === i.Ctor.options.inheritAttrs || t(e.data.attrs) && t(r.data.attrs))) {\n      var o,\n          a,\n          s = r.elm,\n          c = e.data.attrs || {},\n          u = r.data.attrs || {};\n\n      for (o in n(u.__ob__) && (u = r.data.attrs = A({}, u)), u) {\n        a = u[o], c[o] !== a && vr(s, o, a);\n      }\n\n      for (o in (q || Z) && u.value !== c.value && vr(s, \"value\", u.value), c) {\n        t(u[o]) && (Pn(o) ? s.removeAttributeNS(Fn, Rn(o)) : Dn(o) || s.removeAttribute(o));\n      }\n    }\n  }\n\n  function vr(e, t, n) {\n    e.tagName.indexOf(\"-\") > -1 ? hr(e, t, n) : In(t) ? Hn(n) ? e.removeAttribute(t) : (n = \"allowfullscreen\" === t && \"EMBED\" === e.tagName ? \"true\" : t, e.setAttribute(t, n)) : Dn(t) ? e.setAttribute(t, Mn(t, n)) : Pn(t) ? Hn(n) ? e.removeAttributeNS(Fn, Rn(t)) : e.setAttributeNS(Fn, t, n) : hr(e, t, n);\n  }\n\n  function hr(e, t, n) {\n    if (Hn(n)) e.removeAttribute(t);else {\n      if (q && !W && \"TEXTAREA\" === e.tagName && \"placeholder\" === t && \"\" !== n && !e.__ieph) {\n        var r = function r(t) {\n          t.stopImmediatePropagation(), e.removeEventListener(\"input\", r);\n        };\n\n        e.addEventListener(\"input\", r), e.__ieph = !0;\n      }\n\n      e.setAttribute(t, n);\n    }\n  }\n\n  var mr = {\n    create: dr,\n    update: dr\n  };\n\n  function yr(e, r) {\n    var i = r.elm,\n        o = r.data,\n        a = e.data;\n\n    if (!(t(o.staticClass) && t(o.class) && (t(a) || t(a.staticClass) && t(a.class)))) {\n      var s = Bn(r),\n          c = i._transitionClasses;\n      n(c) && (s = zn(s, Vn(c))), s !== i._prevClass && (i.setAttribute(\"class\", s), i._prevClass = s);\n    }\n  }\n\n  var gr,\n      _r,\n      br,\n      $r,\n      wr,\n      Cr,\n      xr = {\n    create: yr,\n    update: yr\n  },\n      kr = /[\\w).+\\-_$\\]]/;\n\n  function Ar(e) {\n    var t,\n        n,\n        r,\n        i,\n        o,\n        a = !1,\n        s = !1,\n        c = !1,\n        u = !1,\n        l = 0,\n        f = 0,\n        p = 0,\n        d = 0;\n\n    for (r = 0; r < e.length; r++) {\n      if (n = t, t = e.charCodeAt(r), a) 39 === t && 92 !== n && (a = !1);else if (s) 34 === t && 92 !== n && (s = !1);else if (c) 96 === t && 92 !== n && (c = !1);else if (u) 47 === t && 92 !== n && (u = !1);else if (124 !== t || 124 === e.charCodeAt(r + 1) || 124 === e.charCodeAt(r - 1) || l || f || p) {\n        switch (t) {\n          case 34:\n            s = !0;\n            break;\n\n          case 39:\n            a = !0;\n            break;\n\n          case 96:\n            c = !0;\n            break;\n\n          case 40:\n            p++;\n            break;\n\n          case 41:\n            p--;\n            break;\n\n          case 91:\n            f++;\n            break;\n\n          case 93:\n            f--;\n            break;\n\n          case 123:\n            l++;\n            break;\n\n          case 125:\n            l--;\n        }\n\n        if (47 === t) {\n          for (var v = r - 1, h = void 0; v >= 0 && \" \" === (h = e.charAt(v)); v--) {\n            ;\n          }\n\n          h && kr.test(h) || (u = !0);\n        }\n      } else void 0 === i ? (d = r + 1, i = e.slice(0, r).trim()) : m();\n    }\n\n    function m() {\n      (o || (o = [])).push(e.slice(d, r).trim()), d = r + 1;\n    }\n\n    if (void 0 === i ? i = e.slice(0, r).trim() : 0 !== d && m(), o) for (r = 0; r < o.length; r++) {\n      i = Or(i, o[r]);\n    }\n    return i;\n  }\n\n  function Or(e, t) {\n    var n = t.indexOf(\"(\");\n    if (n < 0) return '_f(\"' + t + '\")(' + e + \")\";\n    var r = t.slice(0, n),\n        i = t.slice(n + 1);\n    return '_f(\"' + r + '\")(' + e + (\")\" !== i ? \",\" + i : i);\n  }\n\n  function Sr(e, t) {\n    console.error(\"[Vue compiler]: \" + e);\n  }\n\n  function Tr(e, t) {\n    return e ? e.map(function (e) {\n      return e[t];\n    }).filter(function (e) {\n      return e;\n    }) : [];\n  }\n\n  function Er(e, t, n, r, i) {\n    (e.props || (e.props = [])).push(Rr({\n      name: t,\n      value: n,\n      dynamic: i\n    }, r)), e.plain = !1;\n  }\n\n  function Nr(e, t, n, r, i) {\n    (i ? e.dynamicAttrs || (e.dynamicAttrs = []) : e.attrs || (e.attrs = [])).push(Rr({\n      name: t,\n      value: n,\n      dynamic: i\n    }, r)), e.plain = !1;\n  }\n\n  function jr(e, t, n, r) {\n    e.attrsMap[t] = n, e.attrsList.push(Rr({\n      name: t,\n      value: n\n    }, r));\n  }\n\n  function Dr(e, t, n, r, i, o, a, s) {\n    (e.directives || (e.directives = [])).push(Rr({\n      name: t,\n      rawName: n,\n      value: r,\n      arg: i,\n      isDynamicArg: o,\n      modifiers: a\n    }, s)), e.plain = !1;\n  }\n\n  function Lr(e, t, n) {\n    return n ? \"_p(\" + t + ',\"' + e + '\")' : e + t;\n  }\n\n  function Mr(t, n, r, i, o, a, s, c) {\n    var u;\n    (i = i || e).right ? c ? n = \"(\" + n + \")==='click'?'contextmenu':(\" + n + \")\" : \"click\" === n && (n = \"contextmenu\", delete i.right) : i.middle && (c ? n = \"(\" + n + \")==='click'?'mouseup':(\" + n + \")\" : \"click\" === n && (n = \"mouseup\")), i.capture && (delete i.capture, n = Lr(\"!\", n, c)), i.once && (delete i.once, n = Lr(\"~\", n, c)), i.passive && (delete i.passive, n = Lr(\"&\", n, c)), i.native ? (delete i.native, u = t.nativeEvents || (t.nativeEvents = {})) : u = t.events || (t.events = {});\n    var l = Rr({\n      value: r.trim(),\n      dynamic: c\n    }, s);\n    i !== e && (l.modifiers = i);\n    var f = u[n];\n    Array.isArray(f) ? o ? f.unshift(l) : f.push(l) : u[n] = f ? o ? [l, f] : [f, l] : l, t.plain = !1;\n  }\n\n  function Ir(e, t, n) {\n    var r = Fr(e, \":\" + t) || Fr(e, \"v-bind:\" + t);\n    if (null != r) return Ar(r);\n\n    if (!1 !== n) {\n      var i = Fr(e, t);\n      if (null != i) return JSON.stringify(i);\n    }\n  }\n\n  function Fr(e, t, n) {\n    var r;\n    if (null != (r = e.attrsMap[t])) for (var i = e.attrsList, o = 0, a = i.length; o < a; o++) {\n      if (i[o].name === t) {\n        i.splice(o, 1);\n        break;\n      }\n    }\n    return n && delete e.attrsMap[t], r;\n  }\n\n  function Pr(e, t) {\n    for (var n = e.attrsList, r = 0, i = n.length; r < i; r++) {\n      var o = n[r];\n      if (t.test(o.name)) return n.splice(r, 1), o;\n    }\n  }\n\n  function Rr(e, t) {\n    return t && (null != t.start && (e.start = t.start), null != t.end && (e.end = t.end)), e;\n  }\n\n  function Hr(e, t, n) {\n    var r = n || {},\n        i = r.number,\n        o = \"$$v\";\n    r.trim && (o = \"(typeof $$v === 'string'? $$v.trim(): $$v)\"), i && (o = \"_n(\" + o + \")\");\n    var a = Br(t, o);\n    e.model = {\n      value: \"(\" + t + \")\",\n      expression: JSON.stringify(t),\n      callback: \"function ($$v) {\" + a + \"}\"\n    };\n  }\n\n  function Br(e, t) {\n    var n = function (e) {\n      if (e = e.trim(), gr = e.length, e.indexOf(\"[\") < 0 || e.lastIndexOf(\"]\") < gr - 1) return ($r = e.lastIndexOf(\".\")) > -1 ? {\n        exp: e.slice(0, $r),\n        key: '\"' + e.slice($r + 1) + '\"'\n      } : {\n        exp: e,\n        key: null\n      };\n      _r = e, $r = wr = Cr = 0;\n\n      for (; !zr();) {\n        Vr(br = Ur()) ? Jr(br) : 91 === br && Kr(br);\n      }\n\n      return {\n        exp: e.slice(0, wr),\n        key: e.slice(wr + 1, Cr)\n      };\n    }(e);\n\n    return null === n.key ? e + \"=\" + t : \"$set(\" + n.exp + \", \" + n.key + \", \" + t + \")\";\n  }\n\n  function Ur() {\n    return _r.charCodeAt(++$r);\n  }\n\n  function zr() {\n    return $r >= gr;\n  }\n\n  function Vr(e) {\n    return 34 === e || 39 === e;\n  }\n\n  function Kr(e) {\n    var t = 1;\n\n    for (wr = $r; !zr();) {\n      if (Vr(e = Ur())) Jr(e);else if (91 === e && t++, 93 === e && t--, 0 === t) {\n        Cr = $r;\n        break;\n      }\n    }\n  }\n\n  function Jr(e) {\n    for (var t = e; !zr() && (e = Ur()) !== t;) {\n      ;\n    }\n  }\n\n  var qr,\n      Wr = \"__r\",\n      Zr = \"__c\";\n\n  function Gr(e, t, n) {\n    var r = qr;\n    return function i() {\n      null !== t.apply(null, arguments) && Qr(e, i, n, r);\n    };\n  }\n\n  var Xr = Ve && !(X && Number(X[1]) <= 53);\n\n  function Yr(e, t, n, r) {\n    if (Xr) {\n      var i = an,\n          o = t;\n\n      t = o._wrapper = function (e) {\n        if (e.target === e.currentTarget || e.timeStamp >= i || e.timeStamp <= 0 || e.target.ownerDocument !== document) return o.apply(this, arguments);\n      };\n    }\n\n    qr.addEventListener(e, t, Q ? {\n      capture: n,\n      passive: r\n    } : n);\n  }\n\n  function Qr(e, t, n, r) {\n    (r || qr).removeEventListener(e, t._wrapper || t, n);\n  }\n\n  function ei(e, r) {\n    if (!t(e.data.on) || !t(r.data.on)) {\n      var i = r.data.on || {},\n          o = e.data.on || {};\n      qr = r.elm, function (e) {\n        if (n(e[Wr])) {\n          var t = q ? \"change\" : \"input\";\n          e[t] = [].concat(e[Wr], e[t] || []), delete e[Wr];\n        }\n\n        n(e[Zr]) && (e.change = [].concat(e[Zr], e.change || []), delete e[Zr]);\n      }(i), rt(i, o, Yr, Qr, Gr, r.context), qr = void 0;\n    }\n  }\n\n  var ti,\n      ni = {\n    create: ei,\n    update: ei\n  };\n\n  function ri(e, r) {\n    if (!t(e.data.domProps) || !t(r.data.domProps)) {\n      var i,\n          o,\n          a = r.elm,\n          s = e.data.domProps || {},\n          c = r.data.domProps || {};\n\n      for (i in n(c.__ob__) && (c = r.data.domProps = A({}, c)), s) {\n        i in c || (a[i] = \"\");\n      }\n\n      for (i in c) {\n        if (o = c[i], \"textContent\" === i || \"innerHTML\" === i) {\n          if (r.children && (r.children.length = 0), o === s[i]) continue;\n          1 === a.childNodes.length && a.removeChild(a.childNodes[0]);\n        }\n\n        if (\"value\" === i && \"PROGRESS\" !== a.tagName) {\n          a._value = o;\n          var u = t(o) ? \"\" : String(o);\n          ii(a, u) && (a.value = u);\n        } else if (\"innerHTML\" === i && qn(a.tagName) && t(a.innerHTML)) {\n          (ti = ti || document.createElement(\"div\")).innerHTML = \"<svg>\" + o + \"</svg>\";\n\n          for (var l = ti.firstChild; a.firstChild;) {\n            a.removeChild(a.firstChild);\n          }\n\n          for (; l.firstChild;) {\n            a.appendChild(l.firstChild);\n          }\n        } else if (o !== s[i]) try {\n          a[i] = o;\n        } catch (e) {}\n      }\n    }\n  }\n\n  function ii(e, t) {\n    return !e.composing && (\"OPTION\" === e.tagName || function (e, t) {\n      var n = !0;\n\n      try {\n        n = document.activeElement !== e;\n      } catch (e) {}\n\n      return n && e.value !== t;\n    }(e, t) || function (e, t) {\n      var r = e.value,\n          i = e._vModifiers;\n\n      if (n(i)) {\n        if (i.number) return f(r) !== f(t);\n        if (i.trim) return r.trim() !== t.trim();\n      }\n\n      return r !== t;\n    }(e, t));\n  }\n\n  var oi = {\n    create: ri,\n    update: ri\n  },\n      ai = g(function (e) {\n    var t = {},\n        n = /:(.+)/;\n    return e.split(/;(?![^(]*\\))/g).forEach(function (e) {\n      if (e) {\n        var r = e.split(n);\n        r.length > 1 && (t[r[0].trim()] = r[1].trim());\n      }\n    }), t;\n  });\n\n  function si(e) {\n    var t = ci(e.style);\n    return e.staticStyle ? A(e.staticStyle, t) : t;\n  }\n\n  function ci(e) {\n    return Array.isArray(e) ? O(e) : \"string\" == typeof e ? ai(e) : e;\n  }\n\n  var ui,\n      li = /^--/,\n      fi = /\\s*!important$/,\n      pi = function pi(e, t, n) {\n    if (li.test(t)) e.style.setProperty(t, n);else if (fi.test(n)) e.style.setProperty(C(t), n.replace(fi, \"\"), \"important\");else {\n      var r = vi(t);\n      if (Array.isArray(n)) for (var i = 0, o = n.length; i < o; i++) {\n        e.style[r] = n[i];\n      } else e.style[r] = n;\n    }\n  },\n      di = [\"Webkit\", \"Moz\", \"ms\"],\n      vi = g(function (e) {\n    if (ui = ui || document.createElement(\"div\").style, \"filter\" !== (e = b(e)) && e in ui) return e;\n\n    for (var t = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < di.length; n++) {\n      var r = di[n] + t;\n      if (r in ui) return r;\n    }\n  });\n\n  function hi(e, r) {\n    var i = r.data,\n        o = e.data;\n\n    if (!(t(i.staticStyle) && t(i.style) && t(o.staticStyle) && t(o.style))) {\n      var a,\n          s,\n          c = r.elm,\n          u = o.staticStyle,\n          l = o.normalizedStyle || o.style || {},\n          f = u || l,\n          p = ci(r.data.style) || {};\n      r.data.normalizedStyle = n(p.__ob__) ? A({}, p) : p;\n\n      var d = function (e, t) {\n        var n,\n            r = {};\n        if (t) for (var i = e; i.componentInstance;) {\n          (i = i.componentInstance._vnode) && i.data && (n = si(i.data)) && A(r, n);\n        }\n        (n = si(e.data)) && A(r, n);\n\n        for (var o = e; o = o.parent;) {\n          o.data && (n = si(o.data)) && A(r, n);\n        }\n\n        return r;\n      }(r, !0);\n\n      for (s in f) {\n        t(d[s]) && pi(c, s, \"\");\n      }\n\n      for (s in d) {\n        (a = d[s]) !== f[s] && pi(c, s, null == a ? \"\" : a);\n      }\n    }\n  }\n\n  var mi = {\n    create: hi,\n    update: hi\n  },\n      yi = /\\s+/;\n\n  function gi(e, t) {\n    if (t && (t = t.trim())) if (e.classList) t.indexOf(\" \") > -1 ? t.split(yi).forEach(function (t) {\n      return e.classList.add(t);\n    }) : e.classList.add(t);else {\n      var n = \" \" + (e.getAttribute(\"class\") || \"\") + \" \";\n      n.indexOf(\" \" + t + \" \") < 0 && e.setAttribute(\"class\", (n + t).trim());\n    }\n  }\n\n  function _i(e, t) {\n    if (t && (t = t.trim())) if (e.classList) t.indexOf(\" \") > -1 ? t.split(yi).forEach(function (t) {\n      return e.classList.remove(t);\n    }) : e.classList.remove(t), e.classList.length || e.removeAttribute(\"class\");else {\n      for (var n = \" \" + (e.getAttribute(\"class\") || \"\") + \" \", r = \" \" + t + \" \"; n.indexOf(r) >= 0;) {\n        n = n.replace(r, \" \");\n      }\n\n      (n = n.trim()) ? e.setAttribute(\"class\", n) : e.removeAttribute(\"class\");\n    }\n  }\n\n  function bi(e) {\n    if (e) {\n      if (\"object\" == _typeof(e)) {\n        var t = {};\n        return !1 !== e.css && A(t, $i(e.name || \"v\")), A(t, e), t;\n      }\n\n      return \"string\" == typeof e ? $i(e) : void 0;\n    }\n  }\n\n  var $i = g(function (e) {\n    return {\n      enterClass: e + \"-enter\",\n      enterToClass: e + \"-enter-to\",\n      enterActiveClass: e + \"-enter-active\",\n      leaveClass: e + \"-leave\",\n      leaveToClass: e + \"-leave-to\",\n      leaveActiveClass: e + \"-leave-active\"\n    };\n  }),\n      wi = z && !W,\n      Ci = \"transition\",\n      xi = \"animation\",\n      ki = \"transition\",\n      Ai = \"transitionend\",\n      Oi = \"animation\",\n      Si = \"animationend\";\n  wi && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (ki = \"WebkitTransition\", Ai = \"webkitTransitionEnd\"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Oi = \"WebkitAnimation\", Si = \"webkitAnimationEnd\"));\n  var Ti = z ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function (e) {\n    return e();\n  };\n\n  function Ei(e) {\n    Ti(function () {\n      Ti(e);\n    });\n  }\n\n  function Ni(e, t) {\n    var n = e._transitionClasses || (e._transitionClasses = []);\n    n.indexOf(t) < 0 && (n.push(t), gi(e, t));\n  }\n\n  function ji(e, t) {\n    e._transitionClasses && h(e._transitionClasses, t), _i(e, t);\n  }\n\n  function Di(e, t, n) {\n    var r = Mi(e, t),\n        i = r.type,\n        o = r.timeout,\n        a = r.propCount;\n    if (!i) return n();\n\n    var s = i === Ci ? Ai : Si,\n        c = 0,\n        u = function u() {\n      e.removeEventListener(s, l), n();\n    },\n        l = function l(t) {\n      t.target === e && ++c >= a && u();\n    };\n\n    setTimeout(function () {\n      c < a && u();\n    }, o + 1), e.addEventListener(s, l);\n  }\n\n  var Li = /\\b(transform|all)(,|$)/;\n\n  function Mi(e, t) {\n    var n,\n        r = window.getComputedStyle(e),\n        i = (r[ki + \"Delay\"] || \"\").split(\", \"),\n        o = (r[ki + \"Duration\"] || \"\").split(\", \"),\n        a = Ii(i, o),\n        s = (r[Oi + \"Delay\"] || \"\").split(\", \"),\n        c = (r[Oi + \"Duration\"] || \"\").split(\", \"),\n        u = Ii(s, c),\n        l = 0,\n        f = 0;\n    return t === Ci ? a > 0 && (n = Ci, l = a, f = o.length) : t === xi ? u > 0 && (n = xi, l = u, f = c.length) : f = (n = (l = Math.max(a, u)) > 0 ? a > u ? Ci : xi : null) ? n === Ci ? o.length : c.length : 0, {\n      type: n,\n      timeout: l,\n      propCount: f,\n      hasTransform: n === Ci && Li.test(r[ki + \"Property\"])\n    };\n  }\n\n  function Ii(e, t) {\n    for (; e.length < t.length;) {\n      e = e.concat(e);\n    }\n\n    return Math.max.apply(null, t.map(function (t, n) {\n      return Fi(t) + Fi(e[n]);\n    }));\n  }\n\n  function Fi(e) {\n    return 1e3 * Number(e.slice(0, -1).replace(\",\", \".\"));\n  }\n\n  function Pi(e, r) {\n    var i = e.elm;\n    n(i._leaveCb) && (i._leaveCb.cancelled = !0, i._leaveCb());\n    var a = bi(e.data.transition);\n\n    if (!t(a) && !n(i._enterCb) && 1 === i.nodeType) {\n      for (var s = a.css, c = a.type, u = a.enterClass, l = a.enterToClass, p = a.enterActiveClass, d = a.appearClass, v = a.appearToClass, h = a.appearActiveClass, m = a.beforeEnter, y = a.enter, g = a.afterEnter, _ = a.enterCancelled, b = a.beforeAppear, $ = a.appear, w = a.afterAppear, C = a.appearCancelled, x = a.duration, k = Wt, A = Wt.$vnode; A && A.parent;) {\n        k = A.context, A = A.parent;\n      }\n\n      var O = !k._isMounted || !e.isRootInsert;\n\n      if (!O || $ || \"\" === $) {\n        var S = O && d ? d : u,\n            T = O && h ? h : p,\n            E = O && v ? v : l,\n            N = O && b || m,\n            j = O && \"function\" == typeof $ ? $ : y,\n            L = O && w || g,\n            M = O && C || _,\n            I = f(o(x) ? x.enter : x),\n            F = !1 !== s && !W,\n            P = Bi(j),\n            R = i._enterCb = D(function () {\n          F && (ji(i, E), ji(i, T)), R.cancelled ? (F && ji(i, S), M && M(i)) : L && L(i), i._enterCb = null;\n        });\n        e.data.show || it(e, \"insert\", function () {\n          var t = i.parentNode,\n              n = t && t._pending && t._pending[e.key];\n          n && n.tag === e.tag && n.elm._leaveCb && n.elm._leaveCb(), j && j(i, R);\n        }), N && N(i), F && (Ni(i, S), Ni(i, T), Ei(function () {\n          ji(i, S), R.cancelled || (Ni(i, E), P || (Hi(I) ? setTimeout(R, I) : Di(i, c, R)));\n        })), e.data.show && (r && r(), j && j(i, R)), F || P || R();\n      }\n    }\n  }\n\n  function Ri(e, r) {\n    var i = e.elm;\n    n(i._enterCb) && (i._enterCb.cancelled = !0, i._enterCb());\n    var a = bi(e.data.transition);\n    if (t(a) || 1 !== i.nodeType) return r();\n\n    if (!n(i._leaveCb)) {\n      var s = a.css,\n          c = a.type,\n          u = a.leaveClass,\n          l = a.leaveToClass,\n          p = a.leaveActiveClass,\n          d = a.beforeLeave,\n          v = a.leave,\n          h = a.afterLeave,\n          m = a.leaveCancelled,\n          y = a.delayLeave,\n          g = a.duration,\n          _ = !1 !== s && !W,\n          b = Bi(v),\n          $ = f(o(g) ? g.leave : g),\n          w = i._leaveCb = D(function () {\n        i.parentNode && i.parentNode._pending && (i.parentNode._pending[e.key] = null), _ && (ji(i, l), ji(i, p)), w.cancelled ? (_ && ji(i, u), m && m(i)) : (r(), h && h(i)), i._leaveCb = null;\n      });\n\n      y ? y(C) : C();\n    }\n\n    function C() {\n      w.cancelled || (!e.data.show && i.parentNode && ((i.parentNode._pending || (i.parentNode._pending = {}))[e.key] = e), d && d(i), _ && (Ni(i, u), Ni(i, p), Ei(function () {\n        ji(i, u), w.cancelled || (Ni(i, l), b || (Hi($) ? setTimeout(w, $) : Di(i, c, w)));\n      })), v && v(i, w), _ || b || w());\n    }\n  }\n\n  function Hi(e) {\n    return \"number\" == typeof e && !isNaN(e);\n  }\n\n  function Bi(e) {\n    if (t(e)) return !1;\n    var r = e.fns;\n    return n(r) ? Bi(Array.isArray(r) ? r[0] : r) : (e._length || e.length) > 1;\n  }\n\n  function Ui(e, t) {\n    !0 !== t.data.show && Pi(t);\n  }\n\n  var zi = function (e) {\n    var o,\n        a,\n        s = {},\n        c = e.modules,\n        u = e.nodeOps;\n\n    for (o = 0; o < rr.length; ++o) {\n      for (s[rr[o]] = [], a = 0; a < c.length; ++a) {\n        n(c[a][rr[o]]) && s[rr[o]].push(c[a][rr[o]]);\n      }\n    }\n\n    function l(e) {\n      var t = u.parentNode(e);\n      n(t) && u.removeChild(t, e);\n    }\n\n    function f(e, t, i, o, a, c, l) {\n      if (n(e.elm) && n(c) && (e = c[l] = me(e)), e.isRootInsert = !a, !function (e, t, i, o) {\n        var a = e.data;\n\n        if (n(a)) {\n          var c = n(e.componentInstance) && a.keepAlive;\n          if (n(a = a.hook) && n(a = a.init) && a(e, !1), n(e.componentInstance)) return d(e, t), v(i, e.elm, o), r(c) && function (e, t, r, i) {\n            for (var o, a = e; a.componentInstance;) {\n              if (a = a.componentInstance._vnode, n(o = a.data) && n(o = o.transition)) {\n                for (o = 0; o < s.activate.length; ++o) {\n                  s.activate[o](nr, a);\n                }\n\n                t.push(a);\n                break;\n              }\n            }\n\n            v(r, e.elm, i);\n          }(e, t, i, o), !0;\n        }\n      }(e, t, i, o)) {\n        var f = e.data,\n            p = e.children,\n            m = e.tag;\n        n(m) ? (e.elm = e.ns ? u.createElementNS(e.ns, m) : u.createElement(m, e), g(e), h(e, p, t), n(f) && y(e, t), v(i, e.elm, o)) : r(e.isComment) ? (e.elm = u.createComment(e.text), v(i, e.elm, o)) : (e.elm = u.createTextNode(e.text), v(i, e.elm, o));\n      }\n    }\n\n    function d(e, t) {\n      n(e.data.pendingInsert) && (t.push.apply(t, e.data.pendingInsert), e.data.pendingInsert = null), e.elm = e.componentInstance.$el, m(e) ? (y(e, t), g(e)) : (tr(e), t.push(e));\n    }\n\n    function v(e, t, r) {\n      n(e) && (n(r) ? u.parentNode(r) === e && u.insertBefore(e, t, r) : u.appendChild(e, t));\n    }\n\n    function h(e, t, n) {\n      if (Array.isArray(t)) for (var r = 0; r < t.length; ++r) {\n        f(t[r], n, e.elm, null, !0, t, r);\n      } else i(e.text) && u.appendChild(e.elm, u.createTextNode(String(e.text)));\n    }\n\n    function m(e) {\n      for (; e.componentInstance;) {\n        e = e.componentInstance._vnode;\n      }\n\n      return n(e.tag);\n    }\n\n    function y(e, t) {\n      for (var r = 0; r < s.create.length; ++r) {\n        s.create[r](nr, e);\n      }\n\n      n(o = e.data.hook) && (n(o.create) && o.create(nr, e), n(o.insert) && t.push(e));\n    }\n\n    function g(e) {\n      var t;\n      if (n(t = e.fnScopeId)) u.setStyleScope(e.elm, t);else for (var r = e; r;) {\n        n(t = r.context) && n(t = t.$options._scopeId) && u.setStyleScope(e.elm, t), r = r.parent;\n      }\n      n(t = Wt) && t !== e.context && t !== e.fnContext && n(t = t.$options._scopeId) && u.setStyleScope(e.elm, t);\n    }\n\n    function _(e, t, n, r, i, o) {\n      for (; r <= i; ++r) {\n        f(n[r], o, e, t, !1, n, r);\n      }\n    }\n\n    function b(e) {\n      var t,\n          r,\n          i = e.data;\n      if (n(i)) for (n(t = i.hook) && n(t = t.destroy) && t(e), t = 0; t < s.destroy.length; ++t) {\n        s.destroy[t](e);\n      }\n      if (n(t = e.children)) for (r = 0; r < e.children.length; ++r) {\n        b(e.children[r]);\n      }\n    }\n\n    function $(e, t, r, i) {\n      for (; r <= i; ++r) {\n        var o = t[r];\n        n(o) && (n(o.tag) ? (w(o), b(o)) : l(o.elm));\n      }\n    }\n\n    function w(e, t) {\n      if (n(t) || n(e.data)) {\n        var r,\n            i = s.remove.length + 1;\n\n        for (n(t) ? t.listeners += i : t = function (e, t) {\n          function n() {\n            0 == --n.listeners && l(e);\n          }\n\n          return n.listeners = t, n;\n        }(e.elm, i), n(r = e.componentInstance) && n(r = r._vnode) && n(r.data) && w(r, t), r = 0; r < s.remove.length; ++r) {\n          s.remove[r](e, t);\n        }\n\n        n(r = e.data.hook) && n(r = r.remove) ? r(e, t) : t();\n      } else l(e.elm);\n    }\n\n    function C(e, t, r, i) {\n      for (var o = r; o < i; o++) {\n        var a = t[o];\n        if (n(a) && ir(e, a)) return o;\n      }\n    }\n\n    function x(e, i, o, a, c, l) {\n      if (e !== i) {\n        n(i.elm) && n(a) && (i = a[c] = me(i));\n        var p = i.elm = e.elm;\n        if (r(e.isAsyncPlaceholder)) n(i.asyncFactory.resolved) ? O(e.elm, i, o) : i.isAsyncPlaceholder = !0;else if (r(i.isStatic) && r(e.isStatic) && i.key === e.key && (r(i.isCloned) || r(i.isOnce))) i.componentInstance = e.componentInstance;else {\n          var d,\n              v = i.data;\n          n(v) && n(d = v.hook) && n(d = d.prepatch) && d(e, i);\n          var h = e.children,\n              y = i.children;\n\n          if (n(v) && m(i)) {\n            for (d = 0; d < s.update.length; ++d) {\n              s.update[d](e, i);\n            }\n\n            n(d = v.hook) && n(d = d.update) && d(e, i);\n          }\n\n          t(i.text) ? n(h) && n(y) ? h !== y && function (e, r, i, o, a) {\n            for (var s, c, l, p = 0, d = 0, v = r.length - 1, h = r[0], m = r[v], y = i.length - 1, g = i[0], b = i[y], w = !a; p <= v && d <= y;) {\n              t(h) ? h = r[++p] : t(m) ? m = r[--v] : ir(h, g) ? (x(h, g, o, i, d), h = r[++p], g = i[++d]) : ir(m, b) ? (x(m, b, o, i, y), m = r[--v], b = i[--y]) : ir(h, b) ? (x(h, b, o, i, y), w && u.insertBefore(e, h.elm, u.nextSibling(m.elm)), h = r[++p], b = i[--y]) : ir(m, g) ? (x(m, g, o, i, d), w && u.insertBefore(e, m.elm, h.elm), m = r[--v], g = i[++d]) : (t(s) && (s = or(r, p, v)), t(c = n(g.key) ? s[g.key] : C(g, r, p, v)) ? f(g, o, e, h.elm, !1, i, d) : ir(l = r[c], g) ? (x(l, g, o, i, d), r[c] = void 0, w && u.insertBefore(e, l.elm, h.elm)) : f(g, o, e, h.elm, !1, i, d), g = i[++d]);\n            }\n\n            p > v ? _(e, t(i[y + 1]) ? null : i[y + 1].elm, i, d, y, o) : d > y && $(0, r, p, v);\n          }(p, h, y, o, l) : n(y) ? (n(e.text) && u.setTextContent(p, \"\"), _(p, null, y, 0, y.length - 1, o)) : n(h) ? $(0, h, 0, h.length - 1) : n(e.text) && u.setTextContent(p, \"\") : e.text !== i.text && u.setTextContent(p, i.text), n(v) && n(d = v.hook) && n(d = d.postpatch) && d(e, i);\n        }\n      }\n    }\n\n    function k(e, t, i) {\n      if (r(i) && n(e.parent)) e.parent.data.pendingInsert = t;else for (var o = 0; o < t.length; ++o) {\n        t[o].data.hook.insert(t[o]);\n      }\n    }\n\n    var A = p(\"attrs,class,staticClass,staticStyle,key\");\n\n    function O(e, t, i, o) {\n      var a,\n          s = t.tag,\n          c = t.data,\n          u = t.children;\n      if (o = o || c && c.pre, t.elm = e, r(t.isComment) && n(t.asyncFactory)) return t.isAsyncPlaceholder = !0, !0;\n      if (n(c) && (n(a = c.hook) && n(a = a.init) && a(t, !0), n(a = t.componentInstance))) return d(t, i), !0;\n\n      if (n(s)) {\n        if (n(u)) if (e.hasChildNodes()) {\n          if (n(a = c) && n(a = a.domProps) && n(a = a.innerHTML)) {\n            if (a !== e.innerHTML) return !1;\n          } else {\n            for (var l = !0, f = e.firstChild, p = 0; p < u.length; p++) {\n              if (!f || !O(f, u[p], i, o)) {\n                l = !1;\n                break;\n              }\n\n              f = f.nextSibling;\n            }\n\n            if (!l || f) return !1;\n          }\n        } else h(t, u, i);\n\n        if (n(c)) {\n          var v = !1;\n\n          for (var m in c) {\n            if (!A(m)) {\n              v = !0, y(t, i);\n              break;\n            }\n          }\n\n          !v && c.class && et(c.class);\n        }\n      } else e.data !== t.text && (e.data = t.text);\n\n      return !0;\n    }\n\n    return function (e, i, o, a) {\n      if (!t(i)) {\n        var c,\n            l = !1,\n            p = [];\n        if (t(e)) l = !0, f(i, p);else {\n          var d = n(e.nodeType);\n          if (!d && ir(e, i)) x(e, i, p, null, null, a);else {\n            if (d) {\n              if (1 === e.nodeType && e.hasAttribute(L) && (e.removeAttribute(L), o = !0), r(o) && O(e, i, p)) return k(i, p, !0), e;\n              c = e, e = new pe(u.tagName(c).toLowerCase(), {}, [], void 0, c);\n            }\n\n            var v = e.elm,\n                h = u.parentNode(v);\n            if (f(i, p, v._leaveCb ? null : h, u.nextSibling(v)), n(i.parent)) for (var y = i.parent, g = m(i); y;) {\n              for (var _ = 0; _ < s.destroy.length; ++_) {\n                s.destroy[_](y);\n              }\n\n              if (y.elm = i.elm, g) {\n                for (var w = 0; w < s.create.length; ++w) {\n                  s.create[w](nr, y);\n                }\n\n                var C = y.data.hook.insert;\n                if (C.merged) for (var A = 1; A < C.fns.length; A++) {\n                  C.fns[A]();\n                }\n              } else tr(y);\n\n              y = y.parent;\n            }\n            n(h) ? $(0, [e], 0, 0) : n(e.tag) && b(e);\n          }\n        }\n        return k(i, p, l), i.elm;\n      }\n\n      n(e) && b(e);\n    };\n  }({\n    nodeOps: Qn,\n    modules: [mr, xr, ni, oi, mi, z ? {\n      create: Ui,\n      activate: Ui,\n      remove: function remove(e, t) {\n        !0 !== e.data.show ? Ri(e, t) : t();\n      }\n    } : {}].concat(pr)\n  });\n\n  W && document.addEventListener(\"selectionchange\", function () {\n    var e = document.activeElement;\n    e && e.vmodel && Xi(e, \"input\");\n  });\n  var Vi = {\n    inserted: function inserted(e, t, n, r) {\n      \"select\" === n.tag ? (r.elm && !r.elm._vOptions ? it(n, \"postpatch\", function () {\n        Vi.componentUpdated(e, t, n);\n      }) : Ki(e, t, n.context), e._vOptions = [].map.call(e.options, Wi)) : (\"textarea\" === n.tag || Xn(e.type)) && (e._vModifiers = t.modifiers, t.modifiers.lazy || (e.addEventListener(\"compositionstart\", Zi), e.addEventListener(\"compositionend\", Gi), e.addEventListener(\"change\", Gi), W && (e.vmodel = !0)));\n    },\n    componentUpdated: function componentUpdated(e, t, n) {\n      if (\"select\" === n.tag) {\n        Ki(e, t, n.context);\n        var r = e._vOptions,\n            i = e._vOptions = [].map.call(e.options, Wi);\n        if (i.some(function (e, t) {\n          return !N(e, r[t]);\n        })) (e.multiple ? t.value.some(function (e) {\n          return qi(e, i);\n        }) : t.value !== t.oldValue && qi(t.value, i)) && Xi(e, \"change\");\n      }\n    }\n  };\n\n  function Ki(e, t, n) {\n    Ji(e, t, n), (q || Z) && setTimeout(function () {\n      Ji(e, t, n);\n    }, 0);\n  }\n\n  function Ji(e, t, n) {\n    var r = t.value,\n        i = e.multiple;\n\n    if (!i || Array.isArray(r)) {\n      for (var o, a, s = 0, c = e.options.length; s < c; s++) {\n        if (a = e.options[s], i) o = j(r, Wi(a)) > -1, a.selected !== o && (a.selected = o);else if (N(Wi(a), r)) return void (e.selectedIndex !== s && (e.selectedIndex = s));\n      }\n\n      i || (e.selectedIndex = -1);\n    }\n  }\n\n  function qi(e, t) {\n    return t.every(function (t) {\n      return !N(t, e);\n    });\n  }\n\n  function Wi(e) {\n    return \"_value\" in e ? e._value : e.value;\n  }\n\n  function Zi(e) {\n    e.target.composing = !0;\n  }\n\n  function Gi(e) {\n    e.target.composing && (e.target.composing = !1, Xi(e.target, \"input\"));\n  }\n\n  function Xi(e, t) {\n    var n = document.createEvent(\"HTMLEvents\");\n    n.initEvent(t, !0, !0), e.dispatchEvent(n);\n  }\n\n  function Yi(e) {\n    return !e.componentInstance || e.data && e.data.transition ? e : Yi(e.componentInstance._vnode);\n  }\n\n  var Qi = {\n    model: Vi,\n    show: {\n      bind: function bind(e, t, n) {\n        var r = t.value,\n            i = (n = Yi(n)).data && n.data.transition,\n            o = e.__vOriginalDisplay = \"none\" === e.style.display ? \"\" : e.style.display;\n        r && i ? (n.data.show = !0, Pi(n, function () {\n          e.style.display = o;\n        })) : e.style.display = r ? o : \"none\";\n      },\n      update: function update(e, t, n) {\n        var r = t.value;\n        !r != !t.oldValue && ((n = Yi(n)).data && n.data.transition ? (n.data.show = !0, r ? Pi(n, function () {\n          e.style.display = e.__vOriginalDisplay;\n        }) : Ri(n, function () {\n          e.style.display = \"none\";\n        })) : e.style.display = r ? e.__vOriginalDisplay : \"none\");\n      },\n      unbind: function unbind(e, t, n, r, i) {\n        i || (e.style.display = e.__vOriginalDisplay);\n      }\n    }\n  },\n      eo = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  function to(e) {\n    var t = e && e.componentOptions;\n    return t && t.Ctor.options.abstract ? to(zt(t.children)) : e;\n  }\n\n  function no(e) {\n    var t = {},\n        n = e.$options;\n\n    for (var r in n.propsData) {\n      t[r] = e[r];\n    }\n\n    var i = n._parentListeners;\n\n    for (var o in i) {\n      t[b(o)] = i[o];\n    }\n\n    return t;\n  }\n\n  function ro(e, t) {\n    if (/\\d-keep-alive$/.test(t.tag)) return e(\"keep-alive\", {\n      props: t.componentOptions.propsData\n    });\n  }\n\n  var io = function io(e) {\n    return e.tag || Ut(e);\n  },\n      oo = function oo(e) {\n    return \"show\" === e.name;\n  },\n      ao = {\n    name: \"transition\",\n    props: eo,\n    abstract: !0,\n    render: function render(e) {\n      var t = this,\n          n = this.$slots.default;\n\n      if (n && (n = n.filter(io)).length) {\n        var r = this.mode,\n            o = n[0];\n        if (function (e) {\n          for (; e = e.parent;) {\n            if (e.data.transition) return !0;\n          }\n        }(this.$vnode)) return o;\n        var a = to(o);\n        if (!a) return o;\n        if (this._leaving) return ro(e, o);\n        var s = \"__transition-\" + this._uid + \"-\";\n        a.key = null == a.key ? a.isComment ? s + \"comment\" : s + a.tag : i(a.key) ? 0 === String(a.key).indexOf(s) ? a.key : s + a.key : a.key;\n        var c = (a.data || (a.data = {})).transition = no(this),\n            u = this._vnode,\n            l = to(u);\n\n        if (a.data.directives && a.data.directives.some(oo) && (a.data.show = !0), l && l.data && !function (e, t) {\n          return t.key === e.key && t.tag === e.tag;\n        }(a, l) && !Ut(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) {\n          var f = l.data.transition = A({}, c);\n          if (\"out-in\" === r) return this._leaving = !0, it(f, \"afterLeave\", function () {\n            t._leaving = !1, t.$forceUpdate();\n          }), ro(e, o);\n\n          if (\"in-out\" === r) {\n            if (Ut(a)) return u;\n\n            var p,\n                d = function d() {\n              p();\n            };\n\n            it(c, \"afterEnter\", d), it(c, \"enterCancelled\", d), it(f, \"delayLeave\", function (e) {\n              p = e;\n            });\n          }\n        }\n\n        return o;\n      }\n    }\n  },\n      so = A({\n    tag: String,\n    moveClass: String\n  }, eo);\n\n  function co(e) {\n    e.elm._moveCb && e.elm._moveCb(), e.elm._enterCb && e.elm._enterCb();\n  }\n\n  function uo(e) {\n    e.data.newPos = e.elm.getBoundingClientRect();\n  }\n\n  function lo(e) {\n    var t = e.data.pos,\n        n = e.data.newPos,\n        r = t.left - n.left,\n        i = t.top - n.top;\n\n    if (r || i) {\n      e.data.moved = !0;\n      var o = e.elm.style;\n      o.transform = o.WebkitTransform = \"translate(\" + r + \"px,\" + i + \"px)\", o.transitionDuration = \"0s\";\n    }\n  }\n\n  delete so.mode;\n  var fo = {\n    Transition: ao,\n    TransitionGroup: {\n      props: so,\n      beforeMount: function beforeMount() {\n        var e = this,\n            t = this._update;\n\n        this._update = function (n, r) {\n          var i = Zt(e);\n          e.__patch__(e._vnode, e.kept, !1, !0), e._vnode = e.kept, i(), t.call(e, n, r);\n        };\n      },\n      render: function render(e) {\n        for (var t = this.tag || this.$vnode.data.tag || \"span\", n = Object.create(null), r = this.prevChildren = this.children, i = this.$slots.default || [], o = this.children = [], a = no(this), s = 0; s < i.length; s++) {\n          var c = i[s];\n          c.tag && null != c.key && 0 !== String(c.key).indexOf(\"__vlist\") && (o.push(c), n[c.key] = c, (c.data || (c.data = {})).transition = a);\n        }\n\n        if (r) {\n          for (var u = [], l = [], f = 0; f < r.length; f++) {\n            var p = r[f];\n            p.data.transition = a, p.data.pos = p.elm.getBoundingClientRect(), n[p.key] ? u.push(p) : l.push(p);\n          }\n\n          this.kept = e(t, null, u), this.removed = l;\n        }\n\n        return e(t, null, o);\n      },\n      updated: function updated() {\n        var e = this.prevChildren,\n            t = this.moveClass || (this.name || \"v\") + \"-move\";\n        e.length && this.hasMove(e[0].elm, t) && (e.forEach(co), e.forEach(uo), e.forEach(lo), this._reflow = document.body.offsetHeight, e.forEach(function (e) {\n          if (e.data.moved) {\n            var n = e.elm,\n                r = n.style;\n            Ni(n, t), r.transform = r.WebkitTransform = r.transitionDuration = \"\", n.addEventListener(Ai, n._moveCb = function e(r) {\n              r && r.target !== n || r && !/transform$/.test(r.propertyName) || (n.removeEventListener(Ai, e), n._moveCb = null, ji(n, t));\n            });\n          }\n        }));\n      },\n      methods: {\n        hasMove: function hasMove(e, t) {\n          if (!wi) return !1;\n          if (this._hasMove) return this._hasMove;\n          var n = e.cloneNode();\n          e._transitionClasses && e._transitionClasses.forEach(function (e) {\n            _i(n, e);\n          }), gi(n, t), n.style.display = \"none\", this.$el.appendChild(n);\n          var r = Mi(n);\n          return this.$el.removeChild(n), this._hasMove = r.hasTransform;\n        }\n      }\n    }\n  };\n  wn.config.mustUseProp = jn, wn.config.isReservedTag = Wn, wn.config.isReservedAttr = En, wn.config.getTagNamespace = Zn, wn.config.isUnknownElement = function (e) {\n    if (!z) return !0;\n    if (Wn(e)) return !1;\n    if (e = e.toLowerCase(), null != Gn[e]) return Gn[e];\n    var t = document.createElement(e);\n    return e.indexOf(\"-\") > -1 ? Gn[e] = t.constructor === window.HTMLUnknownElement || t.constructor === window.HTMLElement : Gn[e] = /HTMLUnknownElement/.test(t.toString());\n  }, A(wn.options.directives, Qi), A(wn.options.components, fo), wn.prototype.__patch__ = z ? zi : S, wn.prototype.$mount = function (e, t) {\n    return function (e, t, n) {\n      var r;\n      return e.$el = t, e.$options.render || (e.$options.render = ve), Yt(e, \"beforeMount\"), r = function r() {\n        e._update(e._render(), n);\n      }, new fn(e, r, S, {\n        before: function before() {\n          e._isMounted && !e._isDestroyed && Yt(e, \"beforeUpdate\");\n        }\n      }, !0), n = !1, null == e.$vnode && (e._isMounted = !0, Yt(e, \"mounted\")), e;\n    }(this, e = e && z ? Yn(e) : void 0, t);\n  }, z && setTimeout(function () {\n    F.devtools && ne && ne.emit(\"init\", wn);\n  }, 0);\n  var po = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g,\n      vo = /[-.*+?^${}()|[\\]\\/\\\\]/g,\n      ho = g(function (e) {\n    var t = e[0].replace(vo, \"\\\\$&\"),\n        n = e[1].replace(vo, \"\\\\$&\");\n    return new RegExp(t + \"((?:.|\\\\n)+?)\" + n, \"g\");\n  });\n  var mo = {\n    staticKeys: [\"staticClass\"],\n    transformNode: function transformNode(e, t) {\n      t.warn;\n      var n = Fr(e, \"class\");\n      n && (e.staticClass = JSON.stringify(n));\n      var r = Ir(e, \"class\", !1);\n      r && (e.classBinding = r);\n    },\n    genData: function genData(e) {\n      var t = \"\";\n      return e.staticClass && (t += \"staticClass:\" + e.staticClass + \",\"), e.classBinding && (t += \"class:\" + e.classBinding + \",\"), t;\n    }\n  };\n\n  var yo,\n      go = {\n    staticKeys: [\"staticStyle\"],\n    transformNode: function transformNode(e, t) {\n      t.warn;\n      var n = Fr(e, \"style\");\n      n && (e.staticStyle = JSON.stringify(ai(n)));\n      var r = Ir(e, \"style\", !1);\n      r && (e.styleBinding = r);\n    },\n    genData: function genData(e) {\n      var t = \"\";\n      return e.staticStyle && (t += \"staticStyle:\" + e.staticStyle + \",\"), e.styleBinding && (t += \"style:(\" + e.styleBinding + \"),\"), t;\n    }\n  },\n      _o = function _o(e) {\n    return (yo = yo || document.createElement(\"div\")).innerHTML = e, yo.textContent;\n  },\n      bo = p(\"area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr\"),\n      $o = p(\"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source\"),\n      wo = p(\"address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track\"),\n      Co = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/,\n      xo = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/,\n      ko = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + P.source + \"]*\",\n      Ao = \"((?:\" + ko + \"\\\\:)?\" + ko + \")\",\n      Oo = new RegExp(\"^<\" + Ao),\n      So = /^\\s*(\\/?)>/,\n      To = new RegExp(\"^<\\\\/\" + Ao + \"[^>]*>\"),\n      Eo = /^<!DOCTYPE [^>]+>/i,\n      No = /^<!\\--/,\n      jo = /^<!\\[/,\n      Do = p(\"script,style,textarea\", !0),\n      Lo = {},\n      Mo = {\n    \"&lt;\": \"<\",\n    \"&gt;\": \">\",\n    \"&quot;\": '\"',\n    \"&amp;\": \"&\",\n    \"&#10;\": \"\\n\",\n    \"&#9;\": \"\\t\",\n    \"&#39;\": \"'\"\n  },\n      Io = /&(?:lt|gt|quot|amp|#39);/g,\n      Fo = /&(?:lt|gt|quot|amp|#39|#10|#9);/g,\n      Po = p(\"pre,textarea\", !0),\n      Ro = function Ro(e, t) {\n    return e && Po(e) && \"\\n\" === t[0];\n  };\n\n  function Ho(e, t) {\n    var n = t ? Fo : Io;\n    return e.replace(n, function (e) {\n      return Mo[e];\n    });\n  }\n\n  var Bo,\n      Uo,\n      zo,\n      Vo,\n      Ko,\n      Jo,\n      qo,\n      Wo,\n      Zo = /^@|^v-on:/,\n      Go = /^v-|^@|^:/,\n      Xo = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/,\n      Yo = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/,\n      Qo = /^\\(|\\)$/g,\n      ea = /^\\[.*\\]$/,\n      ta = /:(.*)$/,\n      na = /^:|^\\.|^v-bind:/,\n      ra = /\\.[^.\\]]+(?=[^\\]]*$)/g,\n      ia = /^v-slot(:|$)|^#/,\n      oa = /[\\r\\n]/,\n      aa = /\\s+/g,\n      sa = g(_o),\n      ca = \"_empty_\";\n\n  function ua(e, t, n) {\n    return {\n      type: 1,\n      tag: e,\n      attrsList: t,\n      attrsMap: ma(t),\n      rawAttrsMap: {},\n      parent: n,\n      children: []\n    };\n  }\n\n  function la(e, t) {\n    Bo = t.warn || Sr, Jo = t.isPreTag || T, qo = t.mustUseProp || T, Wo = t.getTagNamespace || T;\n    t.isReservedTag;\n    zo = Tr(t.modules, \"transformNode\"), Vo = Tr(t.modules, \"preTransformNode\"), Ko = Tr(t.modules, \"postTransformNode\"), Uo = t.delimiters;\n    var n,\n        r,\n        i = [],\n        o = !1 !== t.preserveWhitespace,\n        a = t.whitespace,\n        s = !1,\n        c = !1;\n\n    function u(e) {\n      if (l(e), s || e.processed || (e = fa(e, t)), i.length || e === n || n.if && (e.elseif || e.else) && da(n, {\n        exp: e.elseif,\n        block: e\n      }), r && !e.forbidden) if (e.elseif || e.else) a = e, (u = function (e) {\n        var t = e.length;\n\n        for (; t--;) {\n          if (1 === e[t].type) return e[t];\n          e.pop();\n        }\n      }(r.children)) && u.if && da(u, {\n        exp: a.elseif,\n        block: a\n      });else {\n        if (e.slotScope) {\n          var o = e.slotTarget || '\"default\"';\n          (r.scopedSlots || (r.scopedSlots = {}))[o] = e;\n        }\n\n        r.children.push(e), e.parent = r;\n      }\n      var a, u;\n      e.children = e.children.filter(function (e) {\n        return !e.slotScope;\n      }), l(e), e.pre && (s = !1), Jo(e.tag) && (c = !1);\n\n      for (var f = 0; f < Ko.length; f++) {\n        Ko[f](e, t);\n      }\n    }\n\n    function l(e) {\n      if (!c) for (var t; (t = e.children[e.children.length - 1]) && 3 === t.type && \" \" === t.text;) {\n        e.children.pop();\n      }\n    }\n\n    return function (e, t) {\n      for (var n, r, i = [], o = t.expectHTML, a = t.isUnaryTag || T, s = t.canBeLeftOpenTag || T, c = 0; e;) {\n        if (n = e, r && Do(r)) {\n          var u = 0,\n              l = r.toLowerCase(),\n              f = Lo[l] || (Lo[l] = new RegExp(\"([\\\\s\\\\S]*?)(</\" + l + \"[^>]*>)\", \"i\")),\n              p = e.replace(f, function (e, n, r) {\n            return u = r.length, Do(l) || \"noscript\" === l || (n = n.replace(/<!\\--([\\s\\S]*?)-->/g, \"$1\").replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1\")), Ro(l, n) && (n = n.slice(1)), t.chars && t.chars(n), \"\";\n          });\n          c += e.length - p.length, e = p, A(l, c - u, c);\n        } else {\n          var d = e.indexOf(\"<\");\n\n          if (0 === d) {\n            if (No.test(e)) {\n              var v = e.indexOf(\"--\\x3e\");\n\n              if (v >= 0) {\n                t.shouldKeepComment && t.comment(e.substring(4, v), c, c + v + 3), C(v + 3);\n                continue;\n              }\n            }\n\n            if (jo.test(e)) {\n              var h = e.indexOf(\"]>\");\n\n              if (h >= 0) {\n                C(h + 2);\n                continue;\n              }\n            }\n\n            var m = e.match(Eo);\n\n            if (m) {\n              C(m[0].length);\n              continue;\n            }\n\n            var y = e.match(To);\n\n            if (y) {\n              var g = c;\n              C(y[0].length), A(y[1], g, c);\n              continue;\n            }\n\n            var _ = x();\n\n            if (_) {\n              k(_), Ro(_.tagName, e) && C(1);\n              continue;\n            }\n          }\n\n          var b = void 0,\n              $ = void 0,\n              w = void 0;\n\n          if (d >= 0) {\n            for ($ = e.slice(d); !(To.test($) || Oo.test($) || No.test($) || jo.test($) || (w = $.indexOf(\"<\", 1)) < 0);) {\n              d += w, $ = e.slice(d);\n            }\n\n            b = e.substring(0, d);\n          }\n\n          d < 0 && (b = e), b && C(b.length), t.chars && b && t.chars(b, c - b.length, c);\n        }\n\n        if (e === n) {\n          t.chars && t.chars(e);\n          break;\n        }\n      }\n\n      function C(t) {\n        c += t, e = e.substring(t);\n      }\n\n      function x() {\n        var t = e.match(Oo);\n\n        if (t) {\n          var n,\n              r,\n              i = {\n            tagName: t[1],\n            attrs: [],\n            start: c\n          };\n\n          for (C(t[0].length); !(n = e.match(So)) && (r = e.match(xo) || e.match(Co));) {\n            r.start = c, C(r[0].length), r.end = c, i.attrs.push(r);\n          }\n\n          if (n) return i.unarySlash = n[1], C(n[0].length), i.end = c, i;\n        }\n      }\n\n      function k(e) {\n        var n = e.tagName,\n            c = e.unarySlash;\n        o && (\"p\" === r && wo(n) && A(r), s(n) && r === n && A(n));\n\n        for (var u = a(n) || !!c, l = e.attrs.length, f = new Array(l), p = 0; p < l; p++) {\n          var d = e.attrs[p],\n              v = d[3] || d[4] || d[5] || \"\",\n              h = \"a\" === n && \"href\" === d[1] ? t.shouldDecodeNewlinesForHref : t.shouldDecodeNewlines;\n          f[p] = {\n            name: d[1],\n            value: Ho(v, h)\n          };\n        }\n\n        u || (i.push({\n          tag: n,\n          lowerCasedTag: n.toLowerCase(),\n          attrs: f,\n          start: e.start,\n          end: e.end\n        }), r = n), t.start && t.start(n, f, u, e.start, e.end);\n      }\n\n      function A(e, n, o) {\n        var a, s;\n        if (null == n && (n = c), null == o && (o = c), e) for (s = e.toLowerCase(), a = i.length - 1; a >= 0 && i[a].lowerCasedTag !== s; a--) {\n          ;\n        } else a = 0;\n\n        if (a >= 0) {\n          for (var u = i.length - 1; u >= a; u--) {\n            t.end && t.end(i[u].tag, n, o);\n          }\n\n          i.length = a, r = a && i[a - 1].tag;\n        } else \"br\" === s ? t.start && t.start(e, [], !0, n, o) : \"p\" === s && (t.start && t.start(e, [], !1, n, o), t.end && t.end(e, n, o));\n      }\n\n      A();\n    }(e, {\n      warn: Bo,\n      expectHTML: t.expectHTML,\n      isUnaryTag: t.isUnaryTag,\n      canBeLeftOpenTag: t.canBeLeftOpenTag,\n      shouldDecodeNewlines: t.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: t.shouldDecodeNewlinesForHref,\n      shouldKeepComment: t.comments,\n      outputSourceRange: t.outputSourceRange,\n      start: function start(e, o, a, l, f) {\n        var p = r && r.ns || Wo(e);\n        q && \"svg\" === p && (o = function (e) {\n          for (var t = [], n = 0; n < e.length; n++) {\n            var r = e[n];\n            ya.test(r.name) || (r.name = r.name.replace(ga, \"\"), t.push(r));\n          }\n\n          return t;\n        }(o));\n        var d,\n            v = ua(e, o, r);\n        p && (v.ns = p), \"style\" !== (d = v).tag && (\"script\" !== d.tag || d.attrsMap.type && \"text/javascript\" !== d.attrsMap.type) || te() || (v.forbidden = !0);\n\n        for (var h = 0; h < Vo.length; h++) {\n          v = Vo[h](v, t) || v;\n        }\n\n        s || (!function (e) {\n          null != Fr(e, \"v-pre\") && (e.pre = !0);\n        }(v), v.pre && (s = !0)), Jo(v.tag) && (c = !0), s ? function (e) {\n          var t = e.attrsList,\n              n = t.length;\n          if (n) for (var r = e.attrs = new Array(n), i = 0; i < n; i++) {\n            r[i] = {\n              name: t[i].name,\n              value: JSON.stringify(t[i].value)\n            }, null != t[i].start && (r[i].start = t[i].start, r[i].end = t[i].end);\n          } else e.pre || (e.plain = !0);\n        }(v) : v.processed || (pa(v), function (e) {\n          var t = Fr(e, \"v-if\");\n          if (t) e.if = t, da(e, {\n            exp: t,\n            block: e\n          });else {\n            null != Fr(e, \"v-else\") && (e.else = !0);\n            var n = Fr(e, \"v-else-if\");\n            n && (e.elseif = n);\n          }\n        }(v), function (e) {\n          null != Fr(e, \"v-once\") && (e.once = !0);\n        }(v)), n || (n = v), a ? u(v) : (r = v, i.push(v));\n      },\n      end: function end(e, t, n) {\n        var o = i[i.length - 1];\n        i.length -= 1, r = i[i.length - 1], u(o);\n      },\n      chars: function chars(e, t, n) {\n        if (r && (!q || \"textarea\" !== r.tag || r.attrsMap.placeholder !== e)) {\n          var i,\n              u,\n              l,\n              f = r.children;\n          if (e = c || e.trim() ? \"script\" === (i = r).tag || \"style\" === i.tag ? e : sa(e) : f.length ? a ? \"condense\" === a && oa.test(e) ? \"\" : \" \" : o ? \" \" : \"\" : \"\") c || \"condense\" !== a || (e = e.replace(aa, \" \")), !s && \" \" !== e && (u = function (e, t) {\n            var n = t ? ho(t) : po;\n\n            if (n.test(e)) {\n              for (var r, i, o, a = [], s = [], c = n.lastIndex = 0; r = n.exec(e);) {\n                (i = r.index) > c && (s.push(o = e.slice(c, i)), a.push(JSON.stringify(o)));\n                var u = Ar(r[1].trim());\n                a.push(\"_s(\" + u + \")\"), s.push({\n                  \"@binding\": u\n                }), c = i + r[0].length;\n              }\n\n              return c < e.length && (s.push(o = e.slice(c)), a.push(JSON.stringify(o))), {\n                expression: a.join(\"+\"),\n                tokens: s\n              };\n            }\n          }(e, Uo)) ? l = {\n            type: 2,\n            expression: u.expression,\n            tokens: u.tokens,\n            text: e\n          } : \" \" === e && f.length && \" \" === f[f.length - 1].text || (l = {\n            type: 3,\n            text: e\n          }), l && f.push(l);\n        }\n      },\n      comment: function comment(e, t, n) {\n        if (r) {\n          var i = {\n            type: 3,\n            text: e,\n            isComment: !0\n          };\n          r.children.push(i);\n        }\n      }\n    }), n;\n  }\n\n  function fa(e, t) {\n    var n, r;\n    (r = Ir(n = e, \"key\")) && (n.key = r), e.plain = !e.key && !e.scopedSlots && !e.attrsList.length, function (e) {\n      var t = Ir(e, \"ref\");\n      t && (e.ref = t, e.refInFor = function (e) {\n        var t = e;\n\n        for (; t;) {\n          if (void 0 !== t.for) return !0;\n          t = t.parent;\n        }\n\n        return !1;\n      }(e));\n    }(e), function (e) {\n      var t;\n      \"template\" === e.tag ? (t = Fr(e, \"scope\"), e.slotScope = t || Fr(e, \"slot-scope\")) : (t = Fr(e, \"slot-scope\")) && (e.slotScope = t);\n      var n = Ir(e, \"slot\");\n      n && (e.slotTarget = '\"\"' === n ? '\"default\"' : n, e.slotTargetDynamic = !(!e.attrsMap[\":slot\"] && !e.attrsMap[\"v-bind:slot\"]), \"template\" === e.tag || e.slotScope || Nr(e, \"slot\", n, function (e, t) {\n        return e.rawAttrsMap[\":\" + t] || e.rawAttrsMap[\"v-bind:\" + t] || e.rawAttrsMap[t];\n      }(e, \"slot\")));\n\n      if (\"template\" === e.tag) {\n        var r = Pr(e, ia);\n\n        if (r) {\n          var i = va(r),\n              o = i.name,\n              a = i.dynamic;\n          e.slotTarget = o, e.slotTargetDynamic = a, e.slotScope = r.value || ca;\n        }\n      } else {\n        var s = Pr(e, ia);\n\n        if (s) {\n          var c = e.scopedSlots || (e.scopedSlots = {}),\n              u = va(s),\n              l = u.name,\n              f = u.dynamic,\n              p = c[l] = ua(\"template\", [], e);\n          p.slotTarget = l, p.slotTargetDynamic = f, p.children = e.children.filter(function (e) {\n            if (!e.slotScope) return e.parent = p, !0;\n          }), p.slotScope = s.value || ca, e.children = [], e.plain = !1;\n        }\n      }\n    }(e), function (e) {\n      \"slot\" === e.tag && (e.slotName = Ir(e, \"name\"));\n    }(e), function (e) {\n      var t;\n      (t = Ir(e, \"is\")) && (e.component = t);\n      null != Fr(e, \"inline-template\") && (e.inlineTemplate = !0);\n    }(e);\n\n    for (var i = 0; i < zo.length; i++) {\n      e = zo[i](e, t) || e;\n    }\n\n    return function (e) {\n      var t,\n          n,\n          r,\n          i,\n          o,\n          a,\n          s,\n          c,\n          u = e.attrsList;\n\n      for (t = 0, n = u.length; t < n; t++) {\n        if (r = i = u[t].name, o = u[t].value, Go.test(r)) {\n          if (e.hasBindings = !0, (a = ha(r.replace(Go, \"\"))) && (r = r.replace(ra, \"\")), na.test(r)) r = r.replace(na, \"\"), o = Ar(o), (c = ea.test(r)) && (r = r.slice(1, -1)), a && (a.prop && !c && \"innerHtml\" === (r = b(r)) && (r = \"innerHTML\"), a.camel && !c && (r = b(r)), a.sync && (s = Br(o, \"$event\"), c ? Mr(e, '\"update:\"+(' + r + \")\", s, null, !1, 0, u[t], !0) : (Mr(e, \"update:\" + b(r), s, null, !1, 0, u[t]), C(r) !== b(r) && Mr(e, \"update:\" + C(r), s, null, !1, 0, u[t])))), a && a.prop || !e.component && qo(e.tag, e.attrsMap.type, r) ? Er(e, r, o, u[t], c) : Nr(e, r, o, u[t], c);else if (Zo.test(r)) r = r.replace(Zo, \"\"), (c = ea.test(r)) && (r = r.slice(1, -1)), Mr(e, r, o, a, !1, 0, u[t], c);else {\n            var l = (r = r.replace(Go, \"\")).match(ta),\n                f = l && l[1];\n            c = !1, f && (r = r.slice(0, -(f.length + 1)), ea.test(f) && (f = f.slice(1, -1), c = !0)), Dr(e, r, i, o, f, c, a, u[t]);\n          }\n        } else Nr(e, r, JSON.stringify(o), u[t]), !e.component && \"muted\" === r && qo(e.tag, e.attrsMap.type, r) && Er(e, r, \"true\", u[t]);\n      }\n    }(e), e;\n  }\n\n  function pa(e) {\n    var t;\n\n    if (t = Fr(e, \"v-for\")) {\n      var n = function (e) {\n        var t = e.match(Xo);\n        if (!t) return;\n        var n = {};\n        n.for = t[2].trim();\n        var r = t[1].trim().replace(Qo, \"\"),\n            i = r.match(Yo);\n        i ? (n.alias = r.replace(Yo, \"\").trim(), n.iterator1 = i[1].trim(), i[2] && (n.iterator2 = i[2].trim())) : n.alias = r;\n        return n;\n      }(t);\n\n      n && A(e, n);\n    }\n  }\n\n  function da(e, t) {\n    e.ifConditions || (e.ifConditions = []), e.ifConditions.push(t);\n  }\n\n  function va(e) {\n    var t = e.name.replace(ia, \"\");\n    return t || \"#\" !== e.name[0] && (t = \"default\"), ea.test(t) ? {\n      name: t.slice(1, -1),\n      dynamic: !0\n    } : {\n      name: '\"' + t + '\"',\n      dynamic: !1\n    };\n  }\n\n  function ha(e) {\n    var t = e.match(ra);\n\n    if (t) {\n      var n = {};\n      return t.forEach(function (e) {\n        n[e.slice(1)] = !0;\n      }), n;\n    }\n  }\n\n  function ma(e) {\n    for (var t = {}, n = 0, r = e.length; n < r; n++) {\n      t[e[n].name] = e[n].value;\n    }\n\n    return t;\n  }\n\n  var ya = /^xmlns:NS\\d+/,\n      ga = /^NS\\d+:/;\n\n  function _a(e) {\n    return ua(e.tag, e.attrsList.slice(), e.parent);\n  }\n\n  var ba = [mo, go, {\n    preTransformNode: function preTransformNode(e, t) {\n      if (\"input\" === e.tag) {\n        var n,\n            r = e.attrsMap;\n        if (!r[\"v-model\"]) return;\n\n        if ((r[\":type\"] || r[\"v-bind:type\"]) && (n = Ir(e, \"type\")), r.type || n || !r[\"v-bind\"] || (n = \"(\" + r[\"v-bind\"] + \").type\"), n) {\n          var i = Fr(e, \"v-if\", !0),\n              o = i ? \"&&(\" + i + \")\" : \"\",\n              a = null != Fr(e, \"v-else\", !0),\n              s = Fr(e, \"v-else-if\", !0),\n              c = _a(e);\n\n          pa(c), jr(c, \"type\", \"checkbox\"), fa(c, t), c.processed = !0, c.if = \"(\" + n + \")==='checkbox'\" + o, da(c, {\n            exp: c.if,\n            block: c\n          });\n\n          var u = _a(e);\n\n          Fr(u, \"v-for\", !0), jr(u, \"type\", \"radio\"), fa(u, t), da(c, {\n            exp: \"(\" + n + \")==='radio'\" + o,\n            block: u\n          });\n\n          var l = _a(e);\n\n          return Fr(l, \"v-for\", !0), jr(l, \":type\", n), fa(l, t), da(c, {\n            exp: i,\n            block: l\n          }), a ? c.else = !0 : s && (c.elseif = s), c;\n        }\n      }\n    }\n  }];\n  var $a,\n      wa,\n      Ca = {\n    expectHTML: !0,\n    modules: ba,\n    directives: {\n      model: function model(e, t, n) {\n        var r = t.value,\n            i = t.modifiers,\n            o = e.tag,\n            a = e.attrsMap.type;\n        if (e.component) return Hr(e, r, i), !1;\n        if (\"select\" === o) !function (e, t, n) {\n          var r = 'var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = \"_value\" in o ? o._value : o.value;return ' + (n && n.number ? \"_n(val)\" : \"val\") + \"});\";\n          r = r + \" \" + Br(t, \"$event.target.multiple ? $$selectedVal : $$selectedVal[0]\"), Mr(e, \"change\", r, null, !0);\n        }(e, r, i);else if (\"input\" === o && \"checkbox\" === a) !function (e, t, n) {\n          var r = n && n.number,\n              i = Ir(e, \"value\") || \"null\",\n              o = Ir(e, \"true-value\") || \"true\",\n              a = Ir(e, \"false-value\") || \"false\";\n          Er(e, \"checked\", \"Array.isArray(\" + t + \")?_i(\" + t + \",\" + i + \")>-1\" + (\"true\" === o ? \":(\" + t + \")\" : \":_q(\" + t + \",\" + o + \")\")), Mr(e, \"change\", \"var $$a=\" + t + \",$$el=$event.target,$$c=$$el.checked?(\" + o + \"):(\" + a + \");if(Array.isArray($$a)){var $$v=\" + (r ? \"_n(\" + i + \")\" : i) + \",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(\" + Br(t, \"$$a.concat([$$v])\") + \")}else{$$i>-1&&(\" + Br(t, \"$$a.slice(0,$$i).concat($$a.slice($$i+1))\") + \")}}else{\" + Br(t, \"$$c\") + \"}\", null, !0);\n        }(e, r, i);else if (\"input\" === o && \"radio\" === a) !function (e, t, n) {\n          var r = n && n.number,\n              i = Ir(e, \"value\") || \"null\";\n          Er(e, \"checked\", \"_q(\" + t + \",\" + (i = r ? \"_n(\" + i + \")\" : i) + \")\"), Mr(e, \"change\", Br(t, i), null, !0);\n        }(e, r, i);else if (\"input\" === o || \"textarea\" === o) !function (e, t, n) {\n          var r = e.attrsMap.type,\n              i = n || {},\n              o = i.lazy,\n              a = i.number,\n              s = i.trim,\n              c = !o && \"range\" !== r,\n              u = o ? \"change\" : \"range\" === r ? Wr : \"input\",\n              l = \"$event.target.value\";\n          s && (l = \"$event.target.value.trim()\"), a && (l = \"_n(\" + l + \")\");\n          var f = Br(t, l);\n          c && (f = \"if($event.target.composing)return;\" + f), Er(e, \"value\", \"(\" + t + \")\"), Mr(e, u, f, null, !0), (s || a) && Mr(e, \"blur\", \"$forceUpdate()\");\n        }(e, r, i);else if (!F.isReservedTag(o)) return Hr(e, r, i), !1;\n        return !0;\n      },\n      text: function text(e, t) {\n        t.value && Er(e, \"textContent\", \"_s(\" + t.value + \")\", t);\n      },\n      html: function html(e, t) {\n        t.value && Er(e, \"innerHTML\", \"_s(\" + t.value + \")\", t);\n      }\n    },\n    isPreTag: function isPreTag(e) {\n      return \"pre\" === e;\n    },\n    isUnaryTag: bo,\n    mustUseProp: jn,\n    canBeLeftOpenTag: $o,\n    isReservedTag: Wn,\n    getTagNamespace: Zn,\n    staticKeys: function (e) {\n      return e.reduce(function (e, t) {\n        return e.concat(t.staticKeys || []);\n      }, []).join(\",\");\n    }(ba)\n  },\n      xa = g(function (e) {\n    return p(\"type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap\" + (e ? \",\" + e : \"\"));\n  });\n\n  function ka(e, t) {\n    e && ($a = xa(t.staticKeys || \"\"), wa = t.isReservedTag || T, function e(t) {\n      t.static = function (e) {\n        if (2 === e.type) return !1;\n        if (3 === e.type) return !0;\n        return !(!e.pre && (e.hasBindings || e.if || e.for || d(e.tag) || !wa(e.tag) || function (e) {\n          for (; e.parent;) {\n            if (\"template\" !== (e = e.parent).tag) return !1;\n            if (e.for) return !0;\n          }\n\n          return !1;\n        }(e) || !Object.keys(e).every($a)));\n      }(t);\n\n      if (1 === t.type) {\n        if (!wa(t.tag) && \"slot\" !== t.tag && null == t.attrsMap[\"inline-template\"]) return;\n\n        for (var n = 0, r = t.children.length; n < r; n++) {\n          var i = t.children[n];\n          e(i), i.static || (t.static = !1);\n        }\n\n        if (t.ifConditions) for (var o = 1, a = t.ifConditions.length; o < a; o++) {\n          var s = t.ifConditions[o].block;\n          e(s), s.static || (t.static = !1);\n        }\n      }\n    }(e), function e(t, n) {\n      if (1 === t.type) {\n        if ((t.static || t.once) && (t.staticInFor = n), t.static && t.children.length && (1 !== t.children.length || 3 !== t.children[0].type)) return void (t.staticRoot = !0);\n        if (t.staticRoot = !1, t.children) for (var r = 0, i = t.children.length; r < i; r++) {\n          e(t.children[r], n || !!t.for);\n        }\n        if (t.ifConditions) for (var o = 1, a = t.ifConditions.length; o < a; o++) {\n          e(t.ifConditions[o].block, n);\n        }\n      }\n    }(e, !1));\n  }\n\n  var Aa = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/,\n      Oa = /\\([^)]*?\\);*$/,\n      Sa = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/,\n      Ta = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    delete: [8, 46]\n  },\n      Ea = {\n    esc: [\"Esc\", \"Escape\"],\n    tab: \"Tab\",\n    enter: \"Enter\",\n    space: [\" \", \"Spacebar\"],\n    up: [\"Up\", \"ArrowUp\"],\n    left: [\"Left\", \"ArrowLeft\"],\n    right: [\"Right\", \"ArrowRight\"],\n    down: [\"Down\", \"ArrowDown\"],\n    delete: [\"Backspace\", \"Delete\", \"Del\"]\n  },\n      Na = function Na(e) {\n    return \"if(\" + e + \")return null;\";\n  },\n      ja = {\n    stop: \"$event.stopPropagation();\",\n    prevent: \"$event.preventDefault();\",\n    self: Na(\"$event.target !== $event.currentTarget\"),\n    ctrl: Na(\"!$event.ctrlKey\"),\n    shift: Na(\"!$event.shiftKey\"),\n    alt: Na(\"!$event.altKey\"),\n    meta: Na(\"!$event.metaKey\"),\n    left: Na(\"'button' in $event && $event.button !== 0\"),\n    middle: Na(\"'button' in $event && $event.button !== 1\"),\n    right: Na(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function Da(e, t) {\n    var n = t ? \"nativeOn:\" : \"on:\",\n        r = \"\",\n        i = \"\";\n\n    for (var o in e) {\n      var a = La(e[o]);\n      e[o] && e[o].dynamic ? i += o + \",\" + a + \",\" : r += '\"' + o + '\":' + a + \",\";\n    }\n\n    return r = \"{\" + r.slice(0, -1) + \"}\", i ? n + \"_d(\" + r + \",[\" + i.slice(0, -1) + \"])\" : n + r;\n  }\n\n  function La(e) {\n    if (!e) return \"function(){}\";\n    if (Array.isArray(e)) return \"[\" + e.map(function (e) {\n      return La(e);\n    }).join(\",\") + \"]\";\n    var t = Sa.test(e.value),\n        n = Aa.test(e.value),\n        r = Sa.test(e.value.replace(Oa, \"\"));\n\n    if (e.modifiers) {\n      var i = \"\",\n          o = \"\",\n          a = [];\n\n      for (var s in e.modifiers) {\n        if (ja[s]) o += ja[s], Ta[s] && a.push(s);else if (\"exact\" === s) {\n          var c = e.modifiers;\n          o += Na([\"ctrl\", \"shift\", \"alt\", \"meta\"].filter(function (e) {\n            return !c[e];\n          }).map(function (e) {\n            return \"$event.\" + e + \"Key\";\n          }).join(\"||\"));\n        } else a.push(s);\n      }\n\n      return a.length && (i += function (e) {\n        return \"if(!$event.type.indexOf('key')&&\" + e.map(Ma).join(\"&&\") + \")return null;\";\n      }(a)), o && (i += o), \"function($event){\" + i + (t ? \"return \" + e.value + \"($event)\" : n ? \"return (\" + e.value + \")($event)\" : r ? \"return \" + e.value : e.value) + \"}\";\n    }\n\n    return t || n ? e.value : \"function($event){\" + (r ? \"return \" + e.value : e.value) + \"}\";\n  }\n\n  function Ma(e) {\n    var t = parseInt(e, 10);\n    if (t) return \"$event.keyCode!==\" + t;\n    var n = Ta[e],\n        r = Ea[e];\n    return \"_k($event.keyCode,\" + JSON.stringify(e) + \",\" + JSON.stringify(n) + \",$event.key,\" + JSON.stringify(r) + \")\";\n  }\n\n  var Ia = {\n    on: function on(e, t) {\n      e.wrapListeners = function (e) {\n        return \"_g(\" + e + \",\" + t.value + \")\";\n      };\n    },\n    bind: function bind(e, t) {\n      e.wrapData = function (n) {\n        return \"_b(\" + n + \",'\" + e.tag + \"',\" + t.value + \",\" + (t.modifiers && t.modifiers.prop ? \"true\" : \"false\") + (t.modifiers && t.modifiers.sync ? \",true\" : \"\") + \")\";\n      };\n    },\n    cloak: S\n  },\n      Fa = function Fa(e) {\n    this.options = e, this.warn = e.warn || Sr, this.transforms = Tr(e.modules, \"transformCode\"), this.dataGenFns = Tr(e.modules, \"genData\"), this.directives = A(A({}, Ia), e.directives);\n    var t = e.isReservedTag || T;\n    this.maybeComponent = function (e) {\n      return !!e.component || !t(e.tag);\n    }, this.onceId = 0, this.staticRenderFns = [], this.pre = !1;\n  };\n\n  function Pa(e, t) {\n    var n = new Fa(t);\n    return {\n      render: \"with(this){return \" + (e ? Ra(e, n) : '_c(\"div\")') + \"}\",\n      staticRenderFns: n.staticRenderFns\n    };\n  }\n\n  function Ra(e, t) {\n    if (e.parent && (e.pre = e.pre || e.parent.pre), e.staticRoot && !e.staticProcessed) return Ha(e, t);\n    if (e.once && !e.onceProcessed) return Ba(e, t);\n    if (e.for && !e.forProcessed) return za(e, t);\n    if (e.if && !e.ifProcessed) return Ua(e, t);\n\n    if (\"template\" !== e.tag || e.slotTarget || t.pre) {\n      if (\"slot\" === e.tag) return function (e, t) {\n        var n = e.slotName || '\"default\"',\n            r = qa(e, t),\n            i = \"_t(\" + n + (r ? \",\" + r : \"\"),\n            o = e.attrs || e.dynamicAttrs ? Ga((e.attrs || []).concat(e.dynamicAttrs || []).map(function (e) {\n          return {\n            name: b(e.name),\n            value: e.value,\n            dynamic: e.dynamic\n          };\n        })) : null,\n            a = e.attrsMap[\"v-bind\"];\n        !o && !a || r || (i += \",null\");\n        o && (i += \",\" + o);\n        a && (i += (o ? \"\" : \",null\") + \",\" + a);\n        return i + \")\";\n      }(e, t);\n      var n;\n      if (e.component) n = function (e, t, n) {\n        var r = t.inlineTemplate ? null : qa(t, n, !0);\n        return \"_c(\" + e + \",\" + Va(t, n) + (r ? \",\" + r : \"\") + \")\";\n      }(e.component, e, t);else {\n        var r;\n        (!e.plain || e.pre && t.maybeComponent(e)) && (r = Va(e, t));\n        var i = e.inlineTemplate ? null : qa(e, t, !0);\n        n = \"_c('\" + e.tag + \"'\" + (r ? \",\" + r : \"\") + (i ? \",\" + i : \"\") + \")\";\n      }\n\n      for (var o = 0; o < t.transforms.length; o++) {\n        n = t.transforms[o](e, n);\n      }\n\n      return n;\n    }\n\n    return qa(e, t) || \"void 0\";\n  }\n\n  function Ha(e, t) {\n    e.staticProcessed = !0;\n    var n = t.pre;\n    return e.pre && (t.pre = e.pre), t.staticRenderFns.push(\"with(this){return \" + Ra(e, t) + \"}\"), t.pre = n, \"_m(\" + (t.staticRenderFns.length - 1) + (e.staticInFor ? \",true\" : \"\") + \")\";\n  }\n\n  function Ba(e, t) {\n    if (e.onceProcessed = !0, e.if && !e.ifProcessed) return Ua(e, t);\n\n    if (e.staticInFor) {\n      for (var n = \"\", r = e.parent; r;) {\n        if (r.for) {\n          n = r.key;\n          break;\n        }\n\n        r = r.parent;\n      }\n\n      return n ? \"_o(\" + Ra(e, t) + \",\" + t.onceId++ + \",\" + n + \")\" : Ra(e, t);\n    }\n\n    return Ha(e, t);\n  }\n\n  function Ua(e, t, n, r) {\n    return e.ifProcessed = !0, function e(t, n, r, i) {\n      if (!t.length) return i || \"_e()\";\n      var o = t.shift();\n      return o.exp ? \"(\" + o.exp + \")?\" + a(o.block) + \":\" + e(t, n, r, i) : \"\" + a(o.block);\n\n      function a(e) {\n        return r ? r(e, n) : e.once ? Ba(e, n) : Ra(e, n);\n      }\n    }(e.ifConditions.slice(), t, n, r);\n  }\n\n  function za(e, t, n, r) {\n    var i = e.for,\n        o = e.alias,\n        a = e.iterator1 ? \",\" + e.iterator1 : \"\",\n        s = e.iterator2 ? \",\" + e.iterator2 : \"\";\n    return e.forProcessed = !0, (r || \"_l\") + \"((\" + i + \"),function(\" + o + a + s + \"){return \" + (n || Ra)(e, t) + \"})\";\n  }\n\n  function Va(e, t) {\n    var n = \"{\",\n        r = function (e, t) {\n      var n = e.directives;\n      if (!n) return;\n      var r,\n          i,\n          o,\n          a,\n          s = \"directives:[\",\n          c = !1;\n\n      for (r = 0, i = n.length; r < i; r++) {\n        o = n[r], a = !0;\n        var u = t.directives[o.name];\n        u && (a = !!u(e, o, t.warn)), a && (c = !0, s += '{name:\"' + o.name + '\",rawName:\"' + o.rawName + '\"' + (o.value ? \",value:(\" + o.value + \"),expression:\" + JSON.stringify(o.value) : \"\") + (o.arg ? \",arg:\" + (o.isDynamicArg ? o.arg : '\"' + o.arg + '\"') : \"\") + (o.modifiers ? \",modifiers:\" + JSON.stringify(o.modifiers) : \"\") + \"},\");\n      }\n\n      if (c) return s.slice(0, -1) + \"]\";\n    }(e, t);\n\n    r && (n += r + \",\"), e.key && (n += \"key:\" + e.key + \",\"), e.ref && (n += \"ref:\" + e.ref + \",\"), e.refInFor && (n += \"refInFor:true,\"), e.pre && (n += \"pre:true,\"), e.component && (n += 'tag:\"' + e.tag + '\",');\n\n    for (var i = 0; i < t.dataGenFns.length; i++) {\n      n += t.dataGenFns[i](e);\n    }\n\n    if (e.attrs && (n += \"attrs:\" + Ga(e.attrs) + \",\"), e.props && (n += \"domProps:\" + Ga(e.props) + \",\"), e.events && (n += Da(e.events, !1) + \",\"), e.nativeEvents && (n += Da(e.nativeEvents, !0) + \",\"), e.slotTarget && !e.slotScope && (n += \"slot:\" + e.slotTarget + \",\"), e.scopedSlots && (n += function (e, t, n) {\n      var r = e.for || Object.keys(t).some(function (e) {\n        var n = t[e];\n        return n.slotTargetDynamic || n.if || n.for || Ka(n);\n      }),\n          i = !!e.if;\n      if (!r) for (var o = e.parent; o;) {\n        if (o.slotScope && o.slotScope !== ca || o.for) {\n          r = !0;\n          break;\n        }\n\n        o.if && (i = !0), o = o.parent;\n      }\n      var a = Object.keys(t).map(function (e) {\n        return Ja(t[e], n);\n      }).join(\",\");\n      return \"scopedSlots:_u([\" + a + \"]\" + (r ? \",null,true\" : \"\") + (!r && i ? \",null,false,\" + function (e) {\n        var t = 5381,\n            n = e.length;\n\n        for (; n;) {\n          t = 33 * t ^ e.charCodeAt(--n);\n        }\n\n        return t >>> 0;\n      }(a) : \"\") + \")\";\n    }(e, e.scopedSlots, t) + \",\"), e.model && (n += \"model:{value:\" + e.model.value + \",callback:\" + e.model.callback + \",expression:\" + e.model.expression + \"},\"), e.inlineTemplate) {\n      var o = function (e, t) {\n        var n = e.children[0];\n\n        if (n && 1 === n.type) {\n          var r = Pa(n, t.options);\n          return \"inlineTemplate:{render:function(){\" + r.render + \"},staticRenderFns:[\" + r.staticRenderFns.map(function (e) {\n            return \"function(){\" + e + \"}\";\n          }).join(\",\") + \"]}\";\n        }\n      }(e, t);\n\n      o && (n += o + \",\");\n    }\n\n    return n = n.replace(/,$/, \"\") + \"}\", e.dynamicAttrs && (n = \"_b(\" + n + ',\"' + e.tag + '\",' + Ga(e.dynamicAttrs) + \")\"), e.wrapData && (n = e.wrapData(n)), e.wrapListeners && (n = e.wrapListeners(n)), n;\n  }\n\n  function Ka(e) {\n    return 1 === e.type && (\"slot\" === e.tag || e.children.some(Ka));\n  }\n\n  function Ja(e, t) {\n    var n = e.attrsMap[\"slot-scope\"];\n    if (e.if && !e.ifProcessed && !n) return Ua(e, t, Ja, \"null\");\n    if (e.for && !e.forProcessed) return za(e, t, Ja);\n    var r = e.slotScope === ca ? \"\" : String(e.slotScope),\n        i = \"function(\" + r + \"){return \" + (\"template\" === e.tag ? e.if && n ? \"(\" + e.if + \")?\" + (qa(e, t) || \"undefined\") + \":undefined\" : qa(e, t) || \"undefined\" : Ra(e, t)) + \"}\",\n        o = r ? \"\" : \",proxy:true\";\n    return \"{key:\" + (e.slotTarget || '\"default\"') + \",fn:\" + i + o + \"}\";\n  }\n\n  function qa(e, t, n, r, i) {\n    var o = e.children;\n\n    if (o.length) {\n      var a = o[0];\n\n      if (1 === o.length && a.for && \"template\" !== a.tag && \"slot\" !== a.tag) {\n        var s = n ? t.maybeComponent(a) ? \",1\" : \",0\" : \"\";\n        return \"\" + (r || Ra)(a, t) + s;\n      }\n\n      var c = n ? function (e, t) {\n        for (var n = 0, r = 0; r < e.length; r++) {\n          var i = e[r];\n\n          if (1 === i.type) {\n            if (Wa(i) || i.ifConditions && i.ifConditions.some(function (e) {\n              return Wa(e.block);\n            })) {\n              n = 2;\n              break;\n            }\n\n            (t(i) || i.ifConditions && i.ifConditions.some(function (e) {\n              return t(e.block);\n            })) && (n = 1);\n          }\n        }\n\n        return n;\n      }(o, t.maybeComponent) : 0,\n          u = i || Za;\n      return \"[\" + o.map(function (e) {\n        return u(e, t);\n      }).join(\",\") + \"]\" + (c ? \",\" + c : \"\");\n    }\n  }\n\n  function Wa(e) {\n    return void 0 !== e.for || \"template\" === e.tag || \"slot\" === e.tag;\n  }\n\n  function Za(e, t) {\n    return 1 === e.type ? Ra(e, t) : 3 === e.type && e.isComment ? (r = e, \"_e(\" + JSON.stringify(r.text) + \")\") : \"_v(\" + (2 === (n = e).type ? n.expression : Xa(JSON.stringify(n.text))) + \")\";\n    var n, r;\n  }\n\n  function Ga(e) {\n    for (var t = \"\", n = \"\", r = 0; r < e.length; r++) {\n      var i = e[r],\n          o = Xa(i.value);\n      i.dynamic ? n += i.name + \",\" + o + \",\" : t += '\"' + i.name + '\":' + o + \",\";\n    }\n\n    return t = \"{\" + t.slice(0, -1) + \"}\", n ? \"_d(\" + t + \",[\" + n.slice(0, -1) + \"])\" : t;\n  }\n\n  function Xa(e) {\n    return e.replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n  }\n\n  new RegExp(\"\\\\b\" + \"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments\".split(\",\").join(\"\\\\b|\\\\b\") + \"\\\\b\");\n\n  function Ya(e, t) {\n    try {\n      return new Function(e);\n    } catch (n) {\n      return t.push({\n        err: n,\n        code: e\n      }), S;\n    }\n  }\n\n  function Qa(e) {\n    var t = Object.create(null);\n    return function (n, r, i) {\n      (r = A({}, r)).warn;\n      delete r.warn;\n      var o = r.delimiters ? String(r.delimiters) + n : n;\n      if (t[o]) return t[o];\n      var a = e(n, r),\n          s = {},\n          c = [];\n      return s.render = Ya(a.render, c), s.staticRenderFns = a.staticRenderFns.map(function (e) {\n        return Ya(e, c);\n      }), t[o] = s;\n    };\n  }\n\n  var es,\n      ts,\n      ns = (es = function es(e, t) {\n    var n = la(e.trim(), t);\n    !1 !== t.optimize && ka(n, t);\n    var r = Pa(n, t);\n    return {\n      ast: n,\n      render: r.render,\n      staticRenderFns: r.staticRenderFns\n    };\n  }, function (e) {\n    function t(t, n) {\n      var r = Object.create(e),\n          i = [],\n          o = [];\n      if (n) for (var a in n.modules && (r.modules = (e.modules || []).concat(n.modules)), n.directives && (r.directives = A(Object.create(e.directives || null), n.directives)), n) {\n        \"modules\" !== a && \"directives\" !== a && (r[a] = n[a]);\n      }\n\n      r.warn = function (e, t, n) {\n        (n ? o : i).push(e);\n      };\n\n      var s = es(t.trim(), r);\n      return s.errors = i, s.tips = o, s;\n    }\n\n    return {\n      compile: t,\n      compileToFunctions: Qa(t)\n    };\n  })(Ca),\n      rs = (ns.compile, ns.compileToFunctions);\n\n  function is(e) {\n    return (ts = ts || document.createElement(\"div\")).innerHTML = e ? '<a href=\"\\n\"/>' : '<div a=\"\\n\"/>', ts.innerHTML.indexOf(\"&#10;\") > 0;\n  }\n\n  var os = !!z && is(!1),\n      as = !!z && is(!0),\n      ss = g(function (e) {\n    var t = Yn(e);\n    return t && t.innerHTML;\n  }),\n      cs = wn.prototype.$mount;\n  return wn.prototype.$mount = function (e, t) {\n    if ((e = e && Yn(e)) === document.body || e === document.documentElement) return this;\n    var n = this.$options;\n\n    if (!n.render) {\n      var r = n.template;\n      if (r) {\n        if (\"string\" == typeof r) \"#\" === r.charAt(0) && (r = ss(r));else {\n          if (!r.nodeType) return this;\n          r = r.innerHTML;\n        }\n      } else e && (r = function (e) {\n        if (e.outerHTML) return e.outerHTML;\n        var t = document.createElement(\"div\");\n        return t.appendChild(e.cloneNode(!0)), t.innerHTML;\n      }(e));\n\n      if (r) {\n        var i = rs(r, {\n          outputSourceRange: !1,\n          shouldDecodeNewlines: os,\n          shouldDecodeNewlinesForHref: as,\n          delimiters: n.delimiters,\n          comments: n.comments\n        }, this),\n            o = i.render,\n            a = i.staticRenderFns;\n        n.render = o, n.staticRenderFns = a;\n      }\n    }\n\n    return cs.call(this, e, t);\n  }, wn.compile = rs, wn;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/vue/dist/vue.min.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./sass/app.scss":
/*!***********************!*\
  !*** ./sass/app.scss ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./sass/app.scss?");

/***/ }),

/***/ 0:
/*!********************************************!*\
  !*** multi ./js/source.js ./sass/app.scss ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./js/source.js */\"./js/source.js\");\nmodule.exports = __webpack_require__(/*! ./sass/app.scss */\"./sass/app.scss\");\n\n\n//# sourceURL=webpack:///multi_./js/source.js_./sass/app.scss?");

/***/ })

/******/ });